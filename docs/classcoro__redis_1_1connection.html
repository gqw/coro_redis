<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coro_rediis: coro_redis::connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coro_rediis
   &#160;<span id="projectnumber">1.0.0.0</span>
   </div>
   <div id="projectbrief">C++ Corotine Redis Client</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>coro_redis</b></li><li class="navelem"><a class="el" href="classcoro__redis_1_1connection.html">connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcoro__redis_1_1connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">coro_redis::connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa24b8752d129cfd705bd9f659ad39078"><td class="memItemLeft" align="right" valign="top"><a id="aa24b8752d129cfd705bd9f659ad39078"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BitOp</b> { <b>AND</b>, 
<b>OR</b>, 
<b>XOR</b>, 
<b>NOT</b>
 }</td></tr>
<tr class="separator:aa24b8752d129cfd705bd9f659ad39078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20988027a51d01c169d56ef864386e6"><td class="memTemplParams" colspan="2"><a id="aa20988027a51d01c169d56ef864386e6"></a>
template&lt;typename CORO_RET &gt; </td></tr>
<tr class="memitem:aa20988027a51d01c169d56ef864386e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>awaiter_t</b> = <a class="el" href="structcoro__redis_1_1task__awaiter.html">task_awaiter</a>&lt; CORO_RET, redisReply * &gt;</td></tr>
<tr class="separator:aa20988027a51d01c169d56ef864386e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0519c5881b863daeda215f7920d351"><td class="memItemLeft" align="right" valign="top"><a id="afd0519c5881b863daeda215f7920d351"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>scan_ret_t</b> = std::pair&lt; uint64_t, std::vector&lt; std::string &gt; &gt;</td></tr>
<tr class="separator:afd0519c5881b863daeda215f7920d351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191dc94ee0ecf3dcce572f4bcc83000a"><td class="memItemLeft" align="right" valign="top"><a id="a191dc94ee0ecf3dcce572f4bcc83000a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cptr</b> = std::shared_ptr&lt; <a class="el" href="classcoro__redis_1_1connection.html">connection</a> &gt;</td></tr>
<tr class="separator:a191dc94ee0ecf3dcce572f4bcc83000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a811689f90c9f0c616e759708fbf17233"><td class="memItemLeft" align="right" valign="top"><a id="a811689f90c9f0c616e759708fbf17233"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>connection</b> (redisAsyncContext *actx)</td></tr>
<tr class="separator:a811689f90c9f0c616e759708fbf17233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb21388b1c6ca502d979872956783c2"><td class="memTemplParams" colspan="2">template&lt;typename CORO_RET  = std::string&gt; </td></tr>
<tr class="memitem:abfb21388b1c6ca502d979872956783c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; CORO_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#abfb21388b1c6ca502d979872956783c2">command</a> (std::string_view cmd) const</td></tr>
<tr class="memdesc:abfb21388b1c6ca502d979872956783c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send redis command.  <a href="classcoro__redis_1_1connection.html#abfb21388b1c6ca502d979872956783c2">More...</a><br /></td></tr>
<tr class="separator:abfb21388b1c6ca502d979872956783c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a033547c7cf74ece1e63d934baefa0d"><td class="memTemplParams" colspan="2">template&lt;typename CORO_RET &gt; </td></tr>
<tr class="memitem:a7a033547c7cf74ece1e63d934baefa0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; CORO_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a7a033547c7cf74ece1e63d934baefa0d">command</a> (std::string_view cmd, std::function&lt; std::optional&lt; CORO_RET &gt;(redisReply *)&gt; &amp;&amp;reply_op) const</td></tr>
<tr class="memdesc:a7a033547c7cf74ece1e63d934baefa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send redis command.  <a href="classcoro__redis_1_1connection.html#a7a033547c7cf74ece1e63d934baefa0d">More...</a><br /></td></tr>
<tr class="separator:a7a033547c7cf74ece1e63d934baefa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053c896b24742f8ee1483b9d15a72a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a053c896b24742f8ee1483b9d15a72a6f">auth</a> (std::string_view password)</td></tr>
<tr class="memdesc:a053c896b24742f8ee1483b9d15a72a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send password to Redis.  <a href="classcoro__redis_1_1connection.html#a053c896b24742f8ee1483b9d15a72a6f">More...</a><br /></td></tr>
<tr class="separator:a053c896b24742f8ee1483b9d15a72a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29d06015e269af8de7e53ebfc70a578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af29d06015e269af8de7e53ebfc70a578">auth</a> (std::string_view user, std::string_view password)</td></tr>
<tr class="memdesc:af29d06015e269af8de7e53ebfc70a578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send user and password to Redis.  <a href="classcoro__redis_1_1connection.html#af29d06015e269af8de7e53ebfc70a578">More...</a><br /></td></tr>
<tr class="separator:af29d06015e269af8de7e53ebfc70a578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deef3ca4950d717dc2d6acf361546b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a2deef3ca4950d717dc2d6acf361546b3">echo</a> (std::string_view msg) const</td></tr>
<tr class="memdesc:a2deef3ca4950d717dc2d6acf361546b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask Redis to return the given message.  <a href="classcoro__redis_1_1connection.html#a2deef3ca4950d717dc2d6acf361546b3">More...</a><br /></td></tr>
<tr class="separator:a2deef3ca4950d717dc2d6acf361546b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0e0968429299819868c697aeda5594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aff0e0968429299819868c697aeda5594">ping</a> ()</td></tr>
<tr class="memdesc:aff0e0968429299819868c697aeda5594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connection is alive.  <a href="classcoro__redis_1_1connection.html#aff0e0968429299819868c697aeda5594">More...</a><br /></td></tr>
<tr class="separator:aff0e0968429299819868c697aeda5594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d30d986d47d3cc8e0dcac31b40b6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a07d30d986d47d3cc8e0dcac31b40b6d6">ping</a> (std::string_view msg)</td></tr>
<tr class="memdesc:a07d30d986d47d3cc8e0dcac31b40b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connection is alive.  <a href="classcoro__redis_1_1connection.html#a07d30d986d47d3cc8e0dcac31b40b6d6">More...</a><br /></td></tr>
<tr class="separator:a07d30d986d47d3cc8e0dcac31b40b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28bff6aba15c977d5be2849da557ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad28bff6aba15c977d5be2849da557ee1">quit</a> ()</td></tr>
<tr class="memdesc:ad28bff6aba15c977d5be2849da557ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">After sending QUIT, only the current connection will be close, while other connections in the pool is still open.  <a href="classcoro__redis_1_1connection.html#ad28bff6aba15c977d5be2849da557ee1">More...</a><br /></td></tr>
<tr class="separator:ad28bff6aba15c977d5be2849da557ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15761493b97c165ebed7b21eb2e14d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a15761493b97c165ebed7b21eb2e14d6f">select</a> (uint64_t idx)</td></tr>
<tr class="memdesc:a15761493b97c165ebed7b21eb2e14d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the Redis logical database.  <a href="classcoro__redis_1_1connection.html#a15761493b97c165ebed7b21eb2e14d6f">More...</a><br /></td></tr>
<tr class="separator:a15761493b97c165ebed7b21eb2e14d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3d14434c22a64c54d1f37d04ff6251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6a3d14434c22a64c54d1f37d04ff6251">swapdb</a> (uint64_t idx1, uint64_t idx2)</td></tr>
<tr class="memdesc:a6a3d14434c22a64c54d1f37d04ff6251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two Redis databases.  <a href="classcoro__redis_1_1connection.html#a6a3d14434c22a64c54d1f37d04ff6251">More...</a><br /></td></tr>
<tr class="separator:a6a3d14434c22a64c54d1f37d04ff6251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f223085ec27116d2a2a7c80675095b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a8f223085ec27116d2a2a7c80675095b2">bgrewriteaof</a> ()</td></tr>
<tr class="memdesc:a8f223085ec27116d2a2a7c80675095b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite AOF in the background.  <a href="classcoro__redis_1_1connection.html#a8f223085ec27116d2a2a7c80675095b2">More...</a><br /></td></tr>
<tr class="separator:a8f223085ec27116d2a2a7c80675095b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2236759698088791904610853f9713bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a2236759698088791904610853f9713bd">bgsave</a> ()</td></tr>
<tr class="memdesc:a2236759698088791904610853f9713bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save database in the background.  <a href="classcoro__redis_1_1connection.html#a2236759698088791904610853f9713bd">More...</a><br /></td></tr>
<tr class="separator:a2236759698088791904610853f9713bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f58c12cb4e3dcb9bcebcb05c1f77ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a19f58c12cb4e3dcb9bcebcb05c1f77ad">dbsize</a> ()</td></tr>
<tr class="memdesc:a19f58c12cb4e3dcb9bcebcb05c1f77ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the currently selected database.  <a href="classcoro__redis_1_1connection.html#a19f58c12cb4e3dcb9bcebcb05c1f77ad">More...</a><br /></td></tr>
<tr class="separator:a19f58c12cb4e3dcb9bcebcb05c1f77ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7e47e54ecaebc61ae010eddea7a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a19d7e47e54ecaebc61ae010eddea7a09">flushall</a> (bool async=false)</td></tr>
<tr class="memdesc:a19d7e47e54ecaebc61ae010eddea7a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys of all databases.  <a href="classcoro__redis_1_1connection.html#a19d7e47e54ecaebc61ae010eddea7a09">More...</a><br /></td></tr>
<tr class="separator:a19d7e47e54ecaebc61ae010eddea7a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bad74156f9b5d8ccd69e0076da39c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a67bad74156f9b5d8ccd69e0076da39c4">flushdb</a> (bool async=false)</td></tr>
<tr class="memdesc:a67bad74156f9b5d8ccd69e0076da39c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys of current databases.  <a href="classcoro__redis_1_1connection.html#a67bad74156f9b5d8ccd69e0076da39c4">More...</a><br /></td></tr>
<tr class="separator:a67bad74156f9b5d8ccd69e0076da39c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87fb38dab79b8a578ea14de07032eb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ab87fb38dab79b8a578ea14de07032eb2">info</a> ()</td></tr>
<tr class="memdesc:ab87fb38dab79b8a578ea14de07032eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the info about the server.  <a href="classcoro__redis_1_1connection.html#ab87fb38dab79b8a578ea14de07032eb2">More...</a><br /></td></tr>
<tr class="separator:ab87fb38dab79b8a578ea14de07032eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90955401e15feb441e38efcaa67c8213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a90955401e15feb441e38efcaa67c8213">info</a> (std::string_view section)</td></tr>
<tr class="memdesc:a90955401e15feb441e38efcaa67c8213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the info about the server on the given section.  <a href="classcoro__redis_1_1connection.html#a90955401e15feb441e38efcaa67c8213">More...</a><br /></td></tr>
<tr class="separator:a90955401e15feb441e38efcaa67c8213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ce7cfdfd8a474da62ac84ed68912a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af46ce7cfdfd8a474da62ac84ed68912a">lastsave</a> ()</td></tr>
<tr class="memdesc:af46ce7cfdfd8a474da62ac84ed68912a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UNIX timestamp in seconds, at which the database was saved successfully.  <a href="classcoro__redis_1_1connection.html#af46ce7cfdfd8a474da62ac84ed68912a">More...</a><br /></td></tr>
<tr class="separator:af46ce7cfdfd8a474da62ac84ed68912a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1a92f05f3301c7be450f0a1ddd4268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#afc1a92f05f3301c7be450f0a1ddd4268">save</a> ()</td></tr>
<tr class="memdesc:afc1a92f05f3301c7be450f0a1ddd4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save databases into RDB file <b>synchronously</b>, i.e. block the server during saving.  <a href="classcoro__redis_1_1connection.html#afc1a92f05f3301c7be450f0a1ddd4268">More...</a><br /></td></tr>
<tr class="separator:afc1a92f05f3301c7be450f0a1ddd4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f31e338b00c1fe8d6fb2a570fbec09"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a55f31e338b00c1fe8d6fb2a570fbec09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a55f31e338b00c1fe8d6fb2a570fbec09">del</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a55f31e338b00c1fe8d6fb2a570fbec09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given key.  <a href="classcoro__redis_1_1connection.html#a55f31e338b00c1fe8d6fb2a570fbec09">More...</a><br /></td></tr>
<tr class="separator:a55f31e338b00c1fe8d6fb2a570fbec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cfc92e0f436191a331c3aeafc993fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ab8cfc92e0f436191a331c3aeafc993fd">dump</a> (std::string_view key)</td></tr>
<tr class="memdesc:ab8cfc92e0f436191a331c3aeafc993fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serialized valued stored at key.  <a href="classcoro__redis_1_1connection.html#ab8cfc92e0f436191a331c3aeafc993fd">More...</a><br /></td></tr>
<tr class="separator:ab8cfc92e0f436191a331c3aeafc993fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017f0ff851950f200e44549ab1b3b2db"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a017f0ff851950f200e44549ab1b3b2db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a017f0ff851950f200e44549ab1b3b2db">exists</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a017f0ff851950f200e44549ab1b3b2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given key exists.  <a href="classcoro__redis_1_1connection.html#a017f0ff851950f200e44549ab1b3b2db">More...</a><br /></td></tr>
<tr class="separator:a017f0ff851950f200e44549ab1b3b2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cf2083d12feedc62259ce14dfcbde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ac5cf2083d12feedc62259ce14dfcbde6">expire</a> (std::string_view key, uint64_t timeout)</td></tr>
<tr class="memdesc:ac5cf2083d12feedc62259ce14dfcbde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key.  <a href="classcoro__redis_1_1connection.html#ac5cf2083d12feedc62259ce14dfcbde6">More...</a><br /></td></tr>
<tr class="separator:ac5cf2083d12feedc62259ce14dfcbde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab176839e4e17f0bc23b08d7d67f491af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ab176839e4e17f0bc23b08d7d67f491af">expireat</a> (std::string_view key, uint64_t timestamp)</td></tr>
<tr class="memdesc:ab176839e4e17f0bc23b08d7d67f491af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key, i.e. expire the key at a future time point.  <a href="classcoro__redis_1_1connection.html#ab176839e4e17f0bc23b08d7d67f491af">More...</a><br /></td></tr>
<tr class="separator:ab176839e4e17f0bc23b08d7d67f491af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a7e8b8a16aed7f33aa54b0902ef02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a689a7e8b8a16aed7f33aa54b0902ef02">move</a> (std::string_view key, uint64_t db)</td></tr>
<tr class="memdesc:a689a7e8b8a16aed7f33aa54b0902ef02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get keys matching the given pattern.  <a href="classcoro__redis_1_1connection.html#a689a7e8b8a16aed7f33aa54b0902ef02">More...</a><br /></td></tr>
<tr class="separator:a689a7e8b8a16aed7f33aa54b0902ef02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8baeb4ead129d5a4bd89e26d359162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6d8baeb4ead129d5a4bd89e26d359162">persist</a> (std::string_view key)</td></tr>
<tr class="memdesc:a6d8baeb4ead129d5a4bd89e26d359162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove timeout on key.  <a href="classcoro__redis_1_1connection.html#a6d8baeb4ead129d5a4bd89e26d359162">More...</a><br /></td></tr>
<tr class="separator:a6d8baeb4ead129d5a4bd89e26d359162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cf63d84981af3a540b374dcd59230e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a76cf63d84981af3a540b374dcd59230e">pexpire</a> (std::string_view key, uint64_t timeout)</td></tr>
<tr class="memdesc:a76cf63d84981af3a540b374dcd59230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key.  <a href="classcoro__redis_1_1connection.html#a76cf63d84981af3a540b374dcd59230e">More...</a><br /></td></tr>
<tr class="separator:a76cf63d84981af3a540b374dcd59230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a9990e6ee18a8cf6f89c5e94e1f7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a495a9990e6ee18a8cf6f89c5e94e1f7b">pexpireat</a> (std::string_view key, uint64_t timestamp)</td></tr>
<tr class="memdesc:a495a9990e6ee18a8cf6f89c5e94e1f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key, i.e. expire the key at a future time point.  <a href="classcoro__redis_1_1connection.html#a495a9990e6ee18a8cf6f89c5e94e1f7b">More...</a><br /></td></tr>
<tr class="separator:a495a9990e6ee18a8cf6f89c5e94e1f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab126c366419ceeb14a35a8a87531567d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ab126c366419ceeb14a35a8a87531567d">pttl</a> (std::string_view key)</td></tr>
<tr class="memdesc:ab126c366419ceeb14a35a8a87531567d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TTL of a key in milliseconds.  <a href="classcoro__redis_1_1connection.html#ab126c366419ceeb14a35a8a87531567d">More...</a><br /></td></tr>
<tr class="separator:ab126c366419ceeb14a35a8a87531567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eed34f2ad3c28eb3c226763209f639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af7eed34f2ad3c28eb3c226763209f639">randomkey</a> ()</td></tr>
<tr class="memdesc:af7eed34f2ad3c28eb3c226763209f639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random key from current database.  <a href="classcoro__redis_1_1connection.html#af7eed34f2ad3c28eb3c226763209f639">More...</a><br /></td></tr>
<tr class="separator:af7eed34f2ad3c28eb3c226763209f639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8ae31f1e54e89f85239336c0b85e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#abc8ae31f1e54e89f85239336c0b85e88">rename</a> (std::string_view key, std::string_view newkey)</td></tr>
<tr class="memdesc:abc8ae31f1e54e89f85239336c0b85e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>key</code> to <code>newkey</code>.  <a href="classcoro__redis_1_1connection.html#abc8ae31f1e54e89f85239336c0b85e88">More...</a><br /></td></tr>
<tr class="separator:abc8ae31f1e54e89f85239336c0b85e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a7684da219cc3d5913aa2015bb87bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae6a7684da219cc3d5913aa2015bb87bd">renamenx</a> (std::string_view key, std::string_view newkey)</td></tr>
<tr class="memdesc:ae6a7684da219cc3d5913aa2015bb87bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>key</code> to <code>newkey</code> if <code>newkey</code> does not exist.  <a href="classcoro__redis_1_1connection.html#ae6a7684da219cc3d5913aa2015bb87bd">More...</a><br /></td></tr>
<tr class="separator:ae6a7684da219cc3d5913aa2015bb87bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea381fbdfe3a78ec968949d9ad17f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6ea381fbdfe3a78ec968949d9ad17f40">restore</a> (std::string_view key, std::string_view val, uint64_t <a class="el" href="classcoro__redis_1_1connection.html#a775641846f891eb9ffbc0ca3d3f0f701">ttl</a>, bool replace=false)</td></tr>
<tr class="memdesc:a6ea381fbdfe3a78ec968949d9ad17f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key with the value obtained by <code>Redis::dump</code>.  <a href="classcoro__redis_1_1connection.html#a6ea381fbdfe3a78ec968949d9ad17f40">More...</a><br /></td></tr>
<tr class="separator:a6ea381fbdfe3a78ec968949d9ad17f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58253ae2160e30500d428c04204820e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a58253ae2160e30500d428c04204820e6">scan</a> (uint64_t cursor, uint64_t count=0)</td></tr>
<tr class="memdesc:a58253ae2160e30500d428c04204820e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan keys of the database matching the given pattern.  <a href="classcoro__redis_1_1connection.html#a58253ae2160e30500d428c04204820e6">More...</a><br /></td></tr>
<tr class="separator:a58253ae2160e30500d428c04204820e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccabe93c829e4472c22e61f80da9582"><td class="memItemLeft" align="right" valign="top"><a id="acccabe93c829e4472c22e61f80da9582"></a>
<a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scan</b> (uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="separator:acccabe93c829e4472c22e61f80da9582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88fd4dddeafbc96ae811c464e1bcfd6"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ad88fd4dddeafbc96ae811c464e1bcfd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad88fd4dddeafbc96ae811c464e1bcfd6">touch</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:ad88fd4dddeafbc96ae811c464e1bcfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the last access time of the given key.  <a href="classcoro__redis_1_1connection.html#ad88fd4dddeafbc96ae811c464e1bcfd6">More...</a><br /></td></tr>
<tr class="separator:ad88fd4dddeafbc96ae811c464e1bcfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775641846f891eb9ffbc0ca3d3f0f701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a775641846f891eb9ffbc0ca3d3f0f701">ttl</a> (std::string_view key)</td></tr>
<tr class="memdesc:a775641846f891eb9ffbc0ca3d3f0f701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining Time-To-Live of a key.  <a href="classcoro__redis_1_1connection.html#a775641846f891eb9ffbc0ca3d3f0f701">More...</a><br /></td></tr>
<tr class="separator:a775641846f891eb9ffbc0ca3d3f0f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca0c8460495509dceef6c126aad74c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aeca0c8460495509dceef6c126aad74c0">type</a> (std::string_view key)</td></tr>
<tr class="memdesc:aeca0c8460495509dceef6c126aad74c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the value stored at key.  <a href="classcoro__redis_1_1connection.html#aeca0c8460495509dceef6c126aad74c0">More...</a><br /></td></tr>
<tr class="separator:aeca0c8460495509dceef6c126aad74c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee365e2efe187b5dd5cdca56522dfc3d"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aee365e2efe187b5dd5cdca56522dfc3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aee365e2efe187b5dd5cdca56522dfc3d">unlink</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aee365e2efe187b5dd5cdca56522dfc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given key asynchronously, i.e. without blocking Redis.  <a href="classcoro__redis_1_1connection.html#aee365e2efe187b5dd5cdca56522dfc3d">More...</a><br /></td></tr>
<tr class="separator:aee365e2efe187b5dd5cdca56522dfc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfa75998e62391acecfd9cfd9146d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#accfa75998e62391acecfd9cfd9146d72">wait</a> (uint64_t numslaves, uint64_t timeout)</td></tr>
<tr class="memdesc:accfa75998e62391acecfd9cfd9146d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until previous write commands are successfully replicated to at least the specified number of replicas or the given timeout has been reached.  <a href="classcoro__redis_1_1connection.html#accfa75998e62391acecfd9cfd9146d72">More...</a><br /></td></tr>
<tr class="separator:accfa75998e62391acecfd9cfd9146d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4232d3ffc9ec471f25384ebbbfce0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad4232d3ffc9ec471f25384ebbbfce0ec">append</a> (std::string_view key, std::string_view str)</td></tr>
<tr class="memdesc:ad4232d3ffc9ec471f25384ebbbfce0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the given string to the string stored at key.  <a href="classcoro__redis_1_1connection.html#ad4232d3ffc9ec471f25384ebbbfce0ec">More...</a><br /></td></tr>
<tr class="separator:ad4232d3ffc9ec471f25384ebbbfce0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0563b62bb80f5041bc62fbc7e37a01f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a0563b62bb80f5041bc62fbc7e37a01f3">bitcount</a> (std::string_view key, uint64_t start=0, uint64_t end=-1)</td></tr>
<tr class="memdesc:a0563b62bb80f5041bc62fbc7e37a01f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits that have been set for the given range of the string.  <a href="classcoro__redis_1_1connection.html#a0563b62bb80f5041bc62fbc7e37a01f3">More...</a><br /></td></tr>
<tr class="separator:a0563b62bb80f5041bc62fbc7e37a01f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0063ff6a10d63fdd8cea80f628f8beb6"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a0063ff6a10d63fdd8cea80f628f8beb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a0063ff6a10d63fdd8cea80f628f8beb6">bitop</a> (BitOp op, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a0063ff6a10d63fdd8cea80f628f8beb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do bit operation on the string stored at <code>key</code>, and save the result to <code>destination</code>.  <a href="classcoro__redis_1_1connection.html#a0063ff6a10d63fdd8cea80f628f8beb6">More...</a><br /></td></tr>
<tr class="separator:a0063ff6a10d63fdd8cea80f628f8beb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf9032a56c8a40e50b9fc2a743c1df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6cf9032a56c8a40e50b9fc2a743c1df2">bitpos</a> (std::string_view key, uint64_t bit, uint64_t start=0, uint64_t end=-1)</td></tr>
<tr class="memdesc:a6cf9032a56c8a40e50b9fc2a743c1df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the first bit set to 0 or 1 in the given range of the string.  <a href="classcoro__redis_1_1connection.html#a6cf9032a56c8a40e50b9fc2a743c1df2">More...</a><br /></td></tr>
<tr class="separator:a6cf9032a56c8a40e50b9fc2a743c1df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a63deb0639ec62c2c7733c0d1ef8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a51a63deb0639ec62c2c7733c0d1ef8d6">decr</a> (std::string_view key)</td></tr>
<tr class="memdesc:a51a63deb0639ec62c2c7733c0d1ef8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the integer stored at key by 1.  <a href="classcoro__redis_1_1connection.html#a51a63deb0639ec62c2c7733c0d1ef8d6">More...</a><br /></td></tr>
<tr class="separator:a51a63deb0639ec62c2c7733c0d1ef8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed723efe41b4056ea548fb9992ac3d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aed723efe41b4056ea548fb9992ac3d19">decrby</a> (std::string_view key, uint64_t decrement)</td></tr>
<tr class="memdesc:aed723efe41b4056ea548fb9992ac3d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the integer stored at key by <code>decrement</code>.  <a href="classcoro__redis_1_1connection.html#aed723efe41b4056ea548fb9992ac3d19">More...</a><br /></td></tr>
<tr class="separator:aed723efe41b4056ea548fb9992ac3d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68fe844500fcd9467439ac93bd7df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ada68fe844500fcd9467439ac93bd7df0">get</a> (std::string_view key) const</td></tr>
<tr class="memdesc:ada68fe844500fcd9467439ac93bd7df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string value stored at key.  <a href="classcoro__redis_1_1connection.html#ada68fe844500fcd9467439ac93bd7df0">More...</a><br /></td></tr>
<tr class="separator:ada68fe844500fcd9467439ac93bd7df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ac5281ac5609578976ae5ccf4d5eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae0ac5281ac5609578976ae5ccf4d5eaa">getbit</a> (std::string_view key, uint64_t offset)</td></tr>
<tr class="memdesc:ae0ac5281ac5609578976ae5ccf4d5eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit value at offset in the string.  <a href="classcoro__redis_1_1connection.html#ae0ac5281ac5609578976ae5ccf4d5eaa">More...</a><br /></td></tr>
<tr class="separator:ae0ac5281ac5609578976ae5ccf4d5eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b84598bf82a570373e9e6a7c8982281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a3b84598bf82a570373e9e6a7c8982281">getrange</a> (std::string_view key, uint64_t start, uint64_t end)</td></tr>
<tr class="memdesc:a3b84598bf82a570373e9e6a7c8982281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring of the string stored at key.  <a href="classcoro__redis_1_1connection.html#a3b84598bf82a570373e9e6a7c8982281">More...</a><br /></td></tr>
<tr class="separator:a3b84598bf82a570373e9e6a7c8982281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc8a4077ed7473ab57c4c3fdd83acd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a1cc8a4077ed7473ab57c4c3fdd83acd5">getset</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a1cc8a4077ed7473ab57c4c3fdd83acd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically set the string stored at <code>key</code> to <code>val</code>, and return the old value.  <a href="classcoro__redis_1_1connection.html#a1cc8a4077ed7473ab57c4c3fdd83acd5">More...</a><br /></td></tr>
<tr class="separator:a1cc8a4077ed7473ab57c4c3fdd83acd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15405af586017c881ccf547e21d29029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a15405af586017c881ccf547e21d29029">incr</a> (std::string_view key)</td></tr>
<tr class="memdesc:a15405af586017c881ccf547e21d29029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at key by 1.  <a href="classcoro__redis_1_1connection.html#a15405af586017c881ccf547e21d29029">More...</a><br /></td></tr>
<tr class="separator:a15405af586017c881ccf547e21d29029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb83115c674938f8035aa81ac46fcfad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#afb83115c674938f8035aa81ac46fcfad">incrby</a> (std::string_view key, uint64_t increment)</td></tr>
<tr class="memdesc:afb83115c674938f8035aa81ac46fcfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at key by <code>increment</code>.  <a href="classcoro__redis_1_1connection.html#afb83115c674938f8035aa81ac46fcfad">More...</a><br /></td></tr>
<tr class="separator:afb83115c674938f8035aa81ac46fcfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b91c11c100530889a870e93d53a51a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6b91c11c100530889a870e93d53a51a3">incrbyfloat</a> (std::string_view key, double increment)</td></tr>
<tr class="memdesc:a6b91c11c100530889a870e93d53a51a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the floating point number stored at key by <code>increment</code>.  <a href="classcoro__redis_1_1connection.html#a6b91c11c100530889a870e93d53a51a3">More...</a><br /></td></tr>
<tr class="separator:a6b91c11c100530889a870e93d53a51a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7622a2775ff5436c6323bc3047314c"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a3b7622a2775ff5436c6323bc3047314c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a3b7622a2775ff5436c6323bc3047314c">mget</a> (Args &amp;&amp;...keys)</td></tr>
<tr class="memdesc:a3b7622a2775ff5436c6323bc3047314c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of multiple keys atomically.  <a href="classcoro__redis_1_1connection.html#a3b7622a2775ff5436c6323bc3047314c">More...</a><br /></td></tr>
<tr class="separator:a3b7622a2775ff5436c6323bc3047314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee444aebf7c2ec1af54130d69a188a0"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a4ee444aebf7c2ec1af54130d69a188a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a4ee444aebf7c2ec1af54130d69a188a0">mset</a> (Args &amp;&amp;...keys)</td></tr>
<tr class="memdesc:a4ee444aebf7c2ec1af54130d69a188a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple key-value pairs.  <a href="classcoro__redis_1_1connection.html#a4ee444aebf7c2ec1af54130d69a188a0">More...</a><br /></td></tr>
<tr class="separator:a4ee444aebf7c2ec1af54130d69a188a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f36e89c01a047e3548893922b636006"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a3f36e89c01a047e3548893922b636006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a3f36e89c01a047e3548893922b636006">msetnx</a> (Args &amp;&amp;...keys)</td></tr>
<tr class="memdesc:a3f36e89c01a047e3548893922b636006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given key-value pairs if all specified keys do not exist.  <a href="classcoro__redis_1_1connection.html#a3f36e89c01a047e3548893922b636006">More...</a><br /></td></tr>
<tr class="separator:a3f36e89c01a047e3548893922b636006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6be5f02ece4302ca958f82c75a1023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#afd6be5f02ece4302ca958f82c75a1023">psetex</a> (std::string_view key, uint64_t <a class="el" href="classcoro__redis_1_1connection.html#a775641846f891eb9ffbc0ca3d3f0f701">ttl</a>, std::string_view val)</td></tr>
<tr class="memdesc:afd6be5f02ece4302ca958f82c75a1023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key-value pair with the given timeout in milliseconds.  <a href="classcoro__redis_1_1connection.html#afd6be5f02ece4302ca958f82c75a1023">More...</a><br /></td></tr>
<tr class="separator:afd6be5f02ece4302ca958f82c75a1023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeccc5e933ff6bdba9f5036cdbde226c"><td class="memTemplParams" colspan="2">template&lt;RedisSetValueType T&gt; </td></tr>
<tr class="memitem:afeccc5e933ff6bdba9f5036cdbde226c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#afeccc5e933ff6bdba9f5036cdbde226c">set</a> (std::string_view key, T val, uint64_t <a class="el" href="classcoro__redis_1_1connection.html#a775641846f891eb9ffbc0ca3d3f0f701">ttl</a>=0, RedisTTLType ttl_type=RedisTTLType::EX, UpdateType <a class="el" href="classcoro__redis_1_1connection.html#aeca0c8460495509dceef6c126aad74c0">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:afeccc5e933ff6bdba9f5036cdbde226c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a key-value pair.  <a href="classcoro__redis_1_1connection.html#afeccc5e933ff6bdba9f5036cdbde226c">More...</a><br /></td></tr>
<tr class="separator:afeccc5e933ff6bdba9f5036cdbde226c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fea96606b8d320922b54920f9e5d78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae8fea96606b8d320922b54920f9e5d78">setex</a> (std::string_view key, uint64_t <a class="el" href="classcoro__redis_1_1connection.html#a775641846f891eb9ffbc0ca3d3f0f701">ttl</a>, std::string_view val)</td></tr>
<tr class="memdesc:ae8fea96606b8d320922b54920f9e5d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key-value pair with the given timeout in seconds.  <a href="classcoro__redis_1_1connection.html#ae8fea96606b8d320922b54920f9e5d78">More...</a><br /></td></tr>
<tr class="separator:ae8fea96606b8d320922b54920f9e5d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25969e794c54b7cf0e5b0e5ff3558de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ac25969e794c54b7cf0e5b0e5ff3558de">setnx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:ac25969e794c54b7cf0e5b0e5ff3558de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the key if it does not exist.  <a href="classcoro__redis_1_1connection.html#ac25969e794c54b7cf0e5b0e5ff3558de">More...</a><br /></td></tr>
<tr class="separator:ac25969e794c54b7cf0e5b0e5ff3558de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ffd58a1e50aba761fef42d71cf995d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae4ffd58a1e50aba761fef42d71cf995d">setrange</a> (std::string_view key, uint64_t offset, std::string_view val)</td></tr>
<tr class="memdesc:ae4ffd58a1e50aba761fef42d71cf995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the substring starting from <code>offset</code> to the given value.  <a href="classcoro__redis_1_1connection.html#ae4ffd58a1e50aba761fef42d71cf995d">More...</a><br /></td></tr>
<tr class="separator:ae4ffd58a1e50aba761fef42d71cf995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605cd2814bfaad5cb0b98bae4fe8ca6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a605cd2814bfaad5cb0b98bae4fe8ca6a">strlen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a605cd2814bfaad5cb0b98bae4fe8ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string stored at key.  <a href="classcoro__redis_1_1connection.html#a605cd2814bfaad5cb0b98bae4fe8ca6a">More...</a><br /></td></tr>
<tr class="separator:a605cd2814bfaad5cb0b98bae4fe8ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d8a316acf9f1cc828393e36f287166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a16d8a316acf9f1cc828393e36f287166">llen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a16d8a316acf9f1cc828393e36f287166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the list.  <a href="classcoro__redis_1_1connection.html#a16d8a316acf9f1cc828393e36f287166">More...</a><br /></td></tr>
<tr class="separator:a16d8a316acf9f1cc828393e36f287166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbda75130a7f03a206178464eb2b8daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#adbda75130a7f03a206178464eb2b8daa">lpop</a> (std::string_view key)</td></tr>
<tr class="memdesc:adbda75130a7f03a206178464eb2b8daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the first element of the list.  <a href="classcoro__redis_1_1connection.html#adbda75130a7f03a206178464eb2b8daa">More...</a><br /></td></tr>
<tr class="separator:adbda75130a7f03a206178464eb2b8daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45845b41c5ec7ed8276aff09d020dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae45845b41c5ec7ed8276aff09d020dde">lpush</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:ae45845b41c5ec7ed8276aff09d020dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the beginning of the list.  <a href="classcoro__redis_1_1connection.html#ae45845b41c5ec7ed8276aff09d020dde">More...</a><br /></td></tr>
<tr class="separator:ae45845b41c5ec7ed8276aff09d020dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a3ba1896904443d8cf247e412b81d1"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a11a3ba1896904443d8cf247e412b81d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a11a3ba1896904443d8cf247e412b81d1">lpush</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a11a3ba1896904443d8cf247e412b81d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push multiple elements to the beginning of the list.  <a href="classcoro__redis_1_1connection.html#a11a3ba1896904443d8cf247e412b81d1">More...</a><br /></td></tr>
<tr class="separator:a11a3ba1896904443d8cf247e412b81d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd922e0b161e25204f35f6197bd905b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#afd922e0b161e25204f35f6197bd905b9">lpushx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:afd922e0b161e25204f35f6197bd905b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the beginning of the list, only if the list already exists.  <a href="classcoro__redis_1_1connection.html#afd922e0b161e25204f35f6197bd905b9">More...</a><br /></td></tr>
<tr class="separator:afd922e0b161e25204f35f6197bd905b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad946e04bf24eb334eb5bad9cf316964c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad946e04bf24eb334eb5bad9cf316964c">lrange</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:ad946e04bf24eb334eb5bad9cf316964c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get elements in the given range of the given list.  <a href="classcoro__redis_1_1connection.html#ad946e04bf24eb334eb5bad9cf316964c">More...</a><br /></td></tr>
<tr class="separator:ad946e04bf24eb334eb5bad9cf316964c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b9b8c2b25481d2f1f415c351f0b404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a04b9b8c2b25481d2f1f415c351f0b404">lrem</a> (std::string_view key, uint64_t count, std::string_view val)</td></tr>
<tr class="memdesc:a04b9b8c2b25481d2f1f415c351f0b404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first <code>count</code> occurrences of elements equal to <code>val</code>.  <a href="classcoro__redis_1_1connection.html#a04b9b8c2b25481d2f1f415c351f0b404">More...</a><br /></td></tr>
<tr class="separator:a04b9b8c2b25481d2f1f415c351f0b404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedda41154d6ca7dede1bb333af53bb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aedda41154d6ca7dede1bb333af53bb3c">lset</a> (std::string_view key, uint64_t index, std::string_view val)</td></tr>
<tr class="memdesc:aedda41154d6ca7dede1bb333af53bb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element at the given index to the specified value.  <a href="classcoro__redis_1_1connection.html#aedda41154d6ca7dede1bb333af53bb3c">More...</a><br /></td></tr>
<tr class="separator:aedda41154d6ca7dede1bb333af53bb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3331476c43dc86870ad1c02e3806002c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a3331476c43dc86870ad1c02e3806002c">ltrim</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:a3331476c43dc86870ad1c02e3806002c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a list to keep only element in the given range.  <a href="classcoro__redis_1_1connection.html#a3331476c43dc86870ad1c02e3806002c">More...</a><br /></td></tr>
<tr class="separator:a3331476c43dc86870ad1c02e3806002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26202808f72e0cee34370feb5176a990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a26202808f72e0cee34370feb5176a990">rpop</a> (std::string_view key)</td></tr>
<tr class="memdesc:a26202808f72e0cee34370feb5176a990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the last element of a list.  <a href="classcoro__redis_1_1connection.html#a26202808f72e0cee34370feb5176a990">More...</a><br /></td></tr>
<tr class="separator:a26202808f72e0cee34370feb5176a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5814e56532472cc308924b05601bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a43f5814e56532472cc308924b05601bb">rpoplpush</a> (std::string_view source, std::string_view destination)</td></tr>
<tr class="memdesc:a43f5814e56532472cc308924b05601bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop last element of one list and push it to the left of another list.  <a href="classcoro__redis_1_1connection.html#a43f5814e56532472cc308924b05601bb">More...</a><br /></td></tr>
<tr class="separator:a43f5814e56532472cc308924b05601bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cd2f18878363da88b3396ed5f92140"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa4cd2f18878363da88b3396ed5f92140"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aa4cd2f18878363da88b3396ed5f92140">rpush</a> (std::string_view key, std::string_view val, Args &amp;&amp;... vals)</td></tr>
<tr class="memdesc:aa4cd2f18878363da88b3396ed5f92140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the end of the list.  <a href="classcoro__redis_1_1connection.html#aa4cd2f18878363da88b3396ed5f92140">More...</a><br /></td></tr>
<tr class="separator:aa4cd2f18878363da88b3396ed5f92140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad689b17dd12b81d8eee0c61c8af46f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad689b17dd12b81d8eee0c61c8af46f49">rpushx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:ad689b17dd12b81d8eee0c61c8af46f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the end of the list, only if the list already exists.  <a href="classcoro__redis_1_1connection.html#ad689b17dd12b81d8eee0c61c8af46f49">More...</a><br /></td></tr>
<tr class="separator:ad689b17dd12b81d8eee0c61c8af46f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae830197544cc6dcad0e4aa4100b69ba5"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ae830197544cc6dcad0e4aa4100b69ba5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae830197544cc6dcad0e4aa4100b69ba5">hdel</a> (std::string_view key, std::string_view field, Args &amp;&amp;... fields)</td></tr>
<tr class="memdesc:ae830197544cc6dcad0e4aa4100b69ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given field from hash.  <a href="classcoro__redis_1_1connection.html#ae830197544cc6dcad0e4aa4100b69ba5">More...</a><br /></td></tr>
<tr class="separator:ae830197544cc6dcad0e4aa4100b69ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18481bc17156e36b8525e3905820aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af18481bc17156e36b8525e3905820aff">hexists</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:af18481bc17156e36b8525e3905820aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given field exists in hash.  <a href="classcoro__redis_1_1connection.html#af18481bc17156e36b8525e3905820aff">More...</a><br /></td></tr>
<tr class="separator:af18481bc17156e36b8525e3905820aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97559a977aa31fc34c5a2673fc10959e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a97559a977aa31fc34c5a2673fc10959e">hget</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:a97559a977aa31fc34c5a2673fc10959e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the given field.  <a href="classcoro__redis_1_1connection.html#a97559a977aa31fc34c5a2673fc10959e">More...</a><br /></td></tr>
<tr class="separator:a97559a977aa31fc34c5a2673fc10959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a31f108f12cfad311764fd087d0cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a78a31f108f12cfad311764fd087d0cb9">hgetall</a> (std::string_view key)</td></tr>
<tr class="memdesc:a78a31f108f12cfad311764fd087d0cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all field-value pairs of the given hash.  <a href="classcoro__redis_1_1connection.html#a78a31f108f12cfad311764fd087d0cb9">More...</a><br /></td></tr>
<tr class="separator:a78a31f108f12cfad311764fd087d0cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae229c1c7b9c775534d1b4f842ffb52c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae229c1c7b9c775534d1b4f842ffb52c1">hincrby</a> (std::string_view key, std::string_view field, uint64_t increment)</td></tr>
<tr class="memdesc:ae229c1c7b9c775534d1b4f842ffb52c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at the given field.  <a href="classcoro__redis_1_1connection.html#ae229c1c7b9c775534d1b4f842ffb52c1">More...</a><br /></td></tr>
<tr class="separator:ae229c1c7b9c775534d1b4f842ffb52c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5c7016421f54076209ed2c206199d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a2a5c7016421f54076209ed2c206199d5">hincrbyfloat</a> (std::string_view key, std::string_view field, double increment)</td></tr>
<tr class="memdesc:a2a5c7016421f54076209ed2c206199d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the floating point number stored at the given field.  <a href="classcoro__redis_1_1connection.html#a2a5c7016421f54076209ed2c206199d5">More...</a><br /></td></tr>
<tr class="separator:a2a5c7016421f54076209ed2c206199d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5d8669f66783b6e4e8eddbc40fb351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a7a5d8669f66783b6e4e8eddbc40fb351">hkeys</a> (std::string_view key)</td></tr>
<tr class="memdesc:a7a5d8669f66783b6e4e8eddbc40fb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all fields of the given hash.  <a href="classcoro__redis_1_1connection.html#a7a5d8669f66783b6e4e8eddbc40fb351">More...</a><br /></td></tr>
<tr class="separator:a7a5d8669f66783b6e4e8eddbc40fb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e4856f0acd73da41dd6f58156b7f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a29e4856f0acd73da41dd6f58156b7f10">hlen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a29e4856f0acd73da41dd6f58156b7f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of fields of the given hash.  <a href="classcoro__redis_1_1connection.html#a29e4856f0acd73da41dd6f58156b7f10">More...</a><br /></td></tr>
<tr class="separator:a29e4856f0acd73da41dd6f58156b7f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab063ec5901c6c537bccbd456d25768e9"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ab063ec5901c6c537bccbd456d25768e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ab063ec5901c6c537bccbd456d25768e9">hmget</a> (std::string_view key, std::string_view field, Args &amp;&amp;...fields)</td></tr>
<tr class="memdesc:ab063ec5901c6c537bccbd456d25768e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of multiple fields.  <a href="classcoro__redis_1_1connection.html#ab063ec5901c6c537bccbd456d25768e9">More...</a><br /></td></tr>
<tr class="separator:ab063ec5901c6c537bccbd456d25768e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51586457832247fdd78c066856e179ae"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a51586457832247fdd78c066856e179ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a51586457832247fdd78c066856e179ae">hmset</a> (std::string_view key, std::string_view field, std::string_view value, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a51586457832247fdd78c066856e179ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple field-value pairs of the given hash.  <a href="classcoro__redis_1_1connection.html#a51586457832247fdd78c066856e179ae">More...</a><br /></td></tr>
<tr class="separator:a51586457832247fdd78c066856e179ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b246e5c607e9f99bb0f9ca9ed6c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a693b246e5c607e9f99bb0f9ca9ed6c5d">hscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:a693b246e5c607e9f99bb0f9ca9ed6c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan fields of the given hash matching the given pattern.  <a href="classcoro__redis_1_1connection.html#a693b246e5c607e9f99bb0f9ca9ed6c5d">More...</a><br /></td></tr>
<tr class="separator:a693b246e5c607e9f99bb0f9ca9ed6c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473d5b17dc67976f93fb03990a78f524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a473d5b17dc67976f93fb03990a78f524">hscan</a> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="memdesc:a473d5b17dc67976f93fb03990a78f524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan fields of the given hash matching the given pattern.  <a href="classcoro__redis_1_1connection.html#a473d5b17dc67976f93fb03990a78f524">More...</a><br /></td></tr>
<tr class="separator:a473d5b17dc67976f93fb03990a78f524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0524910dff990fdb4a4067416b4f61e5"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a0524910dff990fdb4a4067416b4f61e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a0524910dff990fdb4a4067416b4f61e5">hset</a> (std::string_view key, std::string_view field, std::string_view val, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0524910dff990fdb4a4067416b4f61e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hash field to value.  <a href="classcoro__redis_1_1connection.html#a0524910dff990fdb4a4067416b4f61e5">More...</a><br /></td></tr>
<tr class="separator:a0524910dff990fdb4a4067416b4f61e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bad38b194fcf0a48924320db16442dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a0bad38b194fcf0a48924320db16442dd">hset</a> (std::string_view key, const std::vector&lt; std::pair&lt; std::string_view, std::string_view &gt;&gt; &amp;kvs)</td></tr>
<tr class="memdesc:a0bad38b194fcf0a48924320db16442dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple fields of the given hash.  <a href="classcoro__redis_1_1connection.html#a0bad38b194fcf0a48924320db16442dd">More...</a><br /></td></tr>
<tr class="separator:a0bad38b194fcf0a48924320db16442dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825cdab0a44b4fa90e97b616fe1db17b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a825cdab0a44b4fa90e97b616fe1db17b">hsetnx</a> (std::string_view key, std::string_view field, std::string_view val)</td></tr>
<tr class="memdesc:a825cdab0a44b4fa90e97b616fe1db17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hash field to value, only if the given field does not exist.  <a href="classcoro__redis_1_1connection.html#a825cdab0a44b4fa90e97b616fe1db17b">More...</a><br /></td></tr>
<tr class="separator:a825cdab0a44b4fa90e97b616fe1db17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16f4dff1a5e5adc5b75e817088a6cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae16f4dff1a5e5adc5b75e817088a6cac">hstrlen</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:ae16f4dff1a5e5adc5b75e817088a6cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string stored at the given field.  <a href="classcoro__redis_1_1connection.html#ae16f4dff1a5e5adc5b75e817088a6cac">More...</a><br /></td></tr>
<tr class="separator:ae16f4dff1a5e5adc5b75e817088a6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd739a75900b08cdeba96d5e7e36853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#abfd739a75900b08cdeba96d5e7e36853">hvals</a> (std::string_view key)</td></tr>
<tr class="memdesc:abfd739a75900b08cdeba96d5e7e36853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of all fields stored at the given hash.  <a href="classcoro__redis_1_1connection.html#abfd739a75900b08cdeba96d5e7e36853">More...</a><br /></td></tr>
<tr class="separator:abfd739a75900b08cdeba96d5e7e36853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae78f8359e8c4403bae06eb37134a11"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:afae78f8359e8c4403bae06eb37134a11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#afae78f8359e8c4403bae06eb37134a11">sadd</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:afae78f8359e8c4403bae06eb37134a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a member to the given set.  <a href="classcoro__redis_1_1connection.html#afae78f8359e8c4403bae06eb37134a11">More...</a><br /></td></tr>
<tr class="separator:afae78f8359e8c4403bae06eb37134a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab804b3a76f04ae92b5bba30176a5b276"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ab804b3a76f04ae92b5bba30176a5b276">scard</a> (std::string_view key)</td></tr>
<tr class="memdesc:ab804b3a76f04ae92b5bba30176a5b276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members in the set.  <a href="classcoro__redis_1_1connection.html#ab804b3a76f04ae92b5bba30176a5b276">More...</a><br /></td></tr>
<tr class="separator:ab804b3a76f04ae92b5bba30176a5b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34007b3c150974f6226ad9ddbcf6ec0"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ae34007b3c150974f6226ad9ddbcf6ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae34007b3c150974f6226ad9ddbcf6ec0">sdiff</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:ae34007b3c150974f6226ad9ddbcf6ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the difference between the first set and all successive sets.  <a href="classcoro__redis_1_1connection.html#ae34007b3c150974f6226ad9ddbcf6ec0">More...</a><br /></td></tr>
<tr class="separator:ae34007b3c150974f6226ad9ddbcf6ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d1bdd4e520003743575f195e9126f9"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a89d1bdd4e520003743575f195e9126f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a89d1bdd4e520003743575f195e9126f9">sdiffstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a89d1bdd4e520003743575f195e9126f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1connection.html#a89d1bdd4e520003743575f195e9126f9">More...</a><br /></td></tr>
<tr class="separator:a89d1bdd4e520003743575f195e9126f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837b80595a7095ebe3191aeeaec855bd"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a837b80595a7095ebe3191aeeaec855bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a837b80595a7095ebe3191aeeaec855bd">sinter</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a837b80595a7095ebe3191aeeaec855bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection between the first set and all successive sets.  <a href="classcoro__redis_1_1connection.html#a837b80595a7095ebe3191aeeaec855bd">More...</a><br /></td></tr>
<tr class="separator:a837b80595a7095ebe3191aeeaec855bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53d39bb5ac7e8eaf7ad290582598781"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa53d39bb5ac7e8eaf7ad290582598781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aa53d39bb5ac7e8eaf7ad290582598781">sinterstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aa53d39bb5ac7e8eaf7ad290582598781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1connection.html#aa53d39bb5ac7e8eaf7ad290582598781">More...</a><br /></td></tr>
<tr class="separator:aa53d39bb5ac7e8eaf7ad290582598781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb6f83c50a755f08df35914759d494e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a8bb6f83c50a755f08df35914759d494e">sismember</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a8bb6f83c50a755f08df35914759d494e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <code>member</code> exists in the set stored at key.  <a href="classcoro__redis_1_1connection.html#a8bb6f83c50a755f08df35914759d494e">More...</a><br /></td></tr>
<tr class="separator:a8bb6f83c50a755f08df35914759d494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96af15e7271ad5cc56a9c7903b05f69f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a96af15e7271ad5cc56a9c7903b05f69f">smembers</a> (std::string_view key)</td></tr>
<tr class="memdesc:a96af15e7271ad5cc56a9c7903b05f69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all members in the given set.  <a href="classcoro__redis_1_1connection.html#a96af15e7271ad5cc56a9c7903b05f69f">More...</a><br /></td></tr>
<tr class="separator:a96af15e7271ad5cc56a9c7903b05f69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48759082bd38f1dffac7a9cca46c750b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a48759082bd38f1dffac7a9cca46c750b">smove</a> (std::string_view source, std::string_view destination, std::string_view member)</td></tr>
<tr class="memdesc:a48759082bd38f1dffac7a9cca46c750b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move <code>member</code> from one set to another.  <a href="classcoro__redis_1_1connection.html#a48759082bd38f1dffac7a9cca46c750b">More...</a><br /></td></tr>
<tr class="separator:a48759082bd38f1dffac7a9cca46c750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70d6d3fb5f72aca377eb669ad071738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aa70d6d3fb5f72aca377eb669ad071738">spop</a> (std::string_view key, uint64_t count=1)</td></tr>
<tr class="memdesc:aa70d6d3fb5f72aca377eb669ad071738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a random member from the set.  <a href="classcoro__redis_1_1connection.html#aa70d6d3fb5f72aca377eb669ad071738">More...</a><br /></td></tr>
<tr class="separator:aa70d6d3fb5f72aca377eb669ad071738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47de17aaf41f253ec6fc252dd5e07105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a47de17aaf41f253ec6fc252dd5e07105">srandmember</a> (std::string_view key)</td></tr>
<tr class="memdesc:a47de17aaf41f253ec6fc252dd5e07105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random member of the given set.  <a href="classcoro__redis_1_1connection.html#a47de17aaf41f253ec6fc252dd5e07105">More...</a><br /></td></tr>
<tr class="separator:a47de17aaf41f253ec6fc252dd5e07105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94e8934c94982567b7a219dc9b4d33b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae94e8934c94982567b7a219dc9b4d33b">srandmember</a> (std::string_view key, uint64_t count)</td></tr>
<tr class="memdesc:ae94e8934c94982567b7a219dc9b4d33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple random members of the given set.  <a href="classcoro__redis_1_1connection.html#ae94e8934c94982567b7a219dc9b4d33b">More...</a><br /></td></tr>
<tr class="separator:ae94e8934c94982567b7a219dc9b4d33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabe2699341bfc587fb1854fbbbfafce"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:acabe2699341bfc587fb1854fbbbfafce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#acabe2699341bfc587fb1854fbbbfafce">srem</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:acabe2699341bfc587fb1854fbbbfafce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a member from set.  <a href="classcoro__redis_1_1connection.html#acabe2699341bfc587fb1854fbbbfafce">More...</a><br /></td></tr>
<tr class="separator:acabe2699341bfc587fb1854fbbbfafce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef19d95ae78e20e2cbd65de7eb8dce37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aef19d95ae78e20e2cbd65de7eb8dce37">sscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:aef19d95ae78e20e2cbd65de7eb8dce37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan members of the set matching the given pattern.  <a href="classcoro__redis_1_1connection.html#aef19d95ae78e20e2cbd65de7eb8dce37">More...</a><br /></td></tr>
<tr class="separator:aef19d95ae78e20e2cbd65de7eb8dce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5166a114ef0b43e61ff6b71af2aeaf31"><td class="memItemLeft" align="right" valign="top"><a id="a5166a114ef0b43e61ff6b71af2aeaf31"></a>
<a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sscan</b> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="separator:a5166a114ef0b43e61ff6b71af2aeaf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a025bf4f30404005a1d0ff44ab93760"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a6a025bf4f30404005a1d0ff44ab93760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6a025bf4f30404005a1d0ff44ab93760">sunion</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a6a025bf4f30404005a1d0ff44ab93760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the union between the first set and all successive sets.  <a href="classcoro__redis_1_1connection.html#a6a025bf4f30404005a1d0ff44ab93760">More...</a><br /></td></tr>
<tr class="separator:a6a025bf4f30404005a1d0ff44ab93760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0dac727f995ff1733702db98068c3e"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a6a0dac727f995ff1733702db98068c3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a6a0dac727f995ff1733702db98068c3e">sunionstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a6a0dac727f995ff1733702db98068c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1connection.html#a6a0dac727f995ff1733702db98068c3e">More...</a><br /></td></tr>
<tr class="separator:a6a0dac727f995ff1733702db98068c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c96a34b19735eb486b57727acf648ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a1c96a34b19735eb486b57727acf648ae">bzpopmax</a> (std::initializer_list&lt; std::string_view &gt; keys, uint64_t timeout=0)</td></tr>
<tr class="memdesc:a1c96a34b19735eb486b57727acf648ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with highest score from sorted set in a blocking way.  <a href="classcoro__redis_1_1connection.html#a1c96a34b19735eb486b57727acf648ae">More...</a><br /></td></tr>
<tr class="separator:a1c96a34b19735eb486b57727acf648ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0f93295c624c58ec90092470eb4e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a1b0f93295c624c58ec90092470eb4e8f">bzpopmin</a> (std::initializer_list&lt; std::string_view &gt; keys, uint64_t timeout=0)</td></tr>
<tr class="memdesc:a1b0f93295c624c58ec90092470eb4e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with lowest score from sorted set in a blocking way.  <a href="classcoro__redis_1_1connection.html#a1b0f93295c624c58ec90092470eb4e8f">More...</a><br /></td></tr>
<tr class="separator:a1b0f93295c624c58ec90092470eb4e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eefcd2da2b37e6e90ef6ed33d24a6f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a4eefcd2da2b37e6e90ef6ed33d24a6f2">zadd</a> (std::string_view key, std::string_view member, double score, UpdateType <a class="el" href="classcoro__redis_1_1connection.html#aeca0c8460495509dceef6c126aad74c0">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:a4eefcd2da2b37e6e90ef6ed33d24a6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update a member with score to sorted set.  <a href="classcoro__redis_1_1connection.html#a4eefcd2da2b37e6e90ef6ed33d24a6f2">More...</a><br /></td></tr>
<tr class="separator:a4eefcd2da2b37e6e90ef6ed33d24a6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb87c67b9b788709a98484c64f4873d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#abfb87c67b9b788709a98484c64f4873d">zadd</a> (std::string_view key, std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt; kvs, UpdateType <a class="el" href="classcoro__redis_1_1connection.html#aeca0c8460495509dceef6c126aad74c0">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:abfb87c67b9b788709a98484c64f4873d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update multiple members with score to sorted set.  <a href="classcoro__redis_1_1connection.html#abfb87c67b9b788709a98484c64f4873d">More...</a><br /></td></tr>
<tr class="separator:abfb87c67b9b788709a98484c64f4873d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1cce10823abed44cac9ebafeda827f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add1cce10823abed44cac9ebafeda827f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#add1cce10823abed44cac9ebafeda827f">zadd</a> (std::string_view key, std::initializer_list&lt; T &gt; il, UpdateType <a class="el" href="classcoro__redis_1_1connection.html#aeca0c8460495509dceef6c126aad74c0">type</a>=UpdateType::ALWAYS, bool changed=false)</td></tr>
<tr class="memdesc:add1cce10823abed44cac9ebafeda827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update multiple members with score to sorted set.  <a href="classcoro__redis_1_1connection.html#add1cce10823abed44cac9ebafeda827f">More...</a><br /></td></tr>
<tr class="separator:add1cce10823abed44cac9ebafeda827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565f8f5f55bd343b4d2376b310199074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a565f8f5f55bd343b4d2376b310199074">zcard</a> (std::string_view key)</td></tr>
<tr class="memdesc:a565f8f5f55bd343b4d2376b310199074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members in the sorted set.  <a href="classcoro__redis_1_1connection.html#a565f8f5f55bd343b4d2376b310199074">More...</a><br /></td></tr>
<tr class="separator:a565f8f5f55bd343b4d2376b310199074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d819629c9ac46d15ab867895c147f68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a0d819629c9ac46d15ab867895c147f68">zcount</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a0d819629c9ac46d15ab867895c147f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members with score between a min-max score range.  <a href="classcoro__redis_1_1connection.html#a0d819629c9ac46d15ab867895c147f68">More...</a><br /></td></tr>
<tr class="separator:a0d819629c9ac46d15ab867895c147f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf56d03fa902498938cb308e3d82f668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aaf56d03fa902498938cb308e3d82f668">zincrby</a> (std::string_view key, double increment, std::string_view member)</td></tr>
<tr class="memdesc:aaf56d03fa902498938cb308e3d82f668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the score of given member.  <a href="classcoro__redis_1_1connection.html#aaf56d03fa902498938cb308e3d82f668">More...</a><br /></td></tr>
<tr class="separator:aaf56d03fa902498938cb308e3d82f668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331b54a20f1d8dfb1d19dec05b09c9de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a331b54a20f1d8dfb1d19dec05b09c9de">zlexcount</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a331b54a20f1d8dfb1d19dec05b09c9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members between a min-max range in lexicographical order.  <a href="classcoro__redis_1_1connection.html#a331b54a20f1d8dfb1d19dec05b09c9de">More...</a><br /></td></tr>
<tr class="separator:a331b54a20f1d8dfb1d19dec05b09c9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95953804c9323874996df0616a1f88ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a95953804c9323874996df0616a1f88ce">zpopmax</a> (std::string_view key, uint64_t count=1)</td></tr>
<tr class="memdesc:a95953804c9323874996df0616a1f88ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with highest score from sorted set.  <a href="classcoro__redis_1_1connection.html#a95953804c9323874996df0616a1f88ce">More...</a><br /></td></tr>
<tr class="separator:a95953804c9323874996df0616a1f88ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4504cdba89e5591c3557312bdd159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a57b4504cdba89e5591c3557312bdd159">zpopmin</a> (std::string_view key)</td></tr>
<tr class="memdesc:a57b4504cdba89e5591c3557312bdd159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with lowest score from sorted set.  <a href="classcoro__redis_1_1connection.html#a57b4504cdba89e5591c3557312bdd159">More...</a><br /></td></tr>
<tr class="separator:a57b4504cdba89e5591c3557312bdd159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74fb5fb4f874ba1d51ec9b9f52e3ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae74fb5fb4f874ba1d51ec9b9f52e3ad9">zrange</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:ae74fb5fb4f874ba1d51ec9b9f52e3ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by rank (ordered from lowest to highest).  <a href="classcoro__redis_1_1connection.html#ae74fb5fb4f874ba1d51ec9b9f52e3ad9">More...</a><br /></td></tr>
<tr class="separator:ae74fb5fb4f874ba1d51ec9b9f52e3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d1927794fc9ea00fc9f6fd197fdeb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a72d1927794fc9ea00fc9f6fd197fdeb6">zrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a72d1927794fc9ea00fc9f6fd197fdeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by lexicographical order (from lowest to highest).  <a href="classcoro__redis_1_1connection.html#a72d1927794fc9ea00fc9f6fd197fdeb6">More...</a><br /></td></tr>
<tr class="separator:a72d1927794fc9ea00fc9f6fd197fdeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5956657e0bfdc750ef4657783de7895e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a5956657e0bfdc750ef4657783de7895e">zrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a5956657e0bfdc750ef4657783de7895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by score (ordered from lowest to highest).  <a href="classcoro__redis_1_1connection.html#a5956657e0bfdc750ef4657783de7895e">More...</a><br /></td></tr>
<tr class="separator:a5956657e0bfdc750ef4657783de7895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266547b0feb67affdf2908f2a95dfa7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a266547b0feb67affdf2908f2a95dfa7f">zrank</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a266547b0feb67affdf2908f2a95dfa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank (from low to high) of the given member in the sorted set.  <a href="classcoro__redis_1_1connection.html#a266547b0feb67affdf2908f2a95dfa7f">More...</a><br /></td></tr>
<tr class="separator:a266547b0feb67affdf2908f2a95dfa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4df1864978dc050f6ca84d90ba604b6"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:af4df1864978dc050f6ca84d90ba604b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af4df1864978dc050f6ca84d90ba604b6">zrem</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:af4df1864978dc050f6ca84d90ba604b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given member from sorted set.  <a href="classcoro__redis_1_1connection.html#af4df1864978dc050f6ca84d90ba604b6">More...</a><br /></td></tr>
<tr class="separator:af4df1864978dc050f6ca84d90ba604b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d798410b4149e405517c1568160003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af1d798410b4149e405517c1568160003">zremrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:af1d798410b4149e405517c1568160003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range of lexicographical order.  <a href="classcoro__redis_1_1connection.html#af1d798410b4149e405517c1568160003">More...</a><br /></td></tr>
<tr class="separator:af1d798410b4149e405517c1568160003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a8419a27d5ddfcd59b9ee29370159a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ac0a8419a27d5ddfcd59b9ee29370159a">zremrangebyrank</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:ac0a8419a27d5ddfcd59b9ee29370159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range ordered by rank.  <a href="classcoro__redis_1_1connection.html#ac0a8419a27d5ddfcd59b9ee29370159a">More...</a><br /></td></tr>
<tr class="separator:ac0a8419a27d5ddfcd59b9ee29370159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af575ac9962e2fdb38419f80047435505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#af575ac9962e2fdb38419f80047435505">zremrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:af575ac9962e2fdb38419f80047435505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range ordered by score.  <a href="classcoro__redis_1_1connection.html#af575ac9962e2fdb38419f80047435505">More...</a><br /></td></tr>
<tr class="separator:af575ac9962e2fdb38419f80047435505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e56767f8d5cfe663592cab12878b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a35e56767f8d5cfe663592cab12878b9a">zrevrange</a> (std::string_view key, uint64_t start, uint64_t stop, bool withscores=false)</td></tr>
<tr class="memdesc:a35e56767f8d5cfe663592cab12878b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by rank (ordered from highest to lowest).  <a href="classcoro__redis_1_1connection.html#a35e56767f8d5cfe663592cab12878b9a">More...</a><br /></td></tr>
<tr class="separator:a35e56767f8d5cfe663592cab12878b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06081210006be6fcd9a84a9be009623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad06081210006be6fcd9a84a9be009623">zrevrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:ad06081210006be6fcd9a84a9be009623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by lexicographical order (from highest to lowest).  <a href="classcoro__redis_1_1connection.html#ad06081210006be6fcd9a84a9be009623">More...</a><br /></td></tr>
<tr class="separator:ad06081210006be6fcd9a84a9be009623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1ca5b94db2ae8a09045eef8895772"><td class="memTemplParams" colspan="2">template&lt;typename Interval , typename Output &gt; </td></tr>
<tr class="memitem:ac0e1ca5b94db2ae8a09045eef8895772"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ac0e1ca5b94db2ae8a09045eef8895772">zrevrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:ac0e1ca5b94db2ae8a09045eef8895772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by score (ordered from highest to lowest).  <a href="classcoro__redis_1_1connection.html#ac0e1ca5b94db2ae8a09045eef8895772">More...</a><br /></td></tr>
<tr class="separator:ac0e1ca5b94db2ae8a09045eef8895772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca5c9033bb06455192c844034ee1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a44ca5c9033bb06455192c844034ee1aa">zrevrank</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a44ca5c9033bb06455192c844034ee1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank (from high to low) of the given member in the sorted set.  <a href="classcoro__redis_1_1connection.html#a44ca5c9033bb06455192c844034ee1aa">More...</a><br /></td></tr>
<tr class="separator:a44ca5c9033bb06455192c844034ee1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ed4c56ec2b29baedd765bb959db47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a08ed4c56ec2b29baedd765bb959db47f">zscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:a08ed4c56ec2b29baedd765bb959db47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all members of the given sorted set.  <a href="classcoro__redis_1_1connection.html#a08ed4c56ec2b29baedd765bb959db47f">More...</a><br /></td></tr>
<tr class="separator:a08ed4c56ec2b29baedd765bb959db47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8384ff8b266f061f8b91ee82bcd1d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ad8384ff8b266f061f8b91ee82bcd1d08">zscan</a> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count)</td></tr>
<tr class="memdesc:ad8384ff8b266f061f8b91ee82bcd1d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all members of the given sorted set.  <a href="classcoro__redis_1_1connection.html#ad8384ff8b266f061f8b91ee82bcd1d08">More...</a><br /></td></tr>
<tr class="separator:ad8384ff8b266f061f8b91ee82bcd1d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2906b672390c31397337dde2b7589a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#ae2906b672390c31397337dde2b7589a8">zscore</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:ae2906b672390c31397337dde2b7589a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score of the given member.  <a href="classcoro__redis_1_1connection.html#ae2906b672390c31397337dde2b7589a8">More...</a><br /></td></tr>
<tr class="separator:ae2906b672390c31397337dde2b7589a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915aaa8740febd6c0aee3873a2f2b692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a915aaa8740febd6c0aee3873a2f2b692">zunionstore</a> (std::string_view destination, std::initializer_list&lt; std::string_view &gt; keys, std::string_view aggregate=&quot;SUM&quot;)</td></tr>
<tr class="memdesc:a915aaa8740febd6c0aee3873a2f2b692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sorted set to another one with the scores being multiplied by a factor.  <a href="classcoro__redis_1_1connection.html#a915aaa8740febd6c0aee3873a2f2b692">More...</a><br /></td></tr>
<tr class="separator:a915aaa8740febd6c0aee3873a2f2b692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefed2309e7dca4ad65306d2d6fee24de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#aefed2309e7dca4ad65306d2d6fee24de">zunionstore</a> (std::string_view destination, std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt; kvs, std::string_view aggregate=&quot;SUM&quot;)</td></tr>
<tr class="memdesc:aefed2309e7dca4ad65306d2d6fee24de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get union of multiple sorted sets, and store the result to another one.  <a href="classcoro__redis_1_1connection.html#aefed2309e7dca4ad65306d2d6fee24de">More...</a><br /></td></tr>
<tr class="separator:aefed2309e7dca4ad65306d2d6fee24de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22df18fd13c20da831ddc8660f185d2e"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a22df18fd13c20da831ddc8660f185d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1connection.html#a22df18fd13c20da831ddc8660f185d2e">pfadd</a> (std::string_view key, Args &amp;&amp;...elements)</td></tr>
<tr class="memdesc:a22df18fd13c20da831ddc8660f185d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given element to a hyperloglog.  <a href="classcoro__redis_1_1connection.html#a22df18fd13c20da831ddc8660f185d2e">More...</a><br /></td></tr>
<tr class="separator:a22df18fd13c20da831ddc8660f185d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad4232d3ffc9ec471f25384ebbbfce0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4232d3ffc9ec471f25384ebbbfce0ec">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::append </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the given string to the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">str</td><td>String to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string after the append operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/append">https://redis.io/commands/append</a> </dd></dl>

</div>
</div>
<a id="a053c896b24742f8ee1483b9d15a72a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053c896b24742f8ee1483b9d15a72a6f">&#9670;&nbsp;</a></span>auth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::auth </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send password to Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Normally, you should not call this method. Instead, you should set password with <code>ConnectionOptions</code> or URI. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/auth">https://redis.io/commands/auth</a> </dd></dl>

</div>
</div>
<a id="af29d06015e269af8de7e53ebfc70a578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29d06015e269af8de7e53ebfc70a578">&#9670;&nbsp;</a></span>auth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::auth </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send user and password to Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>User name. </td></tr>
    <tr><td class="paramname">password</td><td>Password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Normally, you should not call this method. Instead, you should set password with <code>ConnectionOptions</code> or URI. Also this overload only works with Redis 6.0 or later. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/auth">https://redis.io/commands/auth</a> </dd></dl>

</div>
</div>
<a id="a8f223085ec27116d2a2a7c80675095b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f223085ec27116d2a2a7c80675095b2">&#9670;&nbsp;</a></span>bgrewriteaof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::bgrewriteaof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite AOF in the background. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bgrewriteaof">https://redis.io/commands/bgrewriteaof</a> </dd></dl>

</div>
</div>
<a id="a2236759698088791904610853f9713bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2236759698088791904610853f9713bd">&#9670;&nbsp;</a></span>bgsave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::bgsave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save database in the background. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bgsave">https://redis.io/commands/bgsave</a> </dd></dl>

</div>
</div>
<a id="a0563b62bb80f5041bc62fbc7e37a01f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0563b62bb80f5041bc62fbc7e37a01f3">&#9670;&nbsp;</a></span>bitcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::bitcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bits that have been set for the given range of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits that have been set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The index can be negative to index from the end of the string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitcount">https://redis.io/commands/bitcount</a> </dd></dl>

</div>
</div>
<a id="a0063ff6a10d63fdd8cea80f628f8beb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0063ff6a10d63fdd8cea80f628f8beb6">&#9670;&nbsp;</a></span>bitop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::bitop </td>
          <td>(</td>
          <td class="paramtype">BitOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do bit operation on the string stored at <code>key</code>, and save the result to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Bit operations. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination key where the result is saved. </td></tr>
    <tr><td class="paramname">key</td><td>The key where the string to be operated is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string saved at <code>destination</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitop">https://redis.io/commands/bitop</a> </dd>
<dd>
<code>BitOp</code> </dd></dl>

</div>
</div>
<a id="a6cf9032a56c8a40e50b9fc2a743c1df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf9032a56c8a40e50b9fc2a743c1df2">&#9670;&nbsp;</a></span>bitpos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::bitpos </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of the first bit set to 0 or 1 in the given range of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">bit</td><td>0 or 1. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first bit set to 0 or 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitpos">https://redis.io/commands/bitpos</a> </dd></dl>

</div>
</div>
<a id="a1c96a34b19735eb486b57727acf648ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c96a34b19735eb486b57727acf648ae">&#9670;&nbsp;</a></span>bzpopmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::bzpopmax </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with highest score from sorted set in a blocking way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. 0 means block forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key-member-score tuple with the highest score. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zpopmax</code> </dd>
<dd>
<a href="https://redis.io/commands/bzpopmax">https://redis.io/commands/bzpopmax</a> </dd></dl>

</div>
</div>
<a id="a1b0f93295c624c58ec90092470eb4e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0f93295c624c58ec90092470eb4e8f">&#9670;&nbsp;</a></span>bzpopmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::bzpopmin </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with lowest score from sorted set in a blocking way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. 0 means block forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key-member-score tuple with the lowest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty and timeout reaches, <code>bzpopmin</code> returns <code>Optional&lt;std::tuple&lt;std::string, std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zpopmin</code> </dd>
<dd>
<a href="https://redis.io/commands/bzpopmin">https://redis.io/commands/bzpopmin</a> </dd></dl>

</div>
</div>
<a id="abfb21388b1c6ca502d979872956783c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb21388b1c6ca502d979872956783c2">&#9670;&nbsp;</a></span>command() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CORO_RET  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;CORO_RET&gt; coro_redis::connection::command </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send redis command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Redis command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Redis return. </dd></dl>

</div>
</div>
<a id="a7a033547c7cf74ece1e63d934baefa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a033547c7cf74ece1e63d934baefa0d">&#9670;&nbsp;</a></span>command() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CORO_RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;CORO_RET&gt; coro_redis::connection::command </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::optional&lt; CORO_RET &gt;(redisReply *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>reply_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send redis command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Redis command. </td></tr>
    <tr><td class="paramname">reply_op</td><td>Callback for deal redis reply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Redis return. </dd></dl>

</div>
</div>
<a id="a19f58c12cb4e3dcb9bcebcb05c1f77ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f58c12cb4e3dcb9bcebcb05c1f77ad">&#9670;&nbsp;</a></span>dbsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::dbsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the currently selected database. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of keys in currently selected database. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/dbsize">https://redis.io/commands/dbsize</a> </dd></dl>

</div>
</div>
<a id="a51a63deb0639ec62c2c7733c0d1ef8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a63deb0639ec62c2c7733c0d1ef8d6">&#9670;&nbsp;</a></span>decr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::decr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the integer stored at key by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the decrement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/decr">https://redis.io/commands/decr</a> </dd></dl>

</div>
</div>
<a id="aed723efe41b4056ea548fb9992ac3d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed723efe41b4056ea548fb9992ac3d19">&#9670;&nbsp;</a></span>decrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::decrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>decrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the integer stored at key by <code>decrement</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">decrement</td><td>Decrement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the decrement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/decrby">https://redis.io/commands/decrby</a> </dd></dl>

</div>
</div>
<a id="a55f31e338b00c1fe8d6fb2a570fbec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f31e338b00c1fe8d6fb2a570fbec09">&#9670;&nbsp;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::del </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of keys removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the key exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/del">https://redis.io/commands/del</a> </dd></dl>

</div>
</div>
<a id="ab8cfc92e0f436191a331c3aeafc993fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cfc92e0f436191a331c3aeafc993fd">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::dump </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the serialized valued stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serialized value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>dump</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/dump">https://redis.io/commands/dump</a> </dd></dl>

</div>
</div>
<a id="a2deef3ca4950d717dc2d6acf361546b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2deef3ca4950d717dc2d6acf361546b3">&#9670;&nbsp;</a></span>echo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::echo </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask Redis to return the given message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the given message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/echo">https://redis.io/commands/echo</a> </dd></dl>

</div>
</div>
<a id="a017f0ff851950f200e44549ab1b3b2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017f0ff851950f200e44549ab1b3b2db">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::exists </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given key exists. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/exists">https://redis.io/commands/exists</a> </dd></dl>

</div>
</div>
<a id="ac5cf2083d12feedc62259ce14dfcbde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cf2083d12feedc62259ce14dfcbde6">&#9670;&nbsp;</a></span>expire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::expire </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/expire">https://redis.io/commands/expire</a> </dd></dl>

</div>
</div>
<a id="ab176839e4e17f0bc23b08d7d67f491af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab176839e4e17f0bc23b08d7d67f491af">&#9670;&nbsp;</a></span>expireat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::expireat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key, i.e. expire the key at a future time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time in seconds since UNIX epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/expireat">https://redis.io/commands/expireat</a> </dd></dl>

</div>
</div>
<a id="a19d7e47e54ecaebc61ae010eddea7a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d7e47e54ecaebc61ae010eddea7a09">&#9670;&nbsp;</a></span>flushall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::flushall </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys of all databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>Whether flushing databases asynchronously, i.e. without blocking the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/flushall">https://redis.io/commands/flushall</a> </dd></dl>

</div>
</div>
<a id="a67bad74156f9b5d8ccd69e0076da39c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bad74156f9b5d8ccd69e0076da39c4">&#9670;&nbsp;</a></span>flushdb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::flushdb </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys of current databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>Whether flushing databases asynchronously, i.e. without blocking the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/flushdb">https://redis.io/commands/flushdb</a> </dd></dl>

</div>
</div>
<a id="ada68fe844500fcd9467439ac93bd7df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada68fe844500fcd9467439ac93bd7df0">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::get </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the string value stored at key. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value stored at key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>get</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/get">https://redis.io/commands/get</a> </dd></dl>

</div>
</div>
<a id="ae0ac5281ac5609578976ae5ccf4d5eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ac5281ac5609578976ae5ccf4d5eaa">&#9670;&nbsp;</a></span>getbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::getbit </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bit value at offset in the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getbit">https://redis.io/commands/getbit</a> </dd></dl>

</div>
</div>
<a id="a3b84598bf82a570373e9e6a7c8982281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b84598bf82a570373e9e6a7c8982281">&#9670;&nbsp;</a></span>getrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::getrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring of the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substring in range [start, end]. If key does not exist, return an empty string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getrange">https://redis.io/commands/getrange</a> </dd></dl>

</div>
</div>
<a id="a1cc8a4077ed7473ab57c4c3fdd83acd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc8a4077ed7473ab57c4c3fdd83acd5">&#9670;&nbsp;</a></span>getset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::getset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically set the string stored at <code>key</code> to <code>val</code>, and return the old value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value stored at key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>getset</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getset">https://redis.io/commands/getset</a> </dd>
<dd>
<code>OptionalString</code> </dd></dl>

</div>
</div>
<a id="ae830197544cc6dcad0e4aa4100b69ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae830197544cc6dcad0e4aa4100b69ba5">&#9670;&nbsp;</a></span>hdel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hdel </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given field from hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the field exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the field does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hdel">https://redis.io/commands/hdel</a> </dd></dl>

</div>
</div>
<a id="af18481bc17156e36b8525e3905820aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18481bc17156e36b8525e3905820aff">&#9670;&nbsp;</a></span>hexists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hexists </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given field exists in hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field exists. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the field exists in hash. </td></tr>
    <tr><td class="paramname">false</td><td>If the field does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hexists">https://redis.io/commands/hexists</a> </dd></dl>

</div>
</div>
<a id="a97559a977aa31fc34c5a2673fc10959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97559a977aa31fc34c5a2673fc10959e">&#9670;&nbsp;</a></span>hget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::hget </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the given field. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If field does not exist, <code>hget</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hget">https://redis.io/commands/hget</a> </dd></dl>

</div>
</div>
<a id="a78a31f108f12cfad311764fd087d0cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a31f108f12cfad311764fd087d0cb9">&#9670;&nbsp;</a></span>hgetall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::hgetall </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all field-value pairs of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; results;</div>
<div class="line"><span class="comment">// Save all field-value pairs of a Redis hash to an unordered_map&lt;string, string&gt;.</span></div>
<div class="line">redis.hgetall(<span class="stringliteral">&quot;hash&quot;</span>, std::inserter(results, results.begin()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hgetall</code> on a large hash, since it will block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a> </dd></dl>

</div>
</div>
<a id="ae229c1c7b9c775534d1b4f842ffb52c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae229c1c7b9c775534d1b4f842ffb52c1">&#9670;&nbsp;</a></span>hincrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hincrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hincrby">https://redis.io/commands/hincrby</a> </dd></dl>

</div>
</div>
<a id="a2a5c7016421f54076209ed2c206199d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5c7016421f54076209ed2c206199d5">&#9670;&nbsp;</a></span>hincrbyfloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;double&gt; coro_redis::connection::hincrbyfloat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the floating point number stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hincrbyfloat">https://redis.io/commands/hincrbyfloat</a> </dd></dl>

</div>
</div>
<a id="a7a5d8669f66783b6e4e8eddbc40fb351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5d8669f66783b6e4e8eddbc40fb351">&#9670;&nbsp;</a></span>hkeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::hkeys </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all fields of the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hkeys</code> on a large hash, since it will block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hkeys">https://redis.io/commands/hkeys</a> </dd></dl>

</div>
</div>
<a id="a29e4856f0acd73da41dd6f58156b7f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e4856f0acd73da41dd6f58156b7f10">&#9670;&nbsp;</a></span>hlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of fields of the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of fields. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hlen">https://redis.io/commands/hlen</a> </dd></dl>

</div>
</div>
<a id="ab063ec5901c6c537bccbd456d25768e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab063ec5901c6c537bccbd456d25768e9">&#9670;&nbsp;</a></span>hmget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::hmget </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of multiple fields. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; fields = {<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;f2&quot;</span>};</div>
<div class="line">std::vector&lt;OptionalString&gt; vals;</div>
<div class="line">redis.hmget(<span class="stringliteral">&quot;hash&quot;</span>, fields.begin(), fields.end(), std::back_inserter(vals));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : vals) {</div>
<div class="line">    <span class="keywordflow">if</span> (val)</div>
<div class="line">        std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;field not exist&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given field range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination should be a container of <code>OptionalString</code> type, since the given field might not exist (in this case, the value of the corresponding field is <code>OptionalString{}</code> (<code>std::nullopt</code>)). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hmget">https://redis.io/commands/hmget</a> </dd></dl>

</div>
</div>
<a id="a51586457832247fdd78c066856e179ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51586457832247fdd78c066856e179ae">&#9670;&nbsp;</a></span>hmset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::hmset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple field-value pairs of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; m = {{<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>}, {<span class="stringliteral">&quot;f2&quot;</span>, <span class="stringliteral">&quot;v2&quot;</span>}};</div>
<div class="line">redis.hmset(<span class="stringliteral">&quot;hash&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field-value pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hmset">https://redis.io/commands/hmset</a> </dd></dl>

</div>
</div>
<a id="a473d5b17dc67976f93fb03990a78f524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473d5b17dc67976f93fb03990a78f524">&#9670;&nbsp;</a></span>hscan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;scan_ret_t&gt; coro_redis::connection::hscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan fields of the given hash matching the given pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hscan">https://redis.io/commands/hscan</a> </dd></dl>

</div>
</div>
<a id="a693b246e5c607e9f99bb0f9ca9ed6c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b246e5c607e9f99bb0f9ca9ed6c5d">&#9670;&nbsp;</a></span>hscan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;scan_ret_t&gt; coro_redis::connection::hscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan fields of the given hash matching the given pattern. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cursor = 0LL;</div>
<div class="line">std::unordered_map&lt;std::string, std::string&gt; kvs;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    cursor = redis.hscan(<span class="stringliteral">&quot;hash&quot;</span>, cursor, <span class="stringliteral">&quot;pattern:*&quot;</span>, 10, std::inserter(kvs, kvs.begin()));</div>
<div class="line">    <span class="keywordflow">if</span> (cursor == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hscan">https://redis.io/commands/hscan</a> </dd></dl>

</div>
</div>
<a id="a0bad38b194fcf0a48924320db16442dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bad38b194fcf0a48924320db16442dd">&#9670;&nbsp;</a></span>hset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string_view, std::string_view &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>kvs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple fields of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; m = {{<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>}, {<span class="stringliteral">&quot;f2&quot;</span>, <span class="stringliteral">&quot;v2&quot;</span>}};</div>
<div class="line">redis.hset(<span class="stringliteral">&quot;hash&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field to be set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of fields that have been added, i.e. fields that not existed before. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hset">https://redis.io/commands/hset</a> </dd></dl>

</div>
</div>
<a id="a0524910dff990fdb4a4067416b4f61e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0524910dff990fdb4a4067416b4f61e5">&#9670;&nbsp;</a></span>hset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hash field to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given field is a new field. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the given field didn't exist, and a new field has been added. </td></tr>
    <tr><td class="paramname">false</td><td>If the given field already exists, and its value has been overwritten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <code>hset</code> returns false, it does not mean that the method failed to set the field. Instead, it means that the field already exists, and we've overwritten its value. If <code>hset</code> fails, it will throw an exception of <code>Exception</code> type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/sewenew/redis-plus-plus/issues/9">https://github.com/sewenew/redis-plus-plus/issues/9</a> </dd>
<dd>
<a href="https://redis.io/commands/hset">https://redis.io/commands/hset</a> </dd></dl>

</div>
</div>
<a id="a825cdab0a44b4fa90e97b616fe1db17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825cdab0a44b4fa90e97b616fe1db17b">&#9670;&nbsp;</a></span>hsetnx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hsetnx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hash field to value, only if the given field does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the field has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If failed to set the field, i.e. the field already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hsetnx">https://redis.io/commands/hsetnx</a> </dd></dl>

</div>
</div>
<a id="ae16f4dff1a5e5adc5b75e817088a6cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16f4dff1a5e5adc5b75e817088a6cac">&#9670;&nbsp;</a></span>hstrlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::hstrlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hstrlen">https://redis.io/commands/hstrlen</a> </dd></dl>

</div>
</div>
<a id="abfd739a75900b08cdeba96d5e7e36853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd739a75900b08cdeba96d5e7e36853">&#9670;&nbsp;</a></span>hvals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::hvals </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of all fields stored at the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hvals</code> on a large hash, since it might block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hvals">https://redis.io/commands/hvals</a> </dd></dl>

</div>
</div>
<a id="a15405af586017c881ccf547e21d29029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15405af586017c881ccf547e21d29029">&#9670;&nbsp;</a></span>incr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::incr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at key by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incr">https://redis.io/commands/incr</a> </dd></dl>

</div>
</div>
<a id="afb83115c674938f8035aa81ac46fcfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb83115c674938f8035aa81ac46fcfad">&#9670;&nbsp;</a></span>incrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::incrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at key by <code>increment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incrby">https://redis.io/commands/incrby</a> </dd></dl>

</div>
</div>
<a id="a6b91c11c100530889a870e93d53a51a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b91c11c100530889a870e93d53a51a3">&#9670;&nbsp;</a></span>incrbyfloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::incrbyfloat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the floating point number stored at key by <code>increment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incrbyfloat">https://redis.io/commands/incrbyfloat</a> </dd></dl>

</div>
</div>
<a id="ab87fb38dab79b8a578ea14de07032eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87fb38dab79b8a578ea14de07032eb2">&#9670;&nbsp;</a></span>info() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the info about the server. </p>
<dl class="section return"><dt>Returns</dt><dd>Server info. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/info">https://redis.io/commands/info</a> </dd></dl>

</div>
</div>
<a id="a90955401e15feb441e38efcaa67c8213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90955401e15feb441e38efcaa67c8213">&#9670;&nbsp;</a></span>info() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::info </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>section</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the info about the server on the given section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>Section. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Server info. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/info">https://redis.io/commands/info</a> </dd></dl>

</div>
</div>
<a id="af46ce7cfdfd8a474da62ac84ed68912a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ce7cfdfd8a474da62ac84ed68912a">&#9670;&nbsp;</a></span>lastsave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::lastsave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UNIX timestamp in seconds, at which the database was saved successfully. </p>
<dl class="section return"><dt>Returns</dt><dd>The last saving time. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lastsave">https://redis.io/commands/lastsave</a> </dd></dl>

</div>
</div>
<a id="a16d8a316acf9f1cc828393e36f287166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d8a316acf9f1cc828393e36f287166">&#9670;&nbsp;</a></span>llen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::llen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/llen">https://redis.io/commands/llen</a> </dd></dl>

</div>
</div>
<a id="adbda75130a7f03a206178464eb2b8daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbda75130a7f03a206178464eb2b8daa">&#9670;&nbsp;</a></span>lpop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::lpop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the first element of the list. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> element = redis.lpop(<span class="stringliteral">&quot;list&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (element)</div>
<div class="line">    std::cout &lt;&lt; *element &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;list is empty, i.e. list does not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If list is empty, i.e. key does not exist, return <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpop">https://redis.io/commands/lpop</a> </dd></dl>

</div>
</div>
<a id="a11a3ba1896904443d8cf247e412b81d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a3ba1896904443d8cf247e412b81d1">&#9670;&nbsp;</a></span>lpush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::lpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push multiple elements to the beginning of the list. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; elements = {<span class="stringliteral">&quot;e1&quot;</span>, <span class="stringliteral">&quot;e2&quot;</span>, <span class="stringliteral">&quot;e3&quot;</span>};</div>
<div class="line">redis.lpush(<span class="stringliteral">&quot;list&quot;</span>, elements.begin(), elements.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first element to be pushed. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given element range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a> </dd></dl>

</div>
</div>
<a id="ae45845b41c5ec7ed8276aff09d020dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45845b41c5ec7ed8276aff09d020dde">&#9670;&nbsp;</a></span>lpush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::lpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the beginning of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a> </dd></dl>

</div>
</div>
<a id="afd922e0b161e25204f35f6197bd905b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd922e0b161e25204f35f6197bd905b9">&#9670;&nbsp;</a></span>lpushx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::lpushx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the beginning of the list, only if the list already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpushx">https://redis.io/commands/lpushx</a> </dd></dl>

</div>
</div>
<a id="ad946e04bf24eb334eb5bad9cf316964c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad946e04bf24eb334eb5bad9cf316964c">&#9670;&nbsp;</a></span>lrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::lrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get elements in the given range of the given list. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; elements;</div>
<div class="line"><span class="comment">// Save all elements of a Redis list to a vector of string.</span></div>
<div class="line">redis.lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1, std::back_inserter(elements));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the range. Index can be negative, which mean index from the end. </td></tr>
    <tr><td class="paramname">stop</td><td>End index of the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the results are saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a> </dd></dl>

</div>
</div>
<a id="a04b9b8c2b25481d2f1f415c351f0b404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b9b8c2b25481d2f1f415c351f0b404">&#9670;&nbsp;</a></span>lrem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::lrem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first <code>count</code> occurrences of elements equal to <code>val</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">count</td><td>Number of occurrences to be removed. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>count</code> can be positive, negative and 0. Check the reference for detail. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lrem">https://redis.io/commands/lrem</a> </dd></dl>

</div>
</div>
<a id="aedda41154d6ca7dede1bb333af53bb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedda41154d6ca7dede1bb333af53bb3c">&#9670;&nbsp;</a></span>lset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::lset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element at the given index to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the element to be set. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lset">https://redis.io/commands/lset</a> </dd></dl>

</div>
</div>
<a id="a3331476c43dc86870ad1c02e3806002c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3331476c43dc86870ad1c02e3806002c">&#9670;&nbsp;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim a list to keep only element in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the key is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start of the index. </td></tr>
    <tr><td class="paramname">stop</td><td>End of the index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ltrim">https://redis.io/commands/ltrim</a> </dd></dl>

</div>
</div>
<a id="a3b7622a2775ff5436c6323bc3047314c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7622a2775ff5436c6323bc3047314c">&#9670;&nbsp;</a></span>mget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::mget </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values of multiple keys atomically. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;k3&quot;</span>};</div>
<div class="line">std::vector&lt;OptionalString&gt; vals;</div>
<div class="line">redis.mget(keys.begin(), keys.end(), std::back_inserter(vals));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : vals) {</div>
<div class="line">    <span class="keywordflow">if</span> (val)</div>
<div class="line">        std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;key does not exist&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first key of the given range. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the values are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination should be a container of <code>OptionalString</code> type, since the given key might not exist (in this case, the value of the corresponding key is <code>OptionalString{}</code> (<code>std::nullopt</code>)). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/mget">https://redis.io/commands/mget</a> </dd></dl>

</div>
</div>
<a id="a689a7e8b8a16aed7f33aa54b0902ef02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689a7e8b8a16aed7f33aa54b0902ef02">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::move </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get keys matching the given pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Pattern. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the returned keys are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>keys</code>, since it might block Redis for a long time, especially when the data set is very big. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::scan</code> </dd>
<dd>
<a href="https://redis.io/commands/keys">https://redis.io/commands/keys</a></dd></dl>
<p>Move a key to the given database. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">db</td><td>The destination database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether key has been moved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If key has been moved. </td></tr>
    <tr><td class="paramname">false</td><td>If key was not moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/move">https://redis.io/commands/move</a> </dd></dl>

</div>
</div>
<a id="a4ee444aebf7c2ec1af54130d69a188a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee444aebf7c2ec1af54130d69a188a0">&#9670;&nbsp;</a></span>mset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::mset </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple key-value pairs. </p>
<p>Example: </p><div class="fragment"><div class="line">redis.mset({std::make_pair(<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>), std::make_pair(<span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;v2&quot;</span>)});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>Initializer list of key-value pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/mset">https://redis.io/commands/mset</a> </dd></dl>

</div>
</div>
<a id="a3f36e89c01a047e3548893922b636006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f36e89c01a047e3548893922b636006">&#9670;&nbsp;</a></span>msetnx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::msetnx </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the given key-value pairs if all specified keys do not exist. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; kvs1;</div>
<div class="line">redis.msetnx(kvs1.begin(), kvs1.end());</div>
<div class="line">std::unordered_map&lt;std::string, std::string&gt; kvs2;</div>
<div class="line">redis.msetnx(kvs2.begin(), kvs2.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first key-value pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator of the given range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether all keys have been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If all keys have been set. </td></tr>
    <tr><td class="paramname">false</td><td>If no key was set, i.e. at least one key already exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/msetnx">https://redis.io/commands/msetnx</a> </dd></dl>

</div>
</div>
<a id="a6d8baeb4ead129d5a4bd89e26d359162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8baeb4ead129d5a4bd89e26d359162">&#9670;&nbsp;</a></span>persist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::persist </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been removed. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist, or does not have an associated timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/persist">https://redis.io/commands/persist</a> </dd></dl>

</div>
</div>
<a id="a76cf63d84981af3a540b374dcd59230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cf63d84981af3a540b374dcd59230e">&#9670;&nbsp;</a></span>pexpire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::pexpire </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pexpire">https://redis.io/commands/pexpire</a> </dd></dl>

</div>
</div>
<a id="a495a9990e6ee18a8cf6f89c5e94e1f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495a9990e6ee18a8cf6f89c5e94e1f7b">&#9670;&nbsp;</a></span>pexpireat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::pexpireat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key, i.e. expire the key at a future time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time in milliseconds since UNIX epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pexpireat">https://redis.io/commands/pexpireat</a> </dd></dl>

</div>
</div>
<a id="a22df18fd13c20da831ddc8660f185d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22df18fd13c20da831ddc8660f185d2e">&#9670;&nbsp;</a></span>pfadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::pfadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given element to a hyperloglog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of the hyperloglog. </td></tr>
    <tr><td class="paramname">element</td><td>Element to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any of hyperloglog's internal register has been altered. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If at least one internal register has been altered. </td></tr>
    <tr><td class="paramname">false</td><td>If none of internal registers has been altered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <code>pfadd</code> returns false, it does not mean that this method failed to add an element to the hyperloglog. Instead it means that the internal registers were not altered. If <code>pfadd</code> fails, it will throw an exception of <code>Exception</code> type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pfadd">https://redis.io/commands/pfadd</a> </dd></dl>

</div>
</div>
<a id="aff0e0968429299819868c697aeda5594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0e0968429299819868c697aeda5594">&#9670;&nbsp;</a></span>ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::ping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connection is alive. </p>
<dl class="section return"><dt>Returns</dt><dd>Always return <em>PONG</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ping">https://redis.io/commands/ping</a> </dd></dl>

</div>
</div>
<a id="a07d30d986d47d3cc8e0dcac31b40b6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d30d986d47d3cc8e0dcac31b40b6d6">&#9670;&nbsp;</a></span>ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::ping </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connection is alive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message sent to Redis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the given message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ping">https://redis.io/commands/ping</a> </dd></dl>

</div>
</div>
<a id="afd6be5f02ece4302ca958f82c75a1023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6be5f02ece4302ca958f82c75a1023">&#9670;&nbsp;</a></span>psetex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::psetex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set key-value pair with the given timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">ttl</td><td>Time-To-Live in milliseconds. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/psetex">https://redis.io/commands/psetex</a> </dd></dl>

</div>
</div>
<a id="ab126c366419ceeb14a35a8a87531567d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab126c366419ceeb14a35a8a87531567d">&#9670;&nbsp;</a></span>pttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::pttl </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the TTL of a key in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TTL of the key in milliseconds. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pttl">https://redis.io/commands/pttl</a> </dd></dl>

</div>
</div>
<a id="ad28bff6aba15c977d5be2849da557ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28bff6aba15c977d5be2849da557ee1">&#9670;&nbsp;</a></span>quit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After sending QUIT, only the current connection will be close, while other connections in the pool is still open. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/quit">https://redis.io/commands/quit</a> </dd></dl>

</div>
</div>
<a id="af7eed34f2ad3c28eb3c226763209f639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7eed34f2ad3c28eb3c226763209f639">&#9670;&nbsp;</a></span>randomkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::randomkey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random key from current database. </p>
<dl class="section return"><dt>Returns</dt><dd>A random key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the database is empty, <code>randomkey</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/randomkey">https://redis.io/commands/randomkey</a> </dd></dl>

</div>
</div>
<a id="abc8ae31f1e54e89f85239336c0b85e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8ae31f1e54e89f85239336c0b85e88">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::rename </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>newkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename <code>key</code> to <code>newkey</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be renamed. </td></tr>
    <tr><td class="paramname">newkey</td><td>The new name of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rename">https://redis.io/commands/rename</a> </dd></dl>

</div>
</div>
<a id="ae6a7684da219cc3d5913aa2015bb87bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a7684da219cc3d5913aa2015bb87bd">&#9670;&nbsp;</a></span>renamenx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::renamenx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>newkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename <code>key</code> to <code>newkey</code> if <code>newkey</code> does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be renamed. </td></tr>
    <tr><td class="paramname">newkey</td><td>The new name of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether key has been renamed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If key has been renamed. </td></tr>
    <tr><td class="paramname">false</td><td>If newkey already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/renamenx">https://redis.io/commands/renamenx</a> </dd></dl>

</div>
</div>
<a id="a6ea381fbdfe3a78ec968949d9ad17f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea381fbdfe3a78ec968949d9ad17f40">&#9670;&nbsp;</a></span>restore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::restore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a key with the value obtained by <code>Redis::dump</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value obtained by <code>Redis::dump</code>. </td></tr>
    <tr><td class="paramname">ttl</td><td>Timeout of the created key in milliseconds. If <code>ttl</code> is 0, set no timeout. </td></tr>
    <tr><td class="paramname">replace</td><td>Whether to overwrite an existing key. If <code>replace</code> is <code>true</code> and key already exists, throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/restore">https://redis.io/commands/restore</a> </dd></dl>

</div>
</div>
<a id="a26202808f72e0cee34370feb5176a990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26202808f72e0cee34370feb5176a990">&#9670;&nbsp;</a></span>rpop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::rpop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the list is empty, i.e. key does not exist, <code>rpop</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpop">https://redis.io/commands/rpop</a> </dd></dl>

</div>
</div>
<a id="a43f5814e56532472cc308924b05601bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f5814e56532472cc308924b05601bb">&#9670;&nbsp;</a></span>rpoplpush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::rpoplpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop last element of one list and push it to the left of another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Key of the source list. </td></tr>
    <tr><td class="paramname">destination</td><td>Key of the destination list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the source list does not exist, <code>rpoplpush</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/brpoplpush">https://redis.io/commands/brpoplpush</a> </dd></dl>

</div>
</div>
<a id="aa4cd2f18878363da88b3396ed5f92140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cd2f18878363da88b3396ed5f92140">&#9670;&nbsp;</a></span>rpush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::rpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpush">https://redis.io/commands/rpush</a> </dd></dl>

</div>
</div>
<a id="ad689b17dd12b81d8eee0c61c8af46f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad689b17dd12b81d8eee0c61c8af46f49">&#9670;&nbsp;</a></span>rpushx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::rpushx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the end of the list, only if the list already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpushx">https://redis.io/commands/rpushx</a> </dd></dl>

</div>
</div>
<a id="afae78f8359e8c4403bae06eb37134a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae78f8359e8c4403bae06eb37134a11">&#9670;&nbsp;</a></span>sadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::sadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a member to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given member is a new member. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>The member did not exist before, and it has been added now. </td></tr>
    <tr><td class="paramname">0</td><td>The member already exists before this operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sadd">https://redis.io/commands/sadd</a> </dd></dl>

</div>
</div>
<a id="afc1a92f05f3301c7be450f0a1ddd4268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1a92f05f3301c7be450f0a1ddd4268">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save databases into RDB file <b>synchronously</b>, i.e. block the server during saving. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/save">https://redis.io/commands/save</a> </dd></dl>

</div>
</div>
<a id="a58253ae2160e30500d428c04204820e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58253ae2160e30500d428c04204820e6">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;scan_ret_t&gt; coro_redis::connection::scan </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan keys of the database matching the given pattern. </p>
<p>Example: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of the keys to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many keys to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the returned keys are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> TODO: support the TYPE option for Redis 6.0. </dd></dl>

</div>
</div>
<a id="ab804b3a76f04ae92b5bba30176a5b276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab804b3a76f04ae92b5bba30176a5b276">&#9670;&nbsp;</a></span>scard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::scard </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/scard">https://redis.io/commands/scard</a> </dd></dl>

</div>
</div>
<a id="ae34007b3c150974f6226ad9ddbcf6ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34007b3c150974f6226ad9ddbcf6ec0">&#9670;&nbsp;</a></span>sdiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::sdiff </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the difference between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sdiff">https://redis.io/commands/sdiff</a> </dd></dl>

</div>
</div>
<a id="a89d1bdd4e520003743575f195e9126f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d1bdd4e520003743575f195e9126f9">&#9670;&nbsp;</a></span>sdiffstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::sdiffstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sdiffstore">https://redis.io/commands/sdiffstore</a> </dd></dl>

</div>
</div>
<a id="a15761493b97c165ebed7b21eb2e14d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15761493b97c165ebed7b21eb2e14d6f">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::select </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the Redis logical database. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/select">https://redis.io/commands/select</a> </dd></dl>

</div>
</div>
<a id="afeccc5e933ff6bdba9f5036cdbde226c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeccc5e933ff6bdba9f5036cdbde226c">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RedisSetValueType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::set </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedisTTLType&#160;</td>
          <td class="paramname"><em>ttl_type</em> = <code>RedisTTLType::EX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a key-value pair. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Set a key-value pair.</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"><span class="comment">// Set a key-value pair, and expire it after 10 seconds.</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, std::chrono::seconds(10));</div>
<div class="line"><span class="comment">// Set a key-value pair with a timeout, only if the key already exists.</span></div>
<div class="line"><span class="keywordflow">if</span> (redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, std::chrono::seconds(10), UpdateType::EXIST))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;OK&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key does not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
    <tr><td class="paramname">ttl</td><td>Timeout on the key. If <code>ttl</code> is 0ms, do not set timeout. </td></tr>
    <tr><td class="paramname">type</td><td>Options for set command:<ul>
<li>UpdateType::EXIST: Set the key only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Set the key only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always set the key no matter whether it exists. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the key has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If the key was not set, because of the given option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/set">https://redis.io/commands/set</a> </dd></dl>

</div>
</div>
<a id="ae8fea96606b8d320922b54920f9e5d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fea96606b8d320922b54920f9e5d78">&#9670;&nbsp;</a></span>setex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::setex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set key-value pair with the given timeout in seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">ttl</td><td>Time-To-Live in seconds. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setex">https://redis.io/commands/setex</a> </dd></dl>

</div>
</div>
<a id="ac25969e794c54b7cf0e5b0e5ff3558de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25969e794c54b7cf0e5b0e5ff3558de">&#9670;&nbsp;</a></span>setnx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::setnx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the key if it does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the key has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If the key was not set, i.e. the key already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setnx">https://redis.io/commands/setnx</a> </dd></dl>

</div>
</div>
<a id="ae4ffd58a1e50aba761fef42d71cf995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ffd58a1e50aba761fef42d71cf995d">&#9670;&nbsp;</a></span>setrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::setrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the substring starting from <code>offset</code> to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string after this operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setrange">https://redis.io/commands/setrange</a> </dd></dl>

</div>
</div>
<a id="a837b80595a7095ebe3191aeeaec855bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837b80595a7095ebe3191aeeaec855bd">&#9670;&nbsp;</a></span>sinter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::sinter </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the intersection between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sinter">https://redis.io/commands/sinter</a> </dd></dl>

</div>
</div>
<a id="aa53d39bb5ac7e8eaf7ad290582598781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53d39bb5ac7e8eaf7ad290582598781">&#9670;&nbsp;</a></span>sinterstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::sinterstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sinter">https://redis.io/commands/sinter</a> </dd></dl>

</div>
</div>
<a id="a8bb6f83c50a755f08df35914759d494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb6f83c50a755f08df35914759d494e">&#9670;&nbsp;</a></span>sismember()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::sismember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if <code>member</code> exists in the set stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>member</code> exists in the set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If it exists in the set. </td></tr>
    <tr><td class="paramname">false</td><td>If it does not exist in the set, or the given key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sismember">https://redis.io/commands/sismember</a> </dd></dl>

</div>
</div>
<a id="a96af15e7271ad5cc56a9c7903b05f69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96af15e7271ad5cc56a9c7903b05f69f">&#9670;&nbsp;</a></span>smembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::smembers </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all members in the given set. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_set&lt;std::string&gt; members1;</div>
<div class="line">redis.smembers(<span class="stringliteral">&quot;set&quot;</span>, std::inserter(members1, members1.begin()));</div>
<div class="line">std::vector&lt;std::string&gt; members2;</div>
<div class="line">redis.smembers(<span class="stringliteral">&quot;set&quot;</span>, std::back_inserter(members2));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a> </dd></dl>

</div>
</div>
<a id="a48759082bd38f1dffac7a9cca46c750b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48759082bd38f1dffac7a9cca46c750b">&#9670;&nbsp;</a></span>smove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::smove </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move <code>member</code> from one set to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Key of the set in which the member currently exists. </td></tr>
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been moved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the member has been moved. </td></tr>
    <tr><td class="paramname">false</td><td>If <code>member</code> does not exist in <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/smove">https://redis.io/commands/smove</a> </dd></dl>

</div>
</div>
<a id="aa70d6d3fb5f72aca377eb669ad071738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70d6d3fb5f72aca377eb669ad071738">&#9670;&nbsp;</a></span>spop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::spop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a random member from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the set is empty, <code>spop</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::srandmember</code> </dd>
<dd>
<a href="https://redis.io/commands/spop">https://redis.io/commands/spop</a> </dd></dl>

</div>
</div>
<a id="a47de17aaf41f253ec6fc252dd5e07105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47de17aaf41f253ec6fc252dd5e07105">&#9670;&nbsp;</a></span>srandmember() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::srandmember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random member of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the set is empty, <code>srandmember</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd>
<dd>
This method won't remove the member from the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::spop</code> </dd>
<dd>
<a href="https://redis.io/commands/srandmember">https://redis.io/commands/srandmember</a> </dd></dl>

</div>
</div>
<a id="ae94e8934c94982567b7a219dc9b4d33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94e8934c94982567b7a219dc9b4d33b">&#9670;&nbsp;</a></span>srandmember() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::srandmember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get multiple random members of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">count</td><td>Number of members to be returned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method won't remove members from the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::spop</code> </dd>
<dd>
<a href="https://redis.io/commands/srandmember">https://redis.io/commands/srandmember</a> </dd></dl>

</div>
</div>
<a id="acabe2699341bfc587fb1854fbbbfafce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabe2699341bfc587fb1854fbbbfafce">&#9670;&nbsp;</a></span>srem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::srem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a member from set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the given member exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the given member does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/srem">https://redis.io/commands/srem</a> </dd></dl>

</div>
</div>
<a id="aef19d95ae78e20e2cbd65de7eb8dce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef19d95ae78e20e2cbd65de7eb8dce37">&#9670;&nbsp;</a></span>sscan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;scan_ret_t&gt; coro_redis::connection::sscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan members of the set matching the given pattern. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cursor = 0LL;</div>
<div class="line">std::unordered_set&lt;std::string&gt; members;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    cursor = redis.sscan(<span class="stringliteral">&quot;set&quot;</span>, cursor, <span class="stringliteral">&quot;pattern:*&quot;</span>,</div>
<div class="line">        10, std::inserter(members, members.begin()));</div>
<div class="line">    <span class="keywordflow">if</span> (cursor == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sscan">https://redis.io/commands/sscan</a> </dd></dl>

</div>
</div>
<a id="a605cd2814bfaad5cb0b98bae4fe8ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605cd2814bfaad5cb0b98bae4fe8ca6a">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::strlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>strlen</code> returns 0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/strlen">https://redis.io/commands/strlen</a> </dd></dl>

</div>
</div>
<a id="a6a025bf4f30404005a1d0ff44ab93760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a025bf4f30404005a1d0ff44ab93760">&#9670;&nbsp;</a></span>sunion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::sunion </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the union between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sunion">https://redis.io/commands/sunion</a> </dd></dl>

</div>
</div>
<a id="a6a0dac727f995ff1733702db98068c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0dac727f995ff1733702db98068c3e">&#9670;&nbsp;</a></span>sunionstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::sunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sunionstore">https://redis.io/commands/sunionstore</a> </dd></dl>

</div>
</div>
<a id="a6a3d14434c22a64c54d1f37d04ff6251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3d14434c22a64c54d1f37d04ff6251">&#9670;&nbsp;</a></span>swapdb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::swapdb </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two Redis databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx1</td><td>The index of the first database. </td></tr>
    <tr><td class="paramname">idx2</td><td>The index of the second database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/swapdb">https://redis.io/commands/swapdb</a> </dd></dl>

</div>
</div>
<a id="ad88fd4dddeafbc96ae811c464e1bcfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88fd4dddeafbc96ae811c464e1bcfd6">&#9670;&nbsp;</a></span>touch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::touch </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the last access time of the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether last access time of the key has been updated. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists, and last access time has been updated. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/touch">https://redis.io/commands/touch</a> </dd></dl>

</div>
</div>
<a id="a775641846f891eb9ffbc0ca3d3f0f701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775641846f891eb9ffbc0ca3d3f0f701">&#9670;&nbsp;</a></span>ttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::ttl </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining Time-To-Live of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TTL in seconds. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TTL</td><td>If the key has a timeout. </td></tr>
    <tr><td class="paramname">-1</td><td>If the key exists but does not have a timeout. </td></tr>
    <tr><td class="paramname">-2</td><td>If the key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Redis 2.6 or older, <code>ttl</code> returns -1 if the key does not exist, or if the key exists but does not have a timeout. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ttl">https://redis.io/commands/ttl</a> </dd></dl>

</div>
</div>
<a id="aeca0c8460495509dceef6c126aad74c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca0c8460495509dceef6c126aad74c0">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::type </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the value stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/type">https://redis.io/commands/type</a> </dd></dl>

</div>
</div>
<a id="aee365e2efe187b5dd5cdca56522dfc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee365e2efe187b5dd5cdca56522dfc3d">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::unlink </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given key asynchronously, i.e. without blocking Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/unlink">https://redis.io/commands/unlink</a> </dd></dl>

</div>
</div>
<a id="accfa75998e62391acecfd9cfd9146d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfa75998e62391acecfd9cfd9146d72">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::wait </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numslaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until previous write commands are successfully replicated to at least the specified number of replicas or the given timeout has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numslaves</td><td>Number of replicas. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. If timeout is 0ms, wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of replicas that have been successfully replicated these write commands. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The return value might be less than <code>numslaves</code>, because timeout has been reached. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/wait">https://redis.io/commands/wait</a> </dd></dl>

</div>
</div>
<a id="add1cce10823abed44cac9ebafeda827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1cce10823abed44cac9ebafeda827f">&#9670;&nbsp;</a></span>zadd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update multiple members with score to sorted set. </p>
<p>Example: </p><div class="fragment"><div class="line">redis.zadd(<span class="stringliteral">&quot;zset&quot;</span>, {std::make_pair(<span class="stringliteral">&quot;m1&quot;</span>, 1.4), std::make_pair(<span class="stringliteral">&quot;m2&quot;</span>, 2.3)});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first member-score pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the member-score pairs range. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: <code>auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>UpdateType</code> </dd>
<dd>
<a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="a4eefcd2da2b37e6e90ef6ed33d24a6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eefcd2da2b37e6e90ef6ed33d24a6f2">&#9670;&nbsp;</a></span>zadd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update a member with score to sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be added. </td></tr>
    <tr><td class="paramname">score</td><td>Score of the member. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: <code>auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>UpdateType</code> </dd>
<dd>
<a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="abfb87c67b9b788709a98484c64f4873d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb87c67b9b788709a98484c64f4873d">&#9670;&nbsp;</a></span>zadd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt;&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update multiple members with score to sorted set. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, double&gt; m = {{<span class="stringliteral">&quot;m1&quot;</span>, 1.2}, {<span class="stringliteral">&quot;m2&quot;</span>, 2.3}};</div>
<div class="line">redis.zadd(<span class="stringliteral">&quot;zset&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first member-score pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the member-score pairs range. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: <code>auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>UpdateType</code> </dd>
<dd>
<a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="a565f8f5f55bd343b4d2376b310199074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565f8f5f55bd343b4d2376b310199074">&#9670;&nbsp;</a></span>zcard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zcard </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members in the sorted set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zcard">https://redis.io/commands/zcard</a> </dd></dl>

</div>
</div>
<a id="a0d819629c9ac46d15ab867895c147f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d819629c9ac46d15ab867895c147f68">&#9670;&nbsp;</a></span>zcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members with score between a min-max score range. </p>
<p>Example: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>The min-max score range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members with score between a min-max score range. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zcount">https://redis.io/commands/zcount</a> </dd></dl>

</div>
</div>
<a id="aaf56d03fa902498938cb308e3d82f668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf56d03fa902498938cb308e3d82f668">&#9670;&nbsp;</a></span>zincrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;double&gt; coro_redis::connection::zincrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the score of given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The score of the member after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zincrby">https://redis.io/commands/zincrby</a> </dd></dl>

</div>
</div>
<a id="a331b54a20f1d8dfb1d19dec05b09c9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331b54a20f1d8dfb1d19dec05b09c9de">&#9670;&nbsp;</a></span>zlexcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zlexcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members between a min-max range in lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>The min-max range in lexicographical order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members between a min-max range in lexicographical order. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zlexcount">https://redis.io/commands/zlexcount</a> </dd></dl>

</div>
</div>
<a id="a95953804c9323874996df0616a1f88ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95953804c9323874996df0616a1f88ce">&#9670;&nbsp;</a></span>zpopmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::zpopmax </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with highest score from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Member-score pair with the highest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty <code>zpopmax</code> returns <code>Optional&lt;std::pair&lt;std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::bzpopmax</code> </dd>
<dd>
<a href="https://redis.io/commands/zpopmax">https://redis.io/commands/zpopmax</a> </dd></dl>

</div>
</div>
<a id="a57b4504cdba89e5591c3557312bdd159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4504cdba89e5591c3557312bdd159">&#9670;&nbsp;</a></span>zpopmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::zpopmin </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with lowest score from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Member-score pair with the lowest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty <code>zpopmin</code> returns <code>Optional&lt;std::pair&lt;std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::bzpopmin</code> </dd>
<dd>
<a href="https://redis.io/commands/zpopmin">https://redis.io/commands/zpopmin</a> </dd></dl>

</div>
</div>
<a id="ae74fb5fb4f874ba1d51ec9b9f52e3ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74fb5fb4f874ba1d51ec9b9f52e3ad9">&#9670;&nbsp;</a></span>zrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::zrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by rank (ordered from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// send *ZRANGE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line">redis.zrange(<span class="stringliteral">&quot;zset&quot;</span>, 0, -1, std::back_inserter(result));</div>
<div class="line"><span class="comment">// send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line">redis.zrange(<span class="stringliteral">&quot;zset&quot;</span>, 0, -1, std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZRANGE key start stop</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZRANGE key start stop WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrevrange</code> </dd>
<dd>
<a href="https://redis.io/commands/zrange">https://redis.io/commands/zrange</a> </dd></dl>

</div>
</div>
<a id="a72d1927794fc9ea00fc9f6fd197fdeb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d1927794fc9ea00fc9f6fd197fdeb6">&#9670;&nbsp;</a></span>zrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::zrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by lexicographical order (from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members between [abc, abd].</span></div>
<div class="line">redis.zrangebylex(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;std::string&gt;(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;abd&quot;</span>, BoundType::CLOSED),</div>
<div class="line">    std::back_inserter(result));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<code>Redis::zrevrangebylex</code> </dd>
<dd>
<a href="https://redis.io/commands/zrangebylex">https://redis.io/commands/zrangebylex</a> </dd></dl>

</div>
</div>
<a id="a5956657e0bfdc750ef4657783de7895e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5956657e0bfdc750ef4657783de7895e">&#9670;&nbsp;</a></span>zrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::vector&lt;std::string&gt; &gt; coro_redis::connection::zrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by score (ordered from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Send *ZRANGEBYSCORE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members whose score between (3, 6).</span></div>
<div class="line">redis.zrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;double&gt;(3, 6, BoundType::OPEN),</div>
<div class="line">    std::back_inserter(result));</div>
<div class="line"><span class="comment">// Send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line"><span class="comment">// Get members whose score between [3, +inf).</span></div>
<div class="line">redis.zrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, LeftBoundedInterval&lt;double&gt;(3, BoundType::RIGHT_OPEN),</div>
<div class="line">    std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZRANGEBYSCORE key min max</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZRANGEBYSCORE key min max WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd>
<dd>
See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrevrangebyscore</code> </dd>
<dd>
<a href="https://redis.io/commands/zrangebyscore">https://redis.io/commands/zrangebyscore</a> </dd></dl>

</div>
</div>
<a id="a266547b0feb67affdf2908f2a95dfa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266547b0feb67affdf2908f2a95dfa7f">&#9670;&nbsp;</a></span>zrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank (from low to high) of the given member in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the given member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the member does not exist, <code>zrank</code> returns <code>OptionalLongLong{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrank">https://redis.io/commands/zrank</a> </dd></dl>

</div>
</div>
<a id="af4df1864978dc050f6ca84d90ba604b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4df1864978dc050f6ca84d90ba604b6">&#9670;&nbsp;</a></span>zrem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zrem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given member from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the member exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the member does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrem">https://redis.io/commands/zrem</a> </dd></dl>

</div>
</div>
<a id="af1d798410b4149e405517c1568160003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d798410b4149e405517c1568160003">&#9670;&nbsp;</a></span>zremrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zremrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range of lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zremrangebylex">https://redis.io/commands/zremrangebylex</a> </dd></dl>

</div>
</div>
<a id="ac0a8419a27d5ddfcd59b9ee29370159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a8419a27d5ddfcd59b9ee29370159a">&#9670;&nbsp;</a></span>zremrangebyrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zremrangebyrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range ordered by rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zremrangebyrank">https://redis.io/commands/zremrangebyrank</a> </dd></dl>

</div>
</div>
<a id="af575ac9962e2fdb38419f80047435505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af575ac9962e2fdb38419f80047435505">&#9670;&nbsp;</a></span>zremrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zremrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range ordered by score. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zremrangebyscore">https://redis.io/commands/zremrangebyscore</a> </dd></dl>

</div>
</div>
<a id="a35e56767f8d5cfe663592cab12878b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e56767f8d5cfe663592cab12878b9a">&#9670;&nbsp;</a></span>zrevrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::zrevrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withscores</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by rank (ordered from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// send *ZREVRANGE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line">redis.zrevrange(<span class="stringliteral">&quot;key&quot;</span>, 0, -1, std::back_inserter(result));</div>
<div class="line"><span class="comment">// send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line">redis.zrevrange(<span class="stringliteral">&quot;key&quot;</span>, 0, -1, std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZREVRANGE key start stop</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZREVRANGE key start stop WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrange</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrange">https://redis.io/commands/zrevrange</a> </dd></dl>

</div>
</div>
<a id="ad06081210006be6fcd9a84a9be009623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06081210006be6fcd9a84a9be009623">&#9670;&nbsp;</a></span>zrevrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::zrevrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by lexicographical order (from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members between [abc, abd] in reverse order.</span></div>
<div class="line">redis.zrevrangebylex(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;std::string&gt;(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;abd&quot;</span>, BoundType::CLOSED),</div>
<div class="line">    std::back_inserter(result));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<code>Redis::zrangebylex</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrangebylex">https://redis.io/commands/zrevrangebylex</a> </dd></dl>

</div>
</div>
<a id="ac0e1ca5b94db2ae8a09045eef8895772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1ca5b94db2ae8a09045eef8895772">&#9670;&nbsp;</a></span>zrevrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;std::string&gt; coro_redis::connection::zrevrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by score (ordered from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Send *ZREVRANGEBYSCORE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members whose score between (3, 6) in reverse order.</span></div>
<div class="line">redis.zrevrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;double&gt;(3, 6, BoundType::OPEN),</div>
<div class="line">    std::back_inserter(result));</div>
<div class="line"><span class="comment">// Send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line"><span class="comment">// Get members whose score between [3, +inf) in reverse order.</span></div>
<div class="line">redis.zrevrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, LeftBoundedInterval&lt;double&gt;(3, BoundType::RIGHT_OPEN),</div>
<div class="line">    std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZREVRANGEBYSCORE key min max</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZREVRANGEBYSCORE key min max WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd>
<dd>
See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrangebyscore</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrangebyscore">https://redis.io/commands/zrevrangebyscore</a> </dd></dl>

</div>
</div>
<a id="a44ca5c9033bb06455192c844034ee1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ca5c9033bb06455192c844034ee1aa">&#9670;&nbsp;</a></span>zrevrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zrevrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank (from high to low) of the given member in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the given member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the member does not exist, <code>zrevrank</code> returns <code>OptionalLongLong{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrevrank">https://redis.io/commands/zrevrank</a> </dd></dl>

</div>
</div>
<a id="ad8384ff8b266f061f8b91ee82bcd1d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8384ff8b266f061f8b91ee82bcd1d08">&#9670;&nbsp;</a></span>zscan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;scan_ret_t&gt; coro_redis::connection::zscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan all members of the given sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscan">https://redis.io/commands/zscan</a> </dd></dl>

</div>
</div>
<a id="a08ed4c56ec2b29baedd765bb959db47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ed4c56ec2b29baedd765bb959db47f">&#9670;&nbsp;</a></span>zscan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan all members of the given sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many members to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscan">https://redis.io/commands/zscan</a> </dd></dl>

</div>
</div>
<a id="ae2906b672390c31397337dde2b7589a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2906b672390c31397337dde2b7589a8">&#9670;&nbsp;</a></span>zscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;double&gt; coro_redis::connection::zscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the score of the given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The score of the member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If member does not exist, <code>zscore</code> returns <code>OptionalDouble{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscore">https://redis.io/commands/zscore</a> </dd></dl>

</div>
</div>
<a id="a915aaa8740febd6c0aee3873a2f2b692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915aaa8740febd6c0aee3873a2f2b692">&#9670;&nbsp;</a></span>zunionstore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>aggregate</em> = <code>&quot;SUM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sorted set to another one with the scores being multiplied by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination sorted set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source sorted set. </td></tr>
    <tr><td class="paramname">weight</td><td>Weight to be multiplied to the score of each member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of members in the sorted set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There's no aggregation type parameter for single key overload, since these 3 types have the same effect. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zinterstore</code> </dd>
<dd>
<a href="https://redis.io/commands/zinterstore">https://redis.io/commands/zinterstore</a> </dd></dl>

</div>
</div>
<a id="aefed2309e7dca4ad65306d2d6fee24de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefed2309e7dca4ad65306d2d6fee24de">&#9670;&nbsp;</a></span>zunionstore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcoro__redis_1_1task__awaiter.html">awaiter_t</a>&lt;uint64_t&gt; coro_redis::connection::zunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt;&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>aggregate</em> = <code>&quot;SUM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get union of multiple sorted sets, and store the result to another one. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Use the default weight, i.e. 1,</span></div>
<div class="line"><span class="comment">// and use the sum of the all scores as the score of the result:</span></div>
<div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;k3&quot;</span>};</div>
<div class="line">redis.zunionstore(<span class="stringliteral">&quot;destination&quot;</span>, keys.begin(), keys.end());</div>
<div class="line"><span class="comment">// Each sorted set has a different weight,</span></div>
<div class="line"><span class="comment">// and the score of the result is the min of all scores.</span></div>
<div class="line">std::vector&lt;std::pair&lt;std::string, double&gt;&gt; keys_with_weights = {{<span class="stringliteral">&quot;k1&quot;</span>, 1}, {<span class="stringliteral">&quot;k2&quot;</span>, 2}};</div>
<div class="line">redis.zunionstore(<span class="stringliteral">&quot;destination&quot;</span>, keys_with_weights.begin(),</div>
<div class="line">    keys_with_weights.end(), Aggregation::MIN);</div>
<div class="line"><span class="comment">// NOTE: `keys_with_weights` can also be of type `std::unordered_map&lt;std::string, double&gt;`.</span></div>
<div class="line"><span class="comment">// However, it will be slower than std::vector&lt;std::pair&lt;std::string, double&gt;&gt;, since we use</span></div>
<div class="line"><span class="comment">// `std::distance(first, last)` to calculate the *numkeys* parameter.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination sorted set. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first sorted set (might with weight). </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the sorted set range. </td></tr>
    <tr><td class="paramname">type</td><td>How the scores are aggregated.<ul>
<li>Aggregation::SUM: Score of a member is the sum of all scores.</li>
<li>Aggregation::MIN: Score of a member is the min of all scores.</li>
<li>Aggregation::MAX: Score of a member is the max of all scores. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of members in the resulting sorted set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The score of each member can be multiplied by a factor, i.e. weight. If <code>Input</code> is an iterator to a container of <code>std::string</code>, we use the default weight, i.e. 1, and send <em>ZUNIONSTORE dest numkeys key [key ...] [AGGREGATE SUM|MIN|MAX]</em> command. If <code>Input</code> is an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, i.e. key-weight pair, we send the command with the given weights: <em>ZUNIONSTORE dest numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</em>. See the <em>Example</em> part for examples on how to use this command. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zinterstore</code> </dd>
<dd>
<a href="https://redis.io/commands/zunionstore">https://redis.io/commands/zunionstore</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/coro_redis/<a class="el" href="connection_8hpp_source.html">connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
