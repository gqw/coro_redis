<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coro_redis: coro_redis::coro_connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coro_redis
   &#160;<span id="projectnumber">1.0.0.0</span>
   </div>
   <div id="projectbrief">C++ Corotine Redis Client</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>coro_redis</b></li><li class="navelem"><a class="el" href="classcoro__redis_1_1coro__connection.html">coro_connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcoro__redis_1_1coro__connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">coro_redis::coro_connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>connection of corotine  
 <a href="classcoro__redis_1_1coro__connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="coro__connection_8hpp_source.html">coro_connection.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ae2bb310ba103fea6d59aff1cc42a11"><td class="memItemLeft" align="right" valign="top"><a id="a5ae2bb310ba103fea6d59aff1cc42a11"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BitOp</b> { <b>AND</b>, 
<b>OR</b>, 
<b>XOR</b>, 
<b>NOT</b>
 }</td></tr>
<tr class="separator:a5ae2bb310ba103fea6d59aff1cc42a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee26c08392506d5830e68b69c8059693"><td class="memItemLeft" align="right" valign="top"><a id="aee26c08392506d5830e68b69c8059693"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cptr</b> = std::shared_ptr&lt; <a class="el" href="classcoro__redis_1_1coro__connection.html">coro_connection</a> &gt;</td></tr>
<tr class="separator:aee26c08392506d5830e68b69c8059693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff7959518f7bef86a56ed4b61419b960"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aff7959518f7bef86a56ed4b61419b960">coro_connection</a> (redisAsyncContext *actx)</td></tr>
<tr class="memdesc:aff7959518f7bef86a56ed4b61419b960"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction  <a href="classcoro__redis_1_1coro__connection.html#aff7959518f7bef86a56ed4b61419b960">More...</a><br /></td></tr>
<tr class="separator:aff7959518f7bef86a56ed4b61419b960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8478ecb3c377ccd3e1253a21a993caef"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcoro__redis_1_1sync__connection.html">sync_connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a8478ecb3c377ccd3e1253a21a993caef">sync</a> ()</td></tr>
<tr class="memdesc:a8478ecb3c377ccd3e1253a21a993caef"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction  <a href="classcoro__redis_1_1coro__connection.html#a8478ecb3c377ccd3e1253a21a993caef">More...</a><br /></td></tr>
<tr class="separator:a8478ecb3c377ccd3e1253a21a993caef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0331d230fe9fd39316ca780d8eb810"><td class="memTemplParams" colspan="2">template&lt;typename CORO_RET  = std::string&gt; </td></tr>
<tr class="memitem:afb0331d230fe9fd39316ca780d8eb810"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; CORO_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#afb0331d230fe9fd39316ca780d8eb810">command</a> (std::string_view cmd) const</td></tr>
<tr class="memdesc:afb0331d230fe9fd39316ca780d8eb810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send redis command.  <a href="classcoro__redis_1_1coro__connection.html#afb0331d230fe9fd39316ca780d8eb810">More...</a><br /></td></tr>
<tr class="separator:afb0331d230fe9fd39316ca780d8eb810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad98a1fbb59805e2a229c39c22cf5bd"><td class="memTemplParams" colspan="2">template&lt;typename CORO_RET &gt; </td></tr>
<tr class="memitem:acad98a1fbb59805e2a229c39c22cf5bd"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; CORO_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#acad98a1fbb59805e2a229c39c22cf5bd">command</a> (std::string_view cmd, std::function&lt; std::optional&lt; CORO_RET &gt;(redisReply *)&gt; &amp;&amp;reply_op) const</td></tr>
<tr class="memdesc:acad98a1fbb59805e2a229c39c22cf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send redis command.  <a href="classcoro__redis_1_1coro__connection.html#acad98a1fbb59805e2a229c39c22cf5bd">More...</a><br /></td></tr>
<tr class="separator:acad98a1fbb59805e2a229c39c22cf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d200321ba33a1cacff857cf4de69e2"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a06d200321ba33a1cacff857cf4de69e2">auth</a> (std::string_view password)</td></tr>
<tr class="memdesc:a06d200321ba33a1cacff857cf4de69e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send password to Redis.  <a href="classcoro__redis_1_1coro__connection.html#a06d200321ba33a1cacff857cf4de69e2">More...</a><br /></td></tr>
<tr class="separator:a06d200321ba33a1cacff857cf4de69e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133f8c741a8ba3b3b9d378676aa06226"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a133f8c741a8ba3b3b9d378676aa06226">auth</a> (std::string_view user, std::string_view password)</td></tr>
<tr class="memdesc:a133f8c741a8ba3b3b9d378676aa06226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send user and password to Redis.  <a href="classcoro__redis_1_1coro__connection.html#a133f8c741a8ba3b3b9d378676aa06226">More...</a><br /></td></tr>
<tr class="separator:a133f8c741a8ba3b3b9d378676aa06226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fca0a60316bd227ee737d4ba5f15a"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a242fca0a60316bd227ee737d4ba5f15a">echo</a> (std::string_view msg) const</td></tr>
<tr class="memdesc:a242fca0a60316bd227ee737d4ba5f15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask Redis to return the given message.  <a href="classcoro__redis_1_1coro__connection.html#a242fca0a60316bd227ee737d4ba5f15a">More...</a><br /></td></tr>
<tr class="separator:a242fca0a60316bd227ee737d4ba5f15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831f88d7336e1c301a948942dffab418"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a831f88d7336e1c301a948942dffab418">ping</a> ()</td></tr>
<tr class="memdesc:a831f88d7336e1c301a948942dffab418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connection is alive.  <a href="classcoro__redis_1_1coro__connection.html#a831f88d7336e1c301a948942dffab418">More...</a><br /></td></tr>
<tr class="separator:a831f88d7336e1c301a948942dffab418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e68ed767a042006db11100b15d1c765"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a8e68ed767a042006db11100b15d1c765">ping</a> (std::string_view msg)</td></tr>
<tr class="memdesc:a8e68ed767a042006db11100b15d1c765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connection is alive.  <a href="classcoro__redis_1_1coro__connection.html#a8e68ed767a042006db11100b15d1c765">More...</a><br /></td></tr>
<tr class="separator:a8e68ed767a042006db11100b15d1c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a245370c5983cf37bc567b4ad2880e4"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a5a245370c5983cf37bc567b4ad2880e4">quit</a> ()</td></tr>
<tr class="memdesc:a5a245370c5983cf37bc567b4ad2880e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">After sending QUIT, only the current connection will be close, while other connections in the pool is still open.  <a href="classcoro__redis_1_1coro__connection.html#a5a245370c5983cf37bc567b4ad2880e4">More...</a><br /></td></tr>
<tr class="separator:a5a245370c5983cf37bc567b4ad2880e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6429926da586c8e18827cc50dae38f66"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6429926da586c8e18827cc50dae38f66">select</a> (uint64_t idx)</td></tr>
<tr class="memdesc:a6429926da586c8e18827cc50dae38f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the Redis logical database.  <a href="classcoro__redis_1_1coro__connection.html#a6429926da586c8e18827cc50dae38f66">More...</a><br /></td></tr>
<tr class="separator:a6429926da586c8e18827cc50dae38f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb6b91bcb4a1c8a4f9deaa51fbee477"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#adeb6b91bcb4a1c8a4f9deaa51fbee477">swapdb</a> (uint64_t idx1, uint64_t idx2)</td></tr>
<tr class="memdesc:adeb6b91bcb4a1c8a4f9deaa51fbee477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two Redis databases.  <a href="classcoro__redis_1_1coro__connection.html#adeb6b91bcb4a1c8a4f9deaa51fbee477">More...</a><br /></td></tr>
<tr class="separator:adeb6b91bcb4a1c8a4f9deaa51fbee477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea1a1692348c8a671ac9b3e0c5efddd"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aaea1a1692348c8a671ac9b3e0c5efddd">bgrewriteaof</a> ()</td></tr>
<tr class="memdesc:aaea1a1692348c8a671ac9b3e0c5efddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite AOF in the background.  <a href="classcoro__redis_1_1coro__connection.html#aaea1a1692348c8a671ac9b3e0c5efddd">More...</a><br /></td></tr>
<tr class="separator:aaea1a1692348c8a671ac9b3e0c5efddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fdd787464f9471ef3f6d3c03bb557b"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a66fdd787464f9471ef3f6d3c03bb557b">bgsave</a> ()</td></tr>
<tr class="memdesc:a66fdd787464f9471ef3f6d3c03bb557b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save database in the background.  <a href="classcoro__redis_1_1coro__connection.html#a66fdd787464f9471ef3f6d3c03bb557b">More...</a><br /></td></tr>
<tr class="separator:a66fdd787464f9471ef3f6d3c03bb557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d1bf9936d10baaf4f6f2d241ad8b1f"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ad9d1bf9936d10baaf4f6f2d241ad8b1f">dbsize</a> ()</td></tr>
<tr class="memdesc:ad9d1bf9936d10baaf4f6f2d241ad8b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the currently selected database.  <a href="classcoro__redis_1_1coro__connection.html#ad9d1bf9936d10baaf4f6f2d241ad8b1f">More...</a><br /></td></tr>
<tr class="separator:ad9d1bf9936d10baaf4f6f2d241ad8b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b5fa63aa787443f9a3f226f8fdd27d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a11b5fa63aa787443f9a3f226f8fdd27d">flushall</a> (bool async=false)</td></tr>
<tr class="memdesc:a11b5fa63aa787443f9a3f226f8fdd27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys of all databases.  <a href="classcoro__redis_1_1coro__connection.html#a11b5fa63aa787443f9a3f226f8fdd27d">More...</a><br /></td></tr>
<tr class="separator:a11b5fa63aa787443f9a3f226f8fdd27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52db6cc82bd99cfb4e80aeed9d5d0fd"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ad52db6cc82bd99cfb4e80aeed9d5d0fd">flushdb</a> (bool async=false)</td></tr>
<tr class="memdesc:ad52db6cc82bd99cfb4e80aeed9d5d0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys of current databases.  <a href="classcoro__redis_1_1coro__connection.html#ad52db6cc82bd99cfb4e80aeed9d5d0fd">More...</a><br /></td></tr>
<tr class="separator:ad52db6cc82bd99cfb4e80aeed9d5d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c85b49de3233b00fdd2c2dfc44e1d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a8c3c85b49de3233b00fdd2c2dfc44e1d">info</a> ()</td></tr>
<tr class="memdesc:a8c3c85b49de3233b00fdd2c2dfc44e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the info about the server.  <a href="classcoro__redis_1_1coro__connection.html#a8c3c85b49de3233b00fdd2c2dfc44e1d">More...</a><br /></td></tr>
<tr class="separator:a8c3c85b49de3233b00fdd2c2dfc44e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df4183a5e15a171774570101b4e30aa"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a9df4183a5e15a171774570101b4e30aa">info</a> (std::string_view section)</td></tr>
<tr class="memdesc:a9df4183a5e15a171774570101b4e30aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the info about the server on the given section.  <a href="classcoro__redis_1_1coro__connection.html#a9df4183a5e15a171774570101b4e30aa">More...</a><br /></td></tr>
<tr class="separator:a9df4183a5e15a171774570101b4e30aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37517cf941f9a7267734287e3f152dea"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a37517cf941f9a7267734287e3f152dea">lastsave</a> ()</td></tr>
<tr class="memdesc:a37517cf941f9a7267734287e3f152dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UNIX timestamp in seconds, at which the database was saved successfully.  <a href="classcoro__redis_1_1coro__connection.html#a37517cf941f9a7267734287e3f152dea">More...</a><br /></td></tr>
<tr class="separator:a37517cf941f9a7267734287e3f152dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f43c1b0021c9d60d15e17bf98d9b8c1"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0f43c1b0021c9d60d15e17bf98d9b8c1">save</a> ()</td></tr>
<tr class="memdesc:a0f43c1b0021c9d60d15e17bf98d9b8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save databases into RDB file <b>synchronously</b>, i.e. block the server during saving.  <a href="classcoro__redis_1_1coro__connection.html#a0f43c1b0021c9d60d15e17bf98d9b8c1">More...</a><br /></td></tr>
<tr class="separator:a0f43c1b0021c9d60d15e17bf98d9b8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3b69612b6ad498fc392420ed04e2c4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6e3b69612b6ad498fc392420ed04e2c4"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6e3b69612b6ad498fc392420ed04e2c4">del</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a6e3b69612b6ad498fc392420ed04e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given key.  <a href="classcoro__redis_1_1coro__connection.html#a6e3b69612b6ad498fc392420ed04e2c4">More...</a><br /></td></tr>
<tr class="separator:a6e3b69612b6ad498fc392420ed04e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16d167c0f172d2758b88cb7c779552f"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ae16d167c0f172d2758b88cb7c779552f">dump</a> (std::string_view key)</td></tr>
<tr class="memdesc:ae16d167c0f172d2758b88cb7c779552f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serialized valued stored at key.  <a href="classcoro__redis_1_1coro__connection.html#ae16d167c0f172d2758b88cb7c779552f">More...</a><br /></td></tr>
<tr class="separator:ae16d167c0f172d2758b88cb7c779552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b399c1e24b46e72a0a856c89e48573"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa4b399c1e24b46e72a0a856c89e48573"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aa4b399c1e24b46e72a0a856c89e48573">exists</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aa4b399c1e24b46e72a0a856c89e48573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given key exists.  <a href="classcoro__redis_1_1coro__connection.html#aa4b399c1e24b46e72a0a856c89e48573">More...</a><br /></td></tr>
<tr class="separator:aa4b399c1e24b46e72a0a856c89e48573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9609aa546610bb323afdbd43018996e9"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a9609aa546610bb323afdbd43018996e9">expire</a> (std::string_view key, uint64_t timeout)</td></tr>
<tr class="memdesc:a9609aa546610bb323afdbd43018996e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key.  <a href="classcoro__redis_1_1coro__connection.html#a9609aa546610bb323afdbd43018996e9">More...</a><br /></td></tr>
<tr class="separator:a9609aa546610bb323afdbd43018996e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb452b39c08b98a47860ef25f0de5f"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a1fbb452b39c08b98a47860ef25f0de5f">expireat</a> (std::string_view key, uint64_t timestamp)</td></tr>
<tr class="memdesc:a1fbb452b39c08b98a47860ef25f0de5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key, i.e. expire the key at a future time point.  <a href="classcoro__redis_1_1coro__connection.html#a1fbb452b39c08b98a47860ef25f0de5f">More...</a><br /></td></tr>
<tr class="separator:a1fbb452b39c08b98a47860ef25f0de5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8ad35553e2d0f618f64f7be80782d7"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a8b8ad35553e2d0f618f64f7be80782d7">move</a> (std::string_view key, uint64_t db)</td></tr>
<tr class="memdesc:a8b8ad35553e2d0f618f64f7be80782d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get keys matching the given pattern.  <a href="classcoro__redis_1_1coro__connection.html#a8b8ad35553e2d0f618f64f7be80782d7">More...</a><br /></td></tr>
<tr class="separator:a8b8ad35553e2d0f618f64f7be80782d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43120cf377919c87afcfa4d247c42fff"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a43120cf377919c87afcfa4d247c42fff">persist</a> (std::string_view key)</td></tr>
<tr class="memdesc:a43120cf377919c87afcfa4d247c42fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove timeout on key.  <a href="classcoro__redis_1_1coro__connection.html#a43120cf377919c87afcfa4d247c42fff">More...</a><br /></td></tr>
<tr class="separator:a43120cf377919c87afcfa4d247c42fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bd28a9a885f02d73af0cac8d815388"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a89bd28a9a885f02d73af0cac8d815388">pexpire</a> (std::string_view key, uint64_t timeout)</td></tr>
<tr class="memdesc:a89bd28a9a885f02d73af0cac8d815388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key.  <a href="classcoro__redis_1_1coro__connection.html#a89bd28a9a885f02d73af0cac8d815388">More...</a><br /></td></tr>
<tr class="separator:a89bd28a9a885f02d73af0cac8d815388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4925a6567993d32be66f149c4b319b"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a5a4925a6567993d32be66f149c4b319b">pexpireat</a> (std::string_view key, uint64_t timestamp)</td></tr>
<tr class="memdesc:a5a4925a6567993d32be66f149c4b319b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key, i.e. expire the key at a future time point.  <a href="classcoro__redis_1_1coro__connection.html#a5a4925a6567993d32be66f149c4b319b">More...</a><br /></td></tr>
<tr class="separator:a5a4925a6567993d32be66f149c4b319b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc31f719052dd6ff99db81b372708b35"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#abc31f719052dd6ff99db81b372708b35">pttl</a> (std::string_view key)</td></tr>
<tr class="memdesc:abc31f719052dd6ff99db81b372708b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TTL of a key in milliseconds.  <a href="classcoro__redis_1_1coro__connection.html#abc31f719052dd6ff99db81b372708b35">More...</a><br /></td></tr>
<tr class="separator:abc31f719052dd6ff99db81b372708b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd890122ffe0335dcfaa95231a6aced"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a9fd890122ffe0335dcfaa95231a6aced">randomkey</a> ()</td></tr>
<tr class="memdesc:a9fd890122ffe0335dcfaa95231a6aced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random key from current database.  <a href="classcoro__redis_1_1coro__connection.html#a9fd890122ffe0335dcfaa95231a6aced">More...</a><br /></td></tr>
<tr class="separator:a9fd890122ffe0335dcfaa95231a6aced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf099822303789b07241f37fe2f711d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#abbf099822303789b07241f37fe2f711d">rename</a> (std::string_view key, std::string_view newkey)</td></tr>
<tr class="memdesc:abbf099822303789b07241f37fe2f711d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>key</code> to <code>newkey</code>.  <a href="classcoro__redis_1_1coro__connection.html#abbf099822303789b07241f37fe2f711d">More...</a><br /></td></tr>
<tr class="separator:abbf099822303789b07241f37fe2f711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6903146a136e342ad88c71169aeffe2c"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6903146a136e342ad88c71169aeffe2c">renamenx</a> (std::string_view key, std::string_view newkey)</td></tr>
<tr class="memdesc:a6903146a136e342ad88c71169aeffe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>key</code> to <code>newkey</code> if <code>newkey</code> does not exist.  <a href="classcoro__redis_1_1coro__connection.html#a6903146a136e342ad88c71169aeffe2c">More...</a><br /></td></tr>
<tr class="separator:a6903146a136e342ad88c71169aeffe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b35c7d9b89ed8c9f1b3c7e2c9dd89a"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a07b35c7d9b89ed8c9f1b3c7e2c9dd89a">restore</a> (std::string_view key, std::string_view val, uint64_t <a class="el" href="classcoro__redis_1_1coro__connection.html#a287efe339b95302b65542e83956c45d0">ttl</a>, bool replace=false)</td></tr>
<tr class="memdesc:a07b35c7d9b89ed8c9f1b3c7e2c9dd89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key with the value obtained by <code>Redis::dump</code>.  <a href="classcoro__redis_1_1coro__connection.html#a07b35c7d9b89ed8c9f1b3c7e2c9dd89a">More...</a><br /></td></tr>
<tr class="separator:a07b35c7d9b89ed8c9f1b3c7e2c9dd89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b27bcac3010c774797fa231004708b3"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0b27bcac3010c774797fa231004708b3">scan</a> (uint64_t cursor, uint64_t count=0)</td></tr>
<tr class="memdesc:a0b27bcac3010c774797fa231004708b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan keys of the database matching the given pattern.  <a href="classcoro__redis_1_1coro__connection.html#a0b27bcac3010c774797fa231004708b3">More...</a><br /></td></tr>
<tr class="separator:a0b27bcac3010c774797fa231004708b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb01e47d15b845358783d040d261fd2"><td class="memItemLeft" align="right" valign="top"><a id="a1bb01e47d15b845358783d040d261fd2"></a>
awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scan</b> (uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="separator:a1bb01e47d15b845358783d040d261fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4768777cb8ccb72a401391b4e1cfafdf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4768777cb8ccb72a401391b4e1cfafdf"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a4768777cb8ccb72a401391b4e1cfafdf">touch</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a4768777cb8ccb72a401391b4e1cfafdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the last access time of the given key.  <a href="classcoro__redis_1_1coro__connection.html#a4768777cb8ccb72a401391b4e1cfafdf">More...</a><br /></td></tr>
<tr class="separator:a4768777cb8ccb72a401391b4e1cfafdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287efe339b95302b65542e83956c45d0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a287efe339b95302b65542e83956c45d0">ttl</a> (std::string_view key)</td></tr>
<tr class="memdesc:a287efe339b95302b65542e83956c45d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining Time-To-Live of a key.  <a href="classcoro__redis_1_1coro__connection.html#a287efe339b95302b65542e83956c45d0">More...</a><br /></td></tr>
<tr class="separator:a287efe339b95302b65542e83956c45d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3dfb56bf418bd6e055cbf16cee5416"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a2f3dfb56bf418bd6e055cbf16cee5416">type</a> (std::string_view key)</td></tr>
<tr class="memdesc:a2f3dfb56bf418bd6e055cbf16cee5416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the value stored at key.  <a href="classcoro__redis_1_1coro__connection.html#a2f3dfb56bf418bd6e055cbf16cee5416">More...</a><br /></td></tr>
<tr class="separator:a2f3dfb56bf418bd6e055cbf16cee5416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714bdd65d2dec825c02d6a2ba965058e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a714bdd65d2dec825c02d6a2ba965058e"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a714bdd65d2dec825c02d6a2ba965058e">unlink</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a714bdd65d2dec825c02d6a2ba965058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given key asynchronously, i.e. without blocking Redis.  <a href="classcoro__redis_1_1coro__connection.html#a714bdd65d2dec825c02d6a2ba965058e">More...</a><br /></td></tr>
<tr class="separator:a714bdd65d2dec825c02d6a2ba965058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f602f3155d2b684d5983d8f94d6840"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a35f602f3155d2b684d5983d8f94d6840">wait</a> (uint64_t numslaves, uint64_t timeout)</td></tr>
<tr class="memdesc:a35f602f3155d2b684d5983d8f94d6840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until previous write commands are successfully replicated to at least the specified number of replicas or the given timeout has been reached.  <a href="classcoro__redis_1_1coro__connection.html#a35f602f3155d2b684d5983d8f94d6840">More...</a><br /></td></tr>
<tr class="separator:a35f602f3155d2b684d5983d8f94d6840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453f55ff8b067180e758c33a722f8f95"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a453f55ff8b067180e758c33a722f8f95">append</a> (std::string_view key, std::string_view str)</td></tr>
<tr class="memdesc:a453f55ff8b067180e758c33a722f8f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the given string to the string stored at key.  <a href="classcoro__redis_1_1coro__connection.html#a453f55ff8b067180e758c33a722f8f95">More...</a><br /></td></tr>
<tr class="separator:a453f55ff8b067180e758c33a722f8f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486f72d0b0b4586b60f74e4741639cb0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a486f72d0b0b4586b60f74e4741639cb0">bitcount</a> (std::string_view key, uint64_t start=0, uint64_t end=-1)</td></tr>
<tr class="memdesc:a486f72d0b0b4586b60f74e4741639cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits that have been set for the given range of the string.  <a href="classcoro__redis_1_1coro__connection.html#a486f72d0b0b4586b60f74e4741639cb0">More...</a><br /></td></tr>
<tr class="separator:a486f72d0b0b4586b60f74e4741639cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffd2b9440e25874139cedec3118573b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aaffd2b9440e25874139cedec3118573b"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aaffd2b9440e25874139cedec3118573b">bitop</a> (BitOp op, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aaffd2b9440e25874139cedec3118573b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do bit operation on the string stored at <code>key</code>, and save the result to <code>destination</code>.  <a href="classcoro__redis_1_1coro__connection.html#aaffd2b9440e25874139cedec3118573b">More...</a><br /></td></tr>
<tr class="separator:aaffd2b9440e25874139cedec3118573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f93e89f3b491dd0ab052d0578b86786"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a3f93e89f3b491dd0ab052d0578b86786">bitpos</a> (std::string_view key, uint64_t bit, uint64_t start=0, uint64_t end=-1)</td></tr>
<tr class="memdesc:a3f93e89f3b491dd0ab052d0578b86786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the first bit set to 0 or 1 in the given range of the string.  <a href="classcoro__redis_1_1coro__connection.html#a3f93e89f3b491dd0ab052d0578b86786">More...</a><br /></td></tr>
<tr class="separator:a3f93e89f3b491dd0ab052d0578b86786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cddc30fc181d3d5b349cf2d198a3c9d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a5cddc30fc181d3d5b349cf2d198a3c9d">decr</a> (std::string_view key)</td></tr>
<tr class="memdesc:a5cddc30fc181d3d5b349cf2d198a3c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the integer stored at key by 1.  <a href="classcoro__redis_1_1coro__connection.html#a5cddc30fc181d3d5b349cf2d198a3c9d">More...</a><br /></td></tr>
<tr class="separator:a5cddc30fc181d3d5b349cf2d198a3c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe809531f975362d1b2327947012584c"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#abe809531f975362d1b2327947012584c">decrby</a> (std::string_view key, uint64_t decrement)</td></tr>
<tr class="memdesc:abe809531f975362d1b2327947012584c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the integer stored at key by <code>decrement</code>.  <a href="classcoro__redis_1_1coro__connection.html#abe809531f975362d1b2327947012584c">More...</a><br /></td></tr>
<tr class="separator:abe809531f975362d1b2327947012584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42ff00230cefbb87bd5822ac8576878"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aa42ff00230cefbb87bd5822ac8576878">get</a> (std::string_view key) const</td></tr>
<tr class="memdesc:aa42ff00230cefbb87bd5822ac8576878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string value stored at key.  <a href="classcoro__redis_1_1coro__connection.html#aa42ff00230cefbb87bd5822ac8576878">More...</a><br /></td></tr>
<tr class="separator:aa42ff00230cefbb87bd5822ac8576878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d9cc3b95a3f70f59be32fd6af2f3f3"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ac6d9cc3b95a3f70f59be32fd6af2f3f3">getbit</a> (std::string_view key, uint64_t offset)</td></tr>
<tr class="memdesc:ac6d9cc3b95a3f70f59be32fd6af2f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit value at offset in the string.  <a href="classcoro__redis_1_1coro__connection.html#ac6d9cc3b95a3f70f59be32fd6af2f3f3">More...</a><br /></td></tr>
<tr class="separator:ac6d9cc3b95a3f70f59be32fd6af2f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f05737d51b501b653a6664d5accc97"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a97f05737d51b501b653a6664d5accc97">getrange</a> (std::string_view key, uint64_t start, uint64_t end)</td></tr>
<tr class="memdesc:a97f05737d51b501b653a6664d5accc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring of the string stored at key.  <a href="classcoro__redis_1_1coro__connection.html#a97f05737d51b501b653a6664d5accc97">More...</a><br /></td></tr>
<tr class="separator:a97f05737d51b501b653a6664d5accc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0864dcaba3cdbe57efb662228b09d4"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aed0864dcaba3cdbe57efb662228b09d4">getset</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:aed0864dcaba3cdbe57efb662228b09d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically set the string stored at <code>key</code> to <code>val</code>, and return the old value.  <a href="classcoro__redis_1_1coro__connection.html#aed0864dcaba3cdbe57efb662228b09d4">More...</a><br /></td></tr>
<tr class="separator:aed0864dcaba3cdbe57efb662228b09d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb4ca2cefee0bdeaed216ead443c1a"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aaddb4ca2cefee0bdeaed216ead443c1a">incr</a> (std::string_view key)</td></tr>
<tr class="memdesc:aaddb4ca2cefee0bdeaed216ead443c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at key by 1.  <a href="classcoro__redis_1_1coro__connection.html#aaddb4ca2cefee0bdeaed216ead443c1a">More...</a><br /></td></tr>
<tr class="separator:aaddb4ca2cefee0bdeaed216ead443c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1cdbc15cf41053531f579f9cf9b5b"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a27b1cdbc15cf41053531f579f9cf9b5b">incrby</a> (std::string_view key, uint64_t increment)</td></tr>
<tr class="memdesc:a27b1cdbc15cf41053531f579f9cf9b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at key by <code>increment</code>.  <a href="classcoro__redis_1_1coro__connection.html#a27b1cdbc15cf41053531f579f9cf9b5b">More...</a><br /></td></tr>
<tr class="separator:a27b1cdbc15cf41053531f579f9cf9b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d71ba58af8e80441598b2d395745971"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0d71ba58af8e80441598b2d395745971">incrbyfloat</a> (std::string_view key, double increment)</td></tr>
<tr class="memdesc:a0d71ba58af8e80441598b2d395745971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the floating point number stored at key by <code>increment</code>.  <a href="classcoro__redis_1_1coro__connection.html#a0d71ba58af8e80441598b2d395745971">More...</a><br /></td></tr>
<tr class="separator:a0d71ba58af8e80441598b2d395745971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ec7aea535f875885d86b003d341a9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0d0ec7aea535f875885d86b003d341a9"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0d0ec7aea535f875885d86b003d341a9">mget</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a0d0ec7aea535f875885d86b003d341a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of multiple keys atomically.  <a href="classcoro__redis_1_1coro__connection.html#a0d0ec7aea535f875885d86b003d341a9">More...</a><br /></td></tr>
<tr class="separator:a0d0ec7aea535f875885d86b003d341a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5aec165c734686cf7524cc9eb0776"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a97e5aec165c734686cf7524cc9eb0776"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a97e5aec165c734686cf7524cc9eb0776">mset</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a97e5aec165c734686cf7524cc9eb0776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple key-value pairs.  <a href="classcoro__redis_1_1coro__connection.html#a97e5aec165c734686cf7524cc9eb0776">More...</a><br /></td></tr>
<tr class="separator:a97e5aec165c734686cf7524cc9eb0776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427b884ee7815421b41f8b1b53754f15"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a427b884ee7815421b41f8b1b53754f15"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a427b884ee7815421b41f8b1b53754f15">msetnx</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a427b884ee7815421b41f8b1b53754f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given key-value pairs if all specified keys do not exist.  <a href="classcoro__redis_1_1coro__connection.html#a427b884ee7815421b41f8b1b53754f15">More...</a><br /></td></tr>
<tr class="separator:a427b884ee7815421b41f8b1b53754f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bac0ef276fc16f792ddc9cfcf89455"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ad0bac0ef276fc16f792ddc9cfcf89455">psetex</a> (std::string_view key, uint64_t <a class="el" href="classcoro__redis_1_1coro__connection.html#a287efe339b95302b65542e83956c45d0">ttl</a>, std::string_view val)</td></tr>
<tr class="memdesc:ad0bac0ef276fc16f792ddc9cfcf89455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key-value pair with the given timeout in milliseconds.  <a href="classcoro__redis_1_1coro__connection.html#ad0bac0ef276fc16f792ddc9cfcf89455">More...</a><br /></td></tr>
<tr class="separator:ad0bac0ef276fc16f792ddc9cfcf89455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a4c4231a69fd20192ae33a4cdd04a4"><td class="memTemplParams" colspan="2">template&lt;RedisSetValueType T&gt; </td></tr>
<tr class="memitem:ae5a4c4231a69fd20192ae33a4cdd04a4"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ae5a4c4231a69fd20192ae33a4cdd04a4">set</a> (std::string_view key, T val, uint64_t <a class="el" href="classcoro__redis_1_1coro__connection.html#a287efe339b95302b65542e83956c45d0">ttl</a>=0, RedisTTLType ttl_type=RedisTTLType::EX, UpdateType <a class="el" href="classcoro__redis_1_1coro__connection.html#a2f3dfb56bf418bd6e055cbf16cee5416">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:ae5a4c4231a69fd20192ae33a4cdd04a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a key-value pair.  <a href="classcoro__redis_1_1coro__connection.html#ae5a4c4231a69fd20192ae33a4cdd04a4">More...</a><br /></td></tr>
<tr class="separator:ae5a4c4231a69fd20192ae33a4cdd04a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc1cc710b2ca3c1f3e0b8e65bbba9e7"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a5cc1cc710b2ca3c1f3e0b8e65bbba9e7">setex</a> (std::string_view key, uint64_t <a class="el" href="classcoro__redis_1_1coro__connection.html#a287efe339b95302b65542e83956c45d0">ttl</a>, std::string_view val)</td></tr>
<tr class="memdesc:a5cc1cc710b2ca3c1f3e0b8e65bbba9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key-value pair with the given timeout in seconds.  <a href="classcoro__redis_1_1coro__connection.html#a5cc1cc710b2ca3c1f3e0b8e65bbba9e7">More...</a><br /></td></tr>
<tr class="separator:a5cc1cc710b2ca3c1f3e0b8e65bbba9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc3e988786498b8364e4d5be2fc4656"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#abfc3e988786498b8364e4d5be2fc4656">setnx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:abfc3e988786498b8364e4d5be2fc4656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the key if it does not exist.  <a href="classcoro__redis_1_1coro__connection.html#abfc3e988786498b8364e4d5be2fc4656">More...</a><br /></td></tr>
<tr class="separator:abfc3e988786498b8364e4d5be2fc4656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7295cb5ac2c6f00d1dd60936034e4d39"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a7295cb5ac2c6f00d1dd60936034e4d39">setrange</a> (std::string_view key, uint64_t offset, std::string_view val)</td></tr>
<tr class="memdesc:a7295cb5ac2c6f00d1dd60936034e4d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the substring starting from <code>offset</code> to the given value.  <a href="classcoro__redis_1_1coro__connection.html#a7295cb5ac2c6f00d1dd60936034e4d39">More...</a><br /></td></tr>
<tr class="separator:a7295cb5ac2c6f00d1dd60936034e4d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3b13fb28c5d91b84ed6d29774deb86"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a4f3b13fb28c5d91b84ed6d29774deb86">strlen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a4f3b13fb28c5d91b84ed6d29774deb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string stored at key.  <a href="classcoro__redis_1_1coro__connection.html#a4f3b13fb28c5d91b84ed6d29774deb86">More...</a><br /></td></tr>
<tr class="separator:a4f3b13fb28c5d91b84ed6d29774deb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742f90703051d0954b88316e0043c93"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ab742f90703051d0954b88316e0043c93">llen</a> (std::string_view key)</td></tr>
<tr class="memdesc:ab742f90703051d0954b88316e0043c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the list.  <a href="classcoro__redis_1_1coro__connection.html#ab742f90703051d0954b88316e0043c93">More...</a><br /></td></tr>
<tr class="separator:ab742f90703051d0954b88316e0043c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc61da81a9cc5dc1c7853aedec49362"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a7fc61da81a9cc5dc1c7853aedec49362">lpop</a> (std::string_view key)</td></tr>
<tr class="memdesc:a7fc61da81a9cc5dc1c7853aedec49362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the first element of the list.  <a href="classcoro__redis_1_1coro__connection.html#a7fc61da81a9cc5dc1c7853aedec49362">More...</a><br /></td></tr>
<tr class="separator:a7fc61da81a9cc5dc1c7853aedec49362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9287b68ef1fe59aa908bd18a22ae41"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a3a9287b68ef1fe59aa908bd18a22ae41">lpush</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a3a9287b68ef1fe59aa908bd18a22ae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the beginning of the list.  <a href="classcoro__redis_1_1coro__connection.html#a3a9287b68ef1fe59aa908bd18a22ae41">More...</a><br /></td></tr>
<tr class="separator:a3a9287b68ef1fe59aa908bd18a22ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8df4028862f17c19ed31c91121aa9b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aed8df4028862f17c19ed31c91121aa9b"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aed8df4028862f17c19ed31c91121aa9b">lpush</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aed8df4028862f17c19ed31c91121aa9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push multiple elements to the beginning of the list.  <a href="classcoro__redis_1_1coro__connection.html#aed8df4028862f17c19ed31c91121aa9b">More...</a><br /></td></tr>
<tr class="separator:aed8df4028862f17c19ed31c91121aa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89353d4c3f5123d6f5aa442aaf78b64e"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a89353d4c3f5123d6f5aa442aaf78b64e">lpushx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a89353d4c3f5123d6f5aa442aaf78b64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the beginning of the list, only if the list already exists.  <a href="classcoro__redis_1_1coro__connection.html#a89353d4c3f5123d6f5aa442aaf78b64e">More...</a><br /></td></tr>
<tr class="separator:a89353d4c3f5123d6f5aa442aaf78b64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7bb9a8df30f22d6a9f8c77ddb99a7"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a7cb7bb9a8df30f22d6a9f8c77ddb99a7">lrange</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:a7cb7bb9a8df30f22d6a9f8c77ddb99a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get elements in the given range of the given list.  <a href="classcoro__redis_1_1coro__connection.html#a7cb7bb9a8df30f22d6a9f8c77ddb99a7">More...</a><br /></td></tr>
<tr class="separator:a7cb7bb9a8df30f22d6a9f8c77ddb99a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d13b0fdf30c856f59a9c1d6dc63499"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ac3d13b0fdf30c856f59a9c1d6dc63499">lrem</a> (std::string_view key, uint64_t count, std::string_view val)</td></tr>
<tr class="memdesc:ac3d13b0fdf30c856f59a9c1d6dc63499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first <code>count</code> occurrences of elements equal to <code>val</code>.  <a href="classcoro__redis_1_1coro__connection.html#ac3d13b0fdf30c856f59a9c1d6dc63499">More...</a><br /></td></tr>
<tr class="separator:ac3d13b0fdf30c856f59a9c1d6dc63499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fffeb2ba22dc630915e66a6a07418cc"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6fffeb2ba22dc630915e66a6a07418cc">lset</a> (std::string_view key, uint64_t index, std::string_view val)</td></tr>
<tr class="memdesc:a6fffeb2ba22dc630915e66a6a07418cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element at the given index to the specified value.  <a href="classcoro__redis_1_1coro__connection.html#a6fffeb2ba22dc630915e66a6a07418cc">More...</a><br /></td></tr>
<tr class="separator:a6fffeb2ba22dc630915e66a6a07418cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a086e48f2d733766def9bf70e49af9"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#af7a086e48f2d733766def9bf70e49af9">ltrim</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:af7a086e48f2d733766def9bf70e49af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a list to keep only element in the given range.  <a href="classcoro__redis_1_1coro__connection.html#af7a086e48f2d733766def9bf70e49af9">More...</a><br /></td></tr>
<tr class="separator:af7a086e48f2d733766def9bf70e49af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a0a31265972be2c674f0e1ce750b43"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ac2a0a31265972be2c674f0e1ce750b43">rpop</a> (std::string_view key)</td></tr>
<tr class="memdesc:ac2a0a31265972be2c674f0e1ce750b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the last element of a list.  <a href="classcoro__redis_1_1coro__connection.html#ac2a0a31265972be2c674f0e1ce750b43">More...</a><br /></td></tr>
<tr class="separator:ac2a0a31265972be2c674f0e1ce750b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41f5045c1687e3e57afb7953b22d346"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ac41f5045c1687e3e57afb7953b22d346">rpoplpush</a> (std::string_view source, std::string_view destination)</td></tr>
<tr class="memdesc:ac41f5045c1687e3e57afb7953b22d346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop last element of one list and push it to the left of another list.  <a href="classcoro__redis_1_1coro__connection.html#ac41f5045c1687e3e57afb7953b22d346">More...</a><br /></td></tr>
<tr class="separator:ac41f5045c1687e3e57afb7953b22d346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ff468dae74ff85572eab87e017eaff"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a08ff468dae74ff85572eab87e017eaff"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a08ff468dae74ff85572eab87e017eaff">rpush</a> (std::string_view key, std::string_view val, Args &amp;&amp;... vals)</td></tr>
<tr class="memdesc:a08ff468dae74ff85572eab87e017eaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the end of the list.  <a href="classcoro__redis_1_1coro__connection.html#a08ff468dae74ff85572eab87e017eaff">More...</a><br /></td></tr>
<tr class="separator:a08ff468dae74ff85572eab87e017eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5cd20ac7e6a2fab7c173f2517538d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a1fe5cd20ac7e6a2fab7c173f2517538d">rpushx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a1fe5cd20ac7e6a2fab7c173f2517538d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the end of the list, only if the list already exists.  <a href="classcoro__redis_1_1coro__connection.html#a1fe5cd20ac7e6a2fab7c173f2517538d">More...</a><br /></td></tr>
<tr class="separator:a1fe5cd20ac7e6a2fab7c173f2517538d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b703acf9cea1a01912e6a31c0a807bd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2b703acf9cea1a01912e6a31c0a807bd"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a2b703acf9cea1a01912e6a31c0a807bd">hdel</a> (std::string_view key, std::string_view field, Args &amp;&amp;... fields)</td></tr>
<tr class="memdesc:a2b703acf9cea1a01912e6a31c0a807bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given field from hash.  <a href="classcoro__redis_1_1coro__connection.html#a2b703acf9cea1a01912e6a31c0a807bd">More...</a><br /></td></tr>
<tr class="separator:a2b703acf9cea1a01912e6a31c0a807bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6827868671776db3b13482b14c9344"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6f6827868671776db3b13482b14c9344">hexists</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:a6f6827868671776db3b13482b14c9344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given field exists in hash.  <a href="classcoro__redis_1_1coro__connection.html#a6f6827868671776db3b13482b14c9344">More...</a><br /></td></tr>
<tr class="separator:a6f6827868671776db3b13482b14c9344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742fa7649368e0063f953b6fb91ba880"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a742fa7649368e0063f953b6fb91ba880">hget</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:a742fa7649368e0063f953b6fb91ba880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the given field.  <a href="classcoro__redis_1_1coro__connection.html#a742fa7649368e0063f953b6fb91ba880">More...</a><br /></td></tr>
<tr class="separator:a742fa7649368e0063f953b6fb91ba880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb0d31376567ba55212654292404d4"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a07eb0d31376567ba55212654292404d4">hgetall</a> (std::string_view key)</td></tr>
<tr class="memdesc:a07eb0d31376567ba55212654292404d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all field-value pairs of the given hash.  <a href="classcoro__redis_1_1coro__connection.html#a07eb0d31376567ba55212654292404d4">More...</a><br /></td></tr>
<tr class="separator:a07eb0d31376567ba55212654292404d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ab5386c279fe04eefd10c6e5d50d79"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a59ab5386c279fe04eefd10c6e5d50d79">hincrby</a> (std::string_view key, std::string_view field, uint64_t increment)</td></tr>
<tr class="memdesc:a59ab5386c279fe04eefd10c6e5d50d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at the given field.  <a href="classcoro__redis_1_1coro__connection.html#a59ab5386c279fe04eefd10c6e5d50d79">More...</a><br /></td></tr>
<tr class="separator:a59ab5386c279fe04eefd10c6e5d50d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2e618e7957a89cdf6e2b3a0abf2b7d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a7f2e618e7957a89cdf6e2b3a0abf2b7d">hincrbyfloat</a> (std::string_view key, std::string_view field, double increment)</td></tr>
<tr class="memdesc:a7f2e618e7957a89cdf6e2b3a0abf2b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the floating point number stored at the given field.  <a href="classcoro__redis_1_1coro__connection.html#a7f2e618e7957a89cdf6e2b3a0abf2b7d">More...</a><br /></td></tr>
<tr class="separator:a7f2e618e7957a89cdf6e2b3a0abf2b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1d670b54c8fd12cff0f3a47ca2316c"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aab1d670b54c8fd12cff0f3a47ca2316c">hkeys</a> (std::string_view key)</td></tr>
<tr class="memdesc:aab1d670b54c8fd12cff0f3a47ca2316c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all fields of the given hash.  <a href="classcoro__redis_1_1coro__connection.html#aab1d670b54c8fd12cff0f3a47ca2316c">More...</a><br /></td></tr>
<tr class="separator:aab1d670b54c8fd12cff0f3a47ca2316c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04719ad766e80466e0775032f47ff8ce"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a04719ad766e80466e0775032f47ff8ce">hlen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a04719ad766e80466e0775032f47ff8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of fields of the given hash.  <a href="classcoro__redis_1_1coro__connection.html#a04719ad766e80466e0775032f47ff8ce">More...</a><br /></td></tr>
<tr class="separator:a04719ad766e80466e0775032f47ff8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471eda079fef74f3236ba444abfadf77"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a471eda079fef74f3236ba444abfadf77"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a471eda079fef74f3236ba444abfadf77">hmget</a> (std::string_view key, std::string_view field, Args &amp;&amp;... fields)</td></tr>
<tr class="memdesc:a471eda079fef74f3236ba444abfadf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of multiple fields.  <a href="classcoro__redis_1_1coro__connection.html#a471eda079fef74f3236ba444abfadf77">More...</a><br /></td></tr>
<tr class="separator:a471eda079fef74f3236ba444abfadf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6906639f6c02e318dcf29f9607129202"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6906639f6c02e318dcf29f9607129202"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6906639f6c02e318dcf29f9607129202">hmset</a> (std::string_view key, std::string_view field, std::string_view value, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6906639f6c02e318dcf29f9607129202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple field-value pairs of the given hash.  <a href="classcoro__redis_1_1coro__connection.html#a6906639f6c02e318dcf29f9607129202">More...</a><br /></td></tr>
<tr class="separator:a6906639f6c02e318dcf29f9607129202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064625c667e4372b017988667a7caed0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a064625c667e4372b017988667a7caed0">hscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:a064625c667e4372b017988667a7caed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan fields of the given hash matching the given pattern.  <a href="classcoro__redis_1_1coro__connection.html#a064625c667e4372b017988667a7caed0">More...</a><br /></td></tr>
<tr class="separator:a064625c667e4372b017988667a7caed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1989ec0704d4fdb8234726c101f18ff0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a1989ec0704d4fdb8234726c101f18ff0">hscan</a> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="memdesc:a1989ec0704d4fdb8234726c101f18ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan fields of the given hash matching the given pattern.  <a href="classcoro__redis_1_1coro__connection.html#a1989ec0704d4fdb8234726c101f18ff0">More...</a><br /></td></tr>
<tr class="separator:a1989ec0704d4fdb8234726c101f18ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989bafcf8271789bbf1a056a9011e464"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a989bafcf8271789bbf1a056a9011e464"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a989bafcf8271789bbf1a056a9011e464">hset</a> (std::string_view key, std::string_view field, std::string_view val, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a989bafcf8271789bbf1a056a9011e464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hash field to value.  <a href="classcoro__redis_1_1coro__connection.html#a989bafcf8271789bbf1a056a9011e464">More...</a><br /></td></tr>
<tr class="separator:a989bafcf8271789bbf1a056a9011e464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff6aa223e62a6dc9186cf048d3cbfa0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#afff6aa223e62a6dc9186cf048d3cbfa0">hset</a> (std::string_view key, const std::vector&lt; std::pair&lt; std::string_view, std::string_view &gt;&gt; &amp;kvs)</td></tr>
<tr class="memdesc:afff6aa223e62a6dc9186cf048d3cbfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple fields of the given hash.  <a href="classcoro__redis_1_1coro__connection.html#afff6aa223e62a6dc9186cf048d3cbfa0">More...</a><br /></td></tr>
<tr class="separator:afff6aa223e62a6dc9186cf048d3cbfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dc62363ad780daad092dfc1a0f23ad"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a77dc62363ad780daad092dfc1a0f23ad">hsetnx</a> (std::string_view key, std::string_view field, std::string_view val)</td></tr>
<tr class="memdesc:a77dc62363ad780daad092dfc1a0f23ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hash field to value, only if the given field does not exist.  <a href="classcoro__redis_1_1coro__connection.html#a77dc62363ad780daad092dfc1a0f23ad">More...</a><br /></td></tr>
<tr class="separator:a77dc62363ad780daad092dfc1a0f23ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390a5b8d20bda94415be2938316240e0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a390a5b8d20bda94415be2938316240e0">hstrlen</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:a390a5b8d20bda94415be2938316240e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string stored at the given field.  <a href="classcoro__redis_1_1coro__connection.html#a390a5b8d20bda94415be2938316240e0">More...</a><br /></td></tr>
<tr class="separator:a390a5b8d20bda94415be2938316240e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320bd653ca450cb00282c85861fda4a7"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a320bd653ca450cb00282c85861fda4a7">hvals</a> (std::string_view key)</td></tr>
<tr class="memdesc:a320bd653ca450cb00282c85861fda4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of all fields stored at the given hash.  <a href="classcoro__redis_1_1coro__connection.html#a320bd653ca450cb00282c85861fda4a7">More...</a><br /></td></tr>
<tr class="separator:a320bd653ca450cb00282c85861fda4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd9af12aab3804e1fea0c6e2e2ee6b1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:accd9af12aab3804e1fea0c6e2e2ee6b1"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#accd9af12aab3804e1fea0c6e2e2ee6b1">sadd</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:accd9af12aab3804e1fea0c6e2e2ee6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a member to the given set.  <a href="classcoro__redis_1_1coro__connection.html#accd9af12aab3804e1fea0c6e2e2ee6b1">More...</a><br /></td></tr>
<tr class="separator:accd9af12aab3804e1fea0c6e2e2ee6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd46666b92e108a34221f390c989587"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aefd46666b92e108a34221f390c989587">scard</a> (std::string_view key)</td></tr>
<tr class="memdesc:aefd46666b92e108a34221f390c989587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members in the set.  <a href="classcoro__redis_1_1coro__connection.html#aefd46666b92e108a34221f390c989587">More...</a><br /></td></tr>
<tr class="separator:aefd46666b92e108a34221f390c989587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d2aaf9d4467222e544d9002516a9b0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a41d2aaf9d4467222e544d9002516a9b0"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a41d2aaf9d4467222e544d9002516a9b0">sdiff</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a41d2aaf9d4467222e544d9002516a9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the difference between the first set and all successive sets.  <a href="classcoro__redis_1_1coro__connection.html#a41d2aaf9d4467222e544d9002516a9b0">More...</a><br /></td></tr>
<tr class="separator:a41d2aaf9d4467222e544d9002516a9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00126981851b1c554fe61d00d613b31e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a00126981851b1c554fe61d00d613b31e"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a00126981851b1c554fe61d00d613b31e">sdiffstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a00126981851b1c554fe61d00d613b31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1coro__connection.html#a00126981851b1c554fe61d00d613b31e">More...</a><br /></td></tr>
<tr class="separator:a00126981851b1c554fe61d00d613b31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f402a3254566b0a1409e905aadd3bb"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a13f402a3254566b0a1409e905aadd3bb"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a13f402a3254566b0a1409e905aadd3bb">sinter</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a13f402a3254566b0a1409e905aadd3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection between the first set and all successive sets.  <a href="classcoro__redis_1_1coro__connection.html#a13f402a3254566b0a1409e905aadd3bb">More...</a><br /></td></tr>
<tr class="separator:a13f402a3254566b0a1409e905aadd3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d444da5f8675cb88d2cdb17c6cb2ac2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7d444da5f8675cb88d2cdb17c6cb2ac2"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a7d444da5f8675cb88d2cdb17c6cb2ac2">sinterstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a7d444da5f8675cb88d2cdb17c6cb2ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1coro__connection.html#a7d444da5f8675cb88d2cdb17c6cb2ac2">More...</a><br /></td></tr>
<tr class="separator:a7d444da5f8675cb88d2cdb17c6cb2ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c32ad6ffad5ad1ca7fb60d6cedf1fe7"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a8c32ad6ffad5ad1ca7fb60d6cedf1fe7">sismember</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a8c32ad6ffad5ad1ca7fb60d6cedf1fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <code>member</code> exists in the set stored at key.  <a href="classcoro__redis_1_1coro__connection.html#a8c32ad6ffad5ad1ca7fb60d6cedf1fe7">More...</a><br /></td></tr>
<tr class="separator:a8c32ad6ffad5ad1ca7fb60d6cedf1fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460d52e7508312d6cb66492a16572499"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a460d52e7508312d6cb66492a16572499">smembers</a> (std::string_view key)</td></tr>
<tr class="memdesc:a460d52e7508312d6cb66492a16572499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all members in the given set.  <a href="classcoro__redis_1_1coro__connection.html#a460d52e7508312d6cb66492a16572499">More...</a><br /></td></tr>
<tr class="separator:a460d52e7508312d6cb66492a16572499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1db5dc5bf80ac96a65f49203f62fef"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aaf1db5dc5bf80ac96a65f49203f62fef">smove</a> (std::string_view source, std::string_view destination, std::string_view member)</td></tr>
<tr class="memdesc:aaf1db5dc5bf80ac96a65f49203f62fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move <code>member</code> from one set to another.  <a href="classcoro__redis_1_1coro__connection.html#aaf1db5dc5bf80ac96a65f49203f62fef">More...</a><br /></td></tr>
<tr class="separator:aaf1db5dc5bf80ac96a65f49203f62fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2217d63ae2dddfcb3ee1c98104ca44a"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ae2217d63ae2dddfcb3ee1c98104ca44a">spop</a> (std::string_view key, uint64_t count=1)</td></tr>
<tr class="memdesc:ae2217d63ae2dddfcb3ee1c98104ca44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a random member from the set.  <a href="classcoro__redis_1_1coro__connection.html#ae2217d63ae2dddfcb3ee1c98104ca44a">More...</a><br /></td></tr>
<tr class="separator:ae2217d63ae2dddfcb3ee1c98104ca44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cebf8814bed3196f65d3ee5d95602a6"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a4cebf8814bed3196f65d3ee5d95602a6">srandmember</a> (std::string_view key)</td></tr>
<tr class="memdesc:a4cebf8814bed3196f65d3ee5d95602a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random member of the given set.  <a href="classcoro__redis_1_1coro__connection.html#a4cebf8814bed3196f65d3ee5d95602a6">More...</a><br /></td></tr>
<tr class="separator:a4cebf8814bed3196f65d3ee5d95602a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d024e1084ce9a8d02a44b894c64b464"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a3d024e1084ce9a8d02a44b894c64b464">srandmember</a> (std::string_view key, uint64_t count)</td></tr>
<tr class="memdesc:a3d024e1084ce9a8d02a44b894c64b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple random members of the given set.  <a href="classcoro__redis_1_1coro__connection.html#a3d024e1084ce9a8d02a44b894c64b464">More...</a><br /></td></tr>
<tr class="separator:a3d024e1084ce9a8d02a44b894c64b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12063063fdbf86df0768cd60803fabf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac12063063fdbf86df0768cd60803fabf"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ac12063063fdbf86df0768cd60803fabf">srem</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:ac12063063fdbf86df0768cd60803fabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a member from set.  <a href="classcoro__redis_1_1coro__connection.html#ac12063063fdbf86df0768cd60803fabf">More...</a><br /></td></tr>
<tr class="separator:ac12063063fdbf86df0768cd60803fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ce030ee7ea6675f64c6b808f54ff1d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a80ce030ee7ea6675f64c6b808f54ff1d">sscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:a80ce030ee7ea6675f64c6b808f54ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan members of the set matching the given pattern.  <a href="classcoro__redis_1_1coro__connection.html#a80ce030ee7ea6675f64c6b808f54ff1d">More...</a><br /></td></tr>
<tr class="separator:a80ce030ee7ea6675f64c6b808f54ff1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27e59554e8c716946abcd6cf3b9e25"><td class="memItemLeft" align="right" valign="top"><a id="aaa27e59554e8c716946abcd6cf3b9e25"></a>
awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sscan</b> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="separator:aaa27e59554e8c716946abcd6cf3b9e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd4e3a5907cd681a0db72688d585319"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:affd4e3a5907cd681a0db72688d585319"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#affd4e3a5907cd681a0db72688d585319">sunion</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:affd4e3a5907cd681a0db72688d585319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the union between the first set and all successive sets.  <a href="classcoro__redis_1_1coro__connection.html#affd4e3a5907cd681a0db72688d585319">More...</a><br /></td></tr>
<tr class="separator:affd4e3a5907cd681a0db72688d585319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c30efc9e5cab586a6969bb32e56c5a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a98c30efc9e5cab586a6969bb32e56c5a"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a98c30efc9e5cab586a6969bb32e56c5a">sunionstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a98c30efc9e5cab586a6969bb32e56c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1coro__connection.html#a98c30efc9e5cab586a6969bb32e56c5a">More...</a><br /></td></tr>
<tr class="separator:a98c30efc9e5cab586a6969bb32e56c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8bab1729ffbb339353b6360aa4a844"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0d8bab1729ffbb339353b6360aa4a844">bzpopmax</a> (std::initializer_list&lt; std::string_view &gt; keys, uint64_t timeout=0)</td></tr>
<tr class="memdesc:a0d8bab1729ffbb339353b6360aa4a844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with highest score from sorted set in a blocking way.  <a href="classcoro__redis_1_1coro__connection.html#a0d8bab1729ffbb339353b6360aa4a844">More...</a><br /></td></tr>
<tr class="separator:a0d8bab1729ffbb339353b6360aa4a844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5f5b746e41921bd7602f6bfac8927a"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aae5f5b746e41921bd7602f6bfac8927a">bzpopmin</a> (std::initializer_list&lt; std::string_view &gt; keys, uint64_t timeout=0)</td></tr>
<tr class="memdesc:aae5f5b746e41921bd7602f6bfac8927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with lowest score from sorted set in a blocking way.  <a href="classcoro__redis_1_1coro__connection.html#aae5f5b746e41921bd7602f6bfac8927a">More...</a><br /></td></tr>
<tr class="separator:aae5f5b746e41921bd7602f6bfac8927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8330b95d71d9847abdf9f354486bef5"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#af8330b95d71d9847abdf9f354486bef5">zadd</a> (std::string_view key, std::string_view member, double score, UpdateType <a class="el" href="classcoro__redis_1_1coro__connection.html#a2f3dfb56bf418bd6e055cbf16cee5416">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:af8330b95d71d9847abdf9f354486bef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update a member with score to sorted set.  <a href="classcoro__redis_1_1coro__connection.html#af8330b95d71d9847abdf9f354486bef5">More...</a><br /></td></tr>
<tr class="separator:af8330b95d71d9847abdf9f354486bef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920e30fa684392352781dec8761258a"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ac920e30fa684392352781dec8761258a">zadd</a> (std::string_view key, std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt; kvs, UpdateType <a class="el" href="classcoro__redis_1_1coro__connection.html#a2f3dfb56bf418bd6e055cbf16cee5416">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:ac920e30fa684392352781dec8761258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update multiple members with score to sorted set.  <a href="classcoro__redis_1_1coro__connection.html#ac920e30fa684392352781dec8761258a">More...</a><br /></td></tr>
<tr class="separator:ac920e30fa684392352781dec8761258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5e97f3370f89bc7a3ef413c1607bdb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a5e97f3370f89bc7a3ef413c1607bdb"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6a5e97f3370f89bc7a3ef413c1607bdb">zadd</a> (std::string_view key, std::initializer_list&lt; T &gt; il, UpdateType <a class="el" href="classcoro__redis_1_1coro__connection.html#a2f3dfb56bf418bd6e055cbf16cee5416">type</a>=UpdateType::ALWAYS, bool changed=false)</td></tr>
<tr class="memdesc:a6a5e97f3370f89bc7a3ef413c1607bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update multiple members with score to sorted set.  <a href="classcoro__redis_1_1coro__connection.html#a6a5e97f3370f89bc7a3ef413c1607bdb">More...</a><br /></td></tr>
<tr class="separator:a6a5e97f3370f89bc7a3ef413c1607bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba94cb28f6dedce8a4234ecbd3cc3551"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aba94cb28f6dedce8a4234ecbd3cc3551">zcard</a> (std::string_view key)</td></tr>
<tr class="memdesc:aba94cb28f6dedce8a4234ecbd3cc3551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members in the sorted set.  <a href="classcoro__redis_1_1coro__connection.html#aba94cb28f6dedce8a4234ecbd3cc3551">More...</a><br /></td></tr>
<tr class="separator:aba94cb28f6dedce8a4234ecbd3cc3551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2936db94d0a51bfdcb19f7b4241ebe72"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a2936db94d0a51bfdcb19f7b4241ebe72">zcount</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a2936db94d0a51bfdcb19f7b4241ebe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members with score between a min-max score range.  <a href="classcoro__redis_1_1coro__connection.html#a2936db94d0a51bfdcb19f7b4241ebe72">More...</a><br /></td></tr>
<tr class="separator:a2936db94d0a51bfdcb19f7b4241ebe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3b3cac2eb8051bad4ba80cc7aa5b45"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a9e3b3cac2eb8051bad4ba80cc7aa5b45">zincrby</a> (std::string_view key, double increment, std::string_view member)</td></tr>
<tr class="memdesc:a9e3b3cac2eb8051bad4ba80cc7aa5b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the score of given member.  <a href="classcoro__redis_1_1coro__connection.html#a9e3b3cac2eb8051bad4ba80cc7aa5b45">More...</a><br /></td></tr>
<tr class="separator:a9e3b3cac2eb8051bad4ba80cc7aa5b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0548a9b98553ec2745a3ed71aaaed8c1"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0548a9b98553ec2745a3ed71aaaed8c1">zlexcount</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a0548a9b98553ec2745a3ed71aaaed8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members between a min-max range in lexicographical order.  <a href="classcoro__redis_1_1coro__connection.html#a0548a9b98553ec2745a3ed71aaaed8c1">More...</a><br /></td></tr>
<tr class="separator:a0548a9b98553ec2745a3ed71aaaed8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8905a8c6af2fc96cd719735d1029c72"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aa8905a8c6af2fc96cd719735d1029c72">zpopmax</a> (std::string_view key, uint64_t count=1)</td></tr>
<tr class="memdesc:aa8905a8c6af2fc96cd719735d1029c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with highest score from sorted set.  <a href="classcoro__redis_1_1coro__connection.html#aa8905a8c6af2fc96cd719735d1029c72">More...</a><br /></td></tr>
<tr class="separator:aa8905a8c6af2fc96cd719735d1029c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a294b7cb8bb15272e9c8131c8545eb"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a26a294b7cb8bb15272e9c8131c8545eb">zpopmin</a> (std::string_view key)</td></tr>
<tr class="memdesc:a26a294b7cb8bb15272e9c8131c8545eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with lowest score from sorted set.  <a href="classcoro__redis_1_1coro__connection.html#a26a294b7cb8bb15272e9c8131c8545eb">More...</a><br /></td></tr>
<tr class="separator:a26a294b7cb8bb15272e9c8131c8545eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac5ebaa17a4cb2f3f2b51c01042cd34"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a7ac5ebaa17a4cb2f3f2b51c01042cd34">zrange</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a7ac5ebaa17a4cb2f3f2b51c01042cd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by rank (ordered from lowest to highest).  <a href="classcoro__redis_1_1coro__connection.html#a7ac5ebaa17a4cb2f3f2b51c01042cd34">More...</a><br /></td></tr>
<tr class="separator:a7ac5ebaa17a4cb2f3f2b51c01042cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d2e5be0963a7bc4675a16165509f35"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a73d2e5be0963a7bc4675a16165509f35">zrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a73d2e5be0963a7bc4675a16165509f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by lexicographical order (from lowest to highest).  <a href="classcoro__redis_1_1coro__connection.html#a73d2e5be0963a7bc4675a16165509f35">More...</a><br /></td></tr>
<tr class="separator:a73d2e5be0963a7bc4675a16165509f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7076e89beafcc5712dec6b9e6e9aa6f"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#af7076e89beafcc5712dec6b9e6e9aa6f">zrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:af7076e89beafcc5712dec6b9e6e9aa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by score (ordered from lowest to highest).  <a href="classcoro__redis_1_1coro__connection.html#af7076e89beafcc5712dec6b9e6e9aa6f">More...</a><br /></td></tr>
<tr class="separator:af7076e89beafcc5712dec6b9e6e9aa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38c270b3de713a99dc111b0631e385d"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#af38c270b3de713a99dc111b0631e385d">zrank</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:af38c270b3de713a99dc111b0631e385d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank (from low to high) of the given member in the sorted set.  <a href="classcoro__redis_1_1coro__connection.html#af38c270b3de713a99dc111b0631e385d">More...</a><br /></td></tr>
<tr class="separator:af38c270b3de713a99dc111b0631e385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8ba95df5108160f727084448919a1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a1da8ba95df5108160f727084448919a1"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a1da8ba95df5108160f727084448919a1">zrem</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:a1da8ba95df5108160f727084448919a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given member from sorted set.  <a href="classcoro__redis_1_1coro__connection.html#a1da8ba95df5108160f727084448919a1">More...</a><br /></td></tr>
<tr class="separator:a1da8ba95df5108160f727084448919a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c57c4791576c1143564075af693624"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a73c57c4791576c1143564075af693624">zremrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a73c57c4791576c1143564075af693624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range of lexicographical order.  <a href="classcoro__redis_1_1coro__connection.html#a73c57c4791576c1143564075af693624">More...</a><br /></td></tr>
<tr class="separator:a73c57c4791576c1143564075af693624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffc1ccce94cd76af298b484fb54566e"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6ffc1ccce94cd76af298b484fb54566e">zremrangebyrank</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:a6ffc1ccce94cd76af298b484fb54566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range ordered by rank.  <a href="classcoro__redis_1_1coro__connection.html#a6ffc1ccce94cd76af298b484fb54566e">More...</a><br /></td></tr>
<tr class="separator:a6ffc1ccce94cd76af298b484fb54566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba0e38ee1b77b1a91ada8ff9ecb407"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a24ba0e38ee1b77b1a91ada8ff9ecb407">zremrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a24ba0e38ee1b77b1a91ada8ff9ecb407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range ordered by score.  <a href="classcoro__redis_1_1coro__connection.html#a24ba0e38ee1b77b1a91ada8ff9ecb407">More...</a><br /></td></tr>
<tr class="separator:a24ba0e38ee1b77b1a91ada8ff9ecb407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa650bae9e9e6e5c14bcef71187391703"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#aa650bae9e9e6e5c14bcef71187391703">zrevrange</a> (std::string_view key, uint64_t start, uint64_t stop, bool withscores=false)</td></tr>
<tr class="memdesc:aa650bae9e9e6e5c14bcef71187391703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by rank (ordered from highest to lowest).  <a href="classcoro__redis_1_1coro__connection.html#aa650bae9e9e6e5c14bcef71187391703">More...</a><br /></td></tr>
<tr class="separator:aa650bae9e9e6e5c14bcef71187391703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec71d7f8217c987a74ad81bcd6eeb02"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#adec71d7f8217c987a74ad81bcd6eeb02">zrevrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:adec71d7f8217c987a74ad81bcd6eeb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by lexicographical order (from highest to lowest).  <a href="classcoro__redis_1_1coro__connection.html#adec71d7f8217c987a74ad81bcd6eeb02">More...</a><br /></td></tr>
<tr class="separator:adec71d7f8217c987a74ad81bcd6eeb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8b9d13aa5b759b17a7e46df62ed5c9"><td class="memTemplParams" colspan="2">template&lt;typename Interval , typename Output &gt; </td></tr>
<tr class="memitem:a0c8b9d13aa5b759b17a7e46df62ed5c9"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a0c8b9d13aa5b759b17a7e46df62ed5c9">zrevrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a0c8b9d13aa5b759b17a7e46df62ed5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by score (ordered from highest to lowest).  <a href="classcoro__redis_1_1coro__connection.html#a0c8b9d13aa5b759b17a7e46df62ed5c9">More...</a><br /></td></tr>
<tr class="separator:a0c8b9d13aa5b759b17a7e46df62ed5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a5b8df67eddf6d3ec528ae23d5ddcd"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ab6a5b8df67eddf6d3ec528ae23d5ddcd">zrevrank</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:ab6a5b8df67eddf6d3ec528ae23d5ddcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank (from high to low) of the given member in the sorted set.  <a href="classcoro__redis_1_1coro__connection.html#ab6a5b8df67eddf6d3ec528ae23d5ddcd">More...</a><br /></td></tr>
<tr class="separator:ab6a5b8df67eddf6d3ec528ae23d5ddcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4e4b19aa5b53ffd29316a897536ef9"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#acc4e4b19aa5b53ffd29316a897536ef9">zscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:acc4e4b19aa5b53ffd29316a897536ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all members of the given sorted set.  <a href="classcoro__redis_1_1coro__connection.html#acc4e4b19aa5b53ffd29316a897536ef9">More...</a><br /></td></tr>
<tr class="separator:acc4e4b19aa5b53ffd29316a897536ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae696ee1711f3588320f05ab470f9da15"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ae696ee1711f3588320f05ab470f9da15">zscan</a> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count)</td></tr>
<tr class="memdesc:ae696ee1711f3588320f05ab470f9da15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all members of the given sorted set.  <a href="classcoro__redis_1_1coro__connection.html#ae696ee1711f3588320f05ab470f9da15">More...</a><br /></td></tr>
<tr class="separator:ae696ee1711f3588320f05ab470f9da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75d4fd3672e7a5b8cecbe13459c52f7"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#ad75d4fd3672e7a5b8cecbe13459c52f7">zscore</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:ad75d4fd3672e7a5b8cecbe13459c52f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score of the given member.  <a href="classcoro__redis_1_1coro__connection.html#ad75d4fd3672e7a5b8cecbe13459c52f7">More...</a><br /></td></tr>
<tr class="separator:ad75d4fd3672e7a5b8cecbe13459c52f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcf904bf29cfe29cf71535d869f5211"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a4fcf904bf29cfe29cf71535d869f5211">zunionstore</a> (std::string_view destination, std::initializer_list&lt; std::string_view &gt; keys, std::string_view aggregate=&quot;SUM&quot;)</td></tr>
<tr class="memdesc:a4fcf904bf29cfe29cf71535d869f5211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sorted set to another one with the scores being multiplied by a factor.  <a href="classcoro__redis_1_1coro__connection.html#a4fcf904bf29cfe29cf71535d869f5211">More...</a><br /></td></tr>
<tr class="separator:a4fcf904bf29cfe29cf71535d869f5211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ed0b810a6ddd6b144c9627c12eaba0"><td class="memItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a13ed0b810a6ddd6b144c9627c12eaba0">zunionstore</a> (std::string_view destination, std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt; kvs, std::string_view aggregate=&quot;SUM&quot;)</td></tr>
<tr class="memdesc:a13ed0b810a6ddd6b144c9627c12eaba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get union of multiple sorted sets, and store the result to another one.  <a href="classcoro__redis_1_1coro__connection.html#a13ed0b810a6ddd6b144c9627c12eaba0">More...</a><br /></td></tr>
<tr class="separator:a13ed0b810a6ddd6b144c9627c12eaba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d35764c7d3c77ae1ab951f8192c49e4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6d35764c7d3c77ae1ab951f8192c49e4"><td class="memTemplItemLeft" align="right" valign="top">awaiter_t&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1coro__connection.html#a6d35764c7d3c77ae1ab951f8192c49e4">pfadd</a> (std::string_view key, Args &amp;&amp;... elements)</td></tr>
<tr class="memdesc:a6d35764c7d3c77ae1ab951f8192c49e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given element to a hyperloglog.  <a href="classcoro__redis_1_1coro__connection.html#a6d35764c7d3c77ae1ab951f8192c49e4">More...</a><br /></td></tr>
<tr class="separator:a6d35764c7d3c77ae1ab951f8192c49e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>connection of corotine </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff7959518f7bef86a56ed4b61419b960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7959518f7bef86a56ed4b61419b960">&#9670;&nbsp;</a></span>coro_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">coro_redis::coro_connection::coro_connection </td>
          <td>(</td>
          <td class="paramtype">redisAsyncContext *&#160;</td>
          <td class="paramname"><em>actx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actx</td><td>Redis asynchronous context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a453f55ff8b067180e758c33a722f8f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453f55ff8b067180e758c33a722f8f95">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::append </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the given string to the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">str</td><td>String to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string after the append operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/append">https://redis.io/commands/append</a> </dd></dl>

</div>
</div>
<a id="a06d200321ba33a1cacff857cf4de69e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d200321ba33a1cacff857cf4de69e2">&#9670;&nbsp;</a></span>auth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::auth </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send password to Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Normally, you should not call this method. Instead, you should set password with <code>ConnectionOptions</code> or URI. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/auth">https://redis.io/commands/auth</a> </dd></dl>

</div>
</div>
<a id="a133f8c741a8ba3b3b9d378676aa06226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133f8c741a8ba3b3b9d378676aa06226">&#9670;&nbsp;</a></span>auth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::auth </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send user and password to Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>User name. </td></tr>
    <tr><td class="paramname">password</td><td>Password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Normally, you should not call this method. Instead, you should set password with <code>ConnectionOptions</code> or URI. Also this overload only works with Redis 6.0 or later. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/auth">https://redis.io/commands/auth</a> </dd></dl>

</div>
</div>
<a id="aaea1a1692348c8a671ac9b3e0c5efddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea1a1692348c8a671ac9b3e0c5efddd">&#9670;&nbsp;</a></span>bgrewriteaof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::bgrewriteaof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite AOF in the background. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bgrewriteaof">https://redis.io/commands/bgrewriteaof</a> </dd></dl>

</div>
</div>
<a id="a66fdd787464f9471ef3f6d3c03bb557b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fdd787464f9471ef3f6d3c03bb557b">&#9670;&nbsp;</a></span>bgsave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::bgsave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save database in the background. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bgsave">https://redis.io/commands/bgsave</a> </dd></dl>

</div>
</div>
<a id="a486f72d0b0b4586b60f74e4741639cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486f72d0b0b4586b60f74e4741639cb0">&#9670;&nbsp;</a></span>bitcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::bitcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bits that have been set for the given range of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits that have been set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The index can be negative to index from the end of the string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitcount">https://redis.io/commands/bitcount</a> </dd></dl>

</div>
</div>
<a id="aaffd2b9440e25874139cedec3118573b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffd2b9440e25874139cedec3118573b">&#9670;&nbsp;</a></span>bitop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::bitop </td>
          <td>(</td>
          <td class="paramtype">BitOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do bit operation on the string stored at <code>key</code>, and save the result to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Bit operations. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination key where the result is saved. </td></tr>
    <tr><td class="paramname">key</td><td>The key where the string to be operated is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string saved at <code>destination</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitop">https://redis.io/commands/bitop</a> </dd>
<dd>
<code>BitOp</code> </dd></dl>

</div>
</div>
<a id="a3f93e89f3b491dd0ab052d0578b86786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f93e89f3b491dd0ab052d0578b86786">&#9670;&nbsp;</a></span>bitpos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::bitpos </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of the first bit set to 0 or 1 in the given range of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">bit</td><td>0 or 1. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first bit set to 0 or 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitpos">https://redis.io/commands/bitpos</a> </dd></dl>

</div>
</div>
<a id="a0d8bab1729ffbb339353b6360aa4a844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8bab1729ffbb339353b6360aa4a844">&#9670;&nbsp;</a></span>bzpopmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::bzpopmax </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with highest score from sorted set in a blocking way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. 0 means block forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key-member-score tuple with the highest score. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zpopmax</code> </dd>
<dd>
<a href="https://redis.io/commands/bzpopmax">https://redis.io/commands/bzpopmax</a> </dd></dl>

</div>
</div>
<a id="aae5f5b746e41921bd7602f6bfac8927a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5f5b746e41921bd7602f6bfac8927a">&#9670;&nbsp;</a></span>bzpopmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::bzpopmin </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with lowest score from sorted set in a blocking way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. 0 means block forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key-member-score tuple with the lowest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty and timeout reaches, <code>bzpopmin</code> returns <code>Optional&lt;std::tuple&lt;std::string, std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zpopmin</code> </dd>
<dd>
<a href="https://redis.io/commands/bzpopmin">https://redis.io/commands/bzpopmin</a> </dd></dl>

</div>
</div>
<a id="afb0331d230fe9fd39316ca780d8eb810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0331d230fe9fd39316ca780d8eb810">&#9670;&nbsp;</a></span>command() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CORO_RET  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;CORO_RET&gt; coro_redis::coro_connection::command </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send redis command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Redis command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Redis return. </dd></dl>

</div>
</div>
<a id="acad98a1fbb59805e2a229c39c22cf5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad98a1fbb59805e2a229c39c22cf5bd">&#9670;&nbsp;</a></span>command() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CORO_RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;CORO_RET&gt; coro_redis::coro_connection::command </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::optional&lt; CORO_RET &gt;(redisReply *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>reply_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send redis command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Redis command. </td></tr>
    <tr><td class="paramname">reply_op</td><td>Callback for deal redis reply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Redis return. </dd></dl>

</div>
</div>
<a id="ad9d1bf9936d10baaf4f6f2d241ad8b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d1bf9936d10baaf4f6f2d241ad8b1f">&#9670;&nbsp;</a></span>dbsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::dbsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the currently selected database. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of keys in currently selected database. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/dbsize">https://redis.io/commands/dbsize</a> </dd></dl>

</div>
</div>
<a id="a5cddc30fc181d3d5b349cf2d198a3c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cddc30fc181d3d5b349cf2d198a3c9d">&#9670;&nbsp;</a></span>decr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::decr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the integer stored at key by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the decrement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/decr">https://redis.io/commands/decr</a> </dd></dl>

</div>
</div>
<a id="abe809531f975362d1b2327947012584c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe809531f975362d1b2327947012584c">&#9670;&nbsp;</a></span>decrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::decrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>decrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the integer stored at key by <code>decrement</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">decrement</td><td>Decrement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the decrement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/decrby">https://redis.io/commands/decrby</a> </dd></dl>

</div>
</div>
<a id="a6e3b69612b6ad498fc392420ed04e2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3b69612b6ad498fc392420ed04e2c4">&#9670;&nbsp;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::del </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of keys removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the key exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/del">https://redis.io/commands/del</a> </dd></dl>

</div>
</div>
<a id="ae16d167c0f172d2758b88cb7c779552f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16d167c0f172d2758b88cb7c779552f">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::dump </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the serialized valued stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serialized value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>dump</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/dump">https://redis.io/commands/dump</a> </dd></dl>

</div>
</div>
<a id="a242fca0a60316bd227ee737d4ba5f15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242fca0a60316bd227ee737d4ba5f15a">&#9670;&nbsp;</a></span>echo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::echo </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask Redis to return the given message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the given message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/echo">https://redis.io/commands/echo</a> </dd></dl>

</div>
</div>
<a id="aa4b399c1e24b46e72a0a856c89e48573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b399c1e24b46e72a0a856c89e48573">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::exists </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given key exists. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/exists">https://redis.io/commands/exists</a> </dd></dl>

</div>
</div>
<a id="a9609aa546610bb323afdbd43018996e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9609aa546610bb323afdbd43018996e9">&#9670;&nbsp;</a></span>expire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::expire </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/expire">https://redis.io/commands/expire</a> </dd></dl>

</div>
</div>
<a id="a1fbb452b39c08b98a47860ef25f0de5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb452b39c08b98a47860ef25f0de5f">&#9670;&nbsp;</a></span>expireat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::expireat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key, i.e. expire the key at a future time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time in seconds since UNIX epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/expireat">https://redis.io/commands/expireat</a> </dd></dl>

</div>
</div>
<a id="a11b5fa63aa787443f9a3f226f8fdd27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b5fa63aa787443f9a3f226f8fdd27d">&#9670;&nbsp;</a></span>flushall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::flushall </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys of all databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>Whether flushing databases asynchronously, i.e. without blocking the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/flushall">https://redis.io/commands/flushall</a> </dd></dl>

</div>
</div>
<a id="ad52db6cc82bd99cfb4e80aeed9d5d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52db6cc82bd99cfb4e80aeed9d5d0fd">&#9670;&nbsp;</a></span>flushdb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::flushdb </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys of current databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>Whether flushing databases asynchronously, i.e. without blocking the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/flushdb">https://redis.io/commands/flushdb</a> </dd></dl>

</div>
</div>
<a id="aa42ff00230cefbb87bd5822ac8576878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42ff00230cefbb87bd5822ac8576878">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::get </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the string value stored at key. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value stored at key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>get</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/get">https://redis.io/commands/get</a> </dd></dl>

</div>
</div>
<a id="ac6d9cc3b95a3f70f59be32fd6af2f3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d9cc3b95a3f70f59be32fd6af2f3f3">&#9670;&nbsp;</a></span>getbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::getbit </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bit value at offset in the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getbit">https://redis.io/commands/getbit</a> </dd></dl>

</div>
</div>
<a id="a97f05737d51b501b653a6664d5accc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f05737d51b501b653a6664d5accc97">&#9670;&nbsp;</a></span>getrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::getrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring of the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substring in range [start, end]. If key does not exist, return an empty string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getrange">https://redis.io/commands/getrange</a> </dd></dl>

</div>
</div>
<a id="aed0864dcaba3cdbe57efb662228b09d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0864dcaba3cdbe57efb662228b09d4">&#9670;&nbsp;</a></span>getset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::getset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically set the string stored at <code>key</code> to <code>val</code>, and return the old value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value stored at key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>getset</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getset">https://redis.io/commands/getset</a> </dd>
<dd>
<code>OptionalString</code> </dd></dl>

</div>
</div>
<a id="a2b703acf9cea1a01912e6a31c0a807bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b703acf9cea1a01912e6a31c0a807bd">&#9670;&nbsp;</a></span>hdel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hdel </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given field from hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the field exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the field does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hdel">https://redis.io/commands/hdel</a> </dd></dl>

</div>
</div>
<a id="a6f6827868671776db3b13482b14c9344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6827868671776db3b13482b14c9344">&#9670;&nbsp;</a></span>hexists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hexists </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given field exists in hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field exists. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the field exists in hash. </td></tr>
    <tr><td class="paramname">false</td><td>If the field does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hexists">https://redis.io/commands/hexists</a> </dd></dl>

</div>
</div>
<a id="a742fa7649368e0063f953b6fb91ba880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742fa7649368e0063f953b6fb91ba880">&#9670;&nbsp;</a></span>hget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::hget </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the given field. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If field does not exist, <code>hget</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hget">https://redis.io/commands/hget</a> </dd></dl>

</div>
</div>
<a id="a07eb0d31376567ba55212654292404d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07eb0d31376567ba55212654292404d4">&#9670;&nbsp;</a></span>hgetall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::hgetall </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all field-value pairs of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; results;</div>
<div class="line"><span class="comment">// Save all field-value pairs of a Redis hash to an unordered_map&lt;string,</span></div>
<div class="line"><span class="keywordtype">string</span>&gt;. redis.hgetall(<span class="stringliteral">&quot;hash&quot;</span>, std::inserter(results, results.begin()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hgetall</code> on a large hash, since it will block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a> </dd></dl>

</div>
</div>
<a id="a59ab5386c279fe04eefd10c6e5d50d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ab5386c279fe04eefd10c6e5d50d79">&#9670;&nbsp;</a></span>hincrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hincrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hincrby">https://redis.io/commands/hincrby</a> </dd></dl>

</div>
</div>
<a id="a7f2e618e7957a89cdf6e2b3a0abf2b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2e618e7957a89cdf6e2b3a0abf2b7d">&#9670;&nbsp;</a></span>hincrbyfloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;double&gt; coro_redis::coro_connection::hincrbyfloat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the floating point number stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hincrbyfloat">https://redis.io/commands/hincrbyfloat</a> </dd></dl>

</div>
</div>
<a id="aab1d670b54c8fd12cff0f3a47ca2316c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1d670b54c8fd12cff0f3a47ca2316c">&#9670;&nbsp;</a></span>hkeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::hkeys </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all fields of the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hkeys</code> on a large hash, since it will block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hkeys">https://redis.io/commands/hkeys</a> </dd></dl>

</div>
</div>
<a id="a04719ad766e80466e0775032f47ff8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04719ad766e80466e0775032f47ff8ce">&#9670;&nbsp;</a></span>hlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of fields of the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of fields. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hlen">https://redis.io/commands/hlen</a> </dd></dl>

</div>
</div>
<a id="a471eda079fef74f3236ba444abfadf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471eda079fef74f3236ba444abfadf77">&#9670;&nbsp;</a></span>hmget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::hmget </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of multiple fields. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; fields = {<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;f2&quot;</span>};</div>
<div class="line">std::vector&lt;OptionalString&gt; vals;</div>
<div class="line">redis.hmget(<span class="stringliteral">&quot;hash&quot;</span>, fields.begin(), fields.end(),</div>
<div class="line">std::back_inserter(vals)); <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : vals) {</div>
<div class="line">    <span class="keywordflow">if</span> (val)</div>
<div class="line">        std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;field not exist&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given field range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination should be a container of <code>OptionalString</code> type, since the given field might not exist (in this case, the value of the corresponding field is <code>OptionalString{}</code> (<code>std::nullopt</code>)). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hmget">https://redis.io/commands/hmget</a> </dd></dl>

</div>
</div>
<a id="a6906639f6c02e318dcf29f9607129202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6906639f6c02e318dcf29f9607129202">&#9670;&nbsp;</a></span>hmset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::hmset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple field-value pairs of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; m = {{<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>}, {<span class="stringliteral">&quot;f2&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;v2&quot;</span>}}; redis.hmset(<span class="stringliteral">&quot;hash&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field-value pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hmset">https://redis.io/commands/hmset</a> </dd></dl>

</div>
</div>
<a id="a1989ec0704d4fdb8234726c101f18ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1989ec0704d4fdb8234726c101f18ff0">&#9670;&nbsp;</a></span>hscan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;scan_ret_t&gt; coro_redis::coro_connection::hscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan fields of the given hash matching the given pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hscan">https://redis.io/commands/hscan</a> </dd></dl>

</div>
</div>
<a id="a064625c667e4372b017988667a7caed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064625c667e4372b017988667a7caed0">&#9670;&nbsp;</a></span>hscan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;scan_ret_t&gt; coro_redis::coro_connection::hscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan fields of the given hash matching the given pattern. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cursor = 0LL;</div>
<div class="line">std::unordered_map&lt;std::string, std::string&gt; kvs;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    cursor = redis.hscan(<span class="stringliteral">&quot;hash&quot;</span>, cursor, <span class="stringliteral">&quot;pattern:*&quot;</span>, 10,</div>
<div class="line">    std::inserter(kvs, kvs.begin())); <span class="keywordflow">if</span> (cursor == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hscan">https://redis.io/commands/hscan</a> </dd></dl>

</div>
</div>
<a id="afff6aa223e62a6dc9186cf048d3cbfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff6aa223e62a6dc9186cf048d3cbfa0">&#9670;&nbsp;</a></span>hset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string_view, std::string_view &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>kvs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple fields of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; m = {{<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>}, {<span class="stringliteral">&quot;f2&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;v2&quot;</span>}}; redis.hset(<span class="stringliteral">&quot;hash&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field to be set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of fields that have been added, i.e. fields that not existed before. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hset">https://redis.io/commands/hset</a> </dd></dl>

</div>
</div>
<a id="a989bafcf8271789bbf1a056a9011e464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989bafcf8271789bbf1a056a9011e464">&#9670;&nbsp;</a></span>hset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hash field to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given field is a new field. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the given field didn't exist, and a new field has been added. </td></tr>
    <tr><td class="paramname">false</td><td>If the given field already exists, and its value has been overwritten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <code>hset</code> returns false, it does not mean that the method failed to set the field. Instead, it means that the field already exists, and we've overwritten its value. If <code>hset</code> fails, it will throw an exception of <code>Exception</code> type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/sewenew/redis-plus-plus/issues/9">https://github.com/sewenew/redis-plus-plus/issues/9</a> </dd>
<dd>
<a href="https://redis.io/commands/hset">https://redis.io/commands/hset</a> </dd></dl>

</div>
</div>
<a id="a77dc62363ad780daad092dfc1a0f23ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dc62363ad780daad092dfc1a0f23ad">&#9670;&nbsp;</a></span>hsetnx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hsetnx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hash field to value, only if the given field does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the field has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If failed to set the field, i.e. the field already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hsetnx">https://redis.io/commands/hsetnx</a> </dd></dl>

</div>
</div>
<a id="a390a5b8d20bda94415be2938316240e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390a5b8d20bda94415be2938316240e0">&#9670;&nbsp;</a></span>hstrlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::hstrlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hstrlen">https://redis.io/commands/hstrlen</a> </dd></dl>

</div>
</div>
<a id="a320bd653ca450cb00282c85861fda4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320bd653ca450cb00282c85861fda4a7">&#9670;&nbsp;</a></span>hvals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::hvals </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of all fields stored at the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hvals</code> on a large hash, since it might block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hvals">https://redis.io/commands/hvals</a> </dd></dl>

</div>
</div>
<a id="aaddb4ca2cefee0bdeaed216ead443c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddb4ca2cefee0bdeaed216ead443c1a">&#9670;&nbsp;</a></span>incr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::incr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at key by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incr">https://redis.io/commands/incr</a> </dd></dl>

</div>
</div>
<a id="a27b1cdbc15cf41053531f579f9cf9b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b1cdbc15cf41053531f579f9cf9b5b">&#9670;&nbsp;</a></span>incrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::incrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at key by <code>increment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incrby">https://redis.io/commands/incrby</a> </dd></dl>

</div>
</div>
<a id="a0d71ba58af8e80441598b2d395745971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d71ba58af8e80441598b2d395745971">&#9670;&nbsp;</a></span>incrbyfloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::incrbyfloat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the floating point number stored at key by <code>increment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incrbyfloat">https://redis.io/commands/incrbyfloat</a> </dd></dl>

</div>
</div>
<a id="a8c3c85b49de3233b00fdd2c2dfc44e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3c85b49de3233b00fdd2c2dfc44e1d">&#9670;&nbsp;</a></span>info() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the info about the server. </p>
<dl class="section return"><dt>Returns</dt><dd>Server info. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/info">https://redis.io/commands/info</a> </dd></dl>

</div>
</div>
<a id="a9df4183a5e15a171774570101b4e30aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df4183a5e15a171774570101b4e30aa">&#9670;&nbsp;</a></span>info() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::info </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>section</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the info about the server on the given section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>Section. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Server info. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/info">https://redis.io/commands/info</a> </dd></dl>

</div>
</div>
<a id="a37517cf941f9a7267734287e3f152dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37517cf941f9a7267734287e3f152dea">&#9670;&nbsp;</a></span>lastsave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::lastsave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UNIX timestamp in seconds, at which the database was saved successfully. </p>
<dl class="section return"><dt>Returns</dt><dd>The last saving time. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lastsave">https://redis.io/commands/lastsave</a> </dd></dl>

</div>
</div>
<a id="ab742f90703051d0954b88316e0043c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab742f90703051d0954b88316e0043c93">&#9670;&nbsp;</a></span>llen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::llen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/llen">https://redis.io/commands/llen</a> </dd></dl>

</div>
</div>
<a id="a7fc61da81a9cc5dc1c7853aedec49362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc61da81a9cc5dc1c7853aedec49362">&#9670;&nbsp;</a></span>lpop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::lpop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the first element of the list. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> element = redis.lpop(<span class="stringliteral">&quot;list&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (element)</div>
<div class="line">    std::cout &lt;&lt; *element &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;list is empty, i.e. list does not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If list is empty, i.e. key does not exist, return <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpop">https://redis.io/commands/lpop</a> </dd></dl>

</div>
</div>
<a id="aed8df4028862f17c19ed31c91121aa9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8df4028862f17c19ed31c91121aa9b">&#9670;&nbsp;</a></span>lpush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::lpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push multiple elements to the beginning of the list. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; elements = {<span class="stringliteral">&quot;e1&quot;</span>, <span class="stringliteral">&quot;e2&quot;</span>, <span class="stringliteral">&quot;e3&quot;</span>};</div>
<div class="line">redis.lpush(<span class="stringliteral">&quot;list&quot;</span>, elements.begin(), elements.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first element to be pushed. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given element range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a> </dd></dl>

</div>
</div>
<a id="a3a9287b68ef1fe59aa908bd18a22ae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9287b68ef1fe59aa908bd18a22ae41">&#9670;&nbsp;</a></span>lpush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::lpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the beginning of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a> </dd></dl>

</div>
</div>
<a id="a89353d4c3f5123d6f5aa442aaf78b64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89353d4c3f5123d6f5aa442aaf78b64e">&#9670;&nbsp;</a></span>lpushx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::lpushx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the beginning of the list, only if the list already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpushx">https://redis.io/commands/lpushx</a> </dd></dl>

</div>
</div>
<a id="a7cb7bb9a8df30f22d6a9f8c77ddb99a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb7bb9a8df30f22d6a9f8c77ddb99a7">&#9670;&nbsp;</a></span>lrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::lrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get elements in the given range of the given list. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; elements;</div>
<div class="line"><span class="comment">// Save all elements of a Redis list to a vector of string.</span></div>
<div class="line">redis.lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1, std::back_inserter(elements));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the range. Index can be negative, which mean index from the end. </td></tr>
    <tr><td class="paramname">stop</td><td>End index of the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the results are saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a> </dd></dl>

</div>
</div>
<a id="ac3d13b0fdf30c856f59a9c1d6dc63499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d13b0fdf30c856f59a9c1d6dc63499">&#9670;&nbsp;</a></span>lrem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::lrem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first <code>count</code> occurrences of elements equal to <code>val</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">count</td><td>Number of occurrences to be removed. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>count</code> can be positive, negative and 0. Check the reference for detail. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lrem">https://redis.io/commands/lrem</a> </dd></dl>

</div>
</div>
<a id="a6fffeb2ba22dc630915e66a6a07418cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fffeb2ba22dc630915e66a6a07418cc">&#9670;&nbsp;</a></span>lset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::lset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element at the given index to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the element to be set. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lset">https://redis.io/commands/lset</a> </dd></dl>

</div>
</div>
<a id="af7a086e48f2d733766def9bf70e49af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a086e48f2d733766def9bf70e49af9">&#9670;&nbsp;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim a list to keep only element in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the key is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start of the index. </td></tr>
    <tr><td class="paramname">stop</td><td>End of the index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ltrim">https://redis.io/commands/ltrim</a> </dd></dl>

</div>
</div>
<a id="a0d0ec7aea535f875885d86b003d341a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ec7aea535f875885d86b003d341a9">&#9670;&nbsp;</a></span>mget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::mget </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values of multiple keys atomically. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;k3&quot;</span>};</div>
<div class="line">std::vector&lt;OptionalString&gt; vals;</div>
<div class="line">redis.mget(keys.begin(), keys.end(), std::back_inserter(vals));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : vals) {</div>
<div class="line">    <span class="keywordflow">if</span> (val)</div>
<div class="line">        std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;key does not exist&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first key of the given range. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the values are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination should be a container of <code>OptionalString</code> type, since the given key might not exist (in this case, the value of the corresponding key is <code>OptionalString{}</code> (<code>std::nullopt</code>)). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/mget">https://redis.io/commands/mget</a> </dd></dl>

</div>
</div>
<a id="a8b8ad35553e2d0f618f64f7be80782d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8ad35553e2d0f618f64f7be80782d7">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::move </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get keys matching the given pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Pattern. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the returned keys are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>keys</code>, since it might block Redis for a long time, especially when the data set is very big. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::scan</code> </dd>
<dd>
<a href="https://redis.io/commands/keys">https://redis.io/commands/keys</a></dd></dl>
<p>Move a key to the given database. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">db</td><td>The destination database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether key has been moved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If key has been moved. </td></tr>
    <tr><td class="paramname">false</td><td>If key was not moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/move">https://redis.io/commands/move</a> </dd></dl>

</div>
</div>
<a id="a97e5aec165c734686cf7524cc9eb0776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5aec165c734686cf7524cc9eb0776">&#9670;&nbsp;</a></span>mset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::mset </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple key-value pairs. </p>
<p>Example: </p><div class="fragment"><div class="line">redis.mset({std::make_pair(<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>), std::make_pair(<span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;v2&quot;</span>)});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>Initializer list of key-value pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/mset">https://redis.io/commands/mset</a> </dd></dl>

</div>
</div>
<a id="a427b884ee7815421b41f8b1b53754f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427b884ee7815421b41f8b1b53754f15">&#9670;&nbsp;</a></span>msetnx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::msetnx </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the given key-value pairs if all specified keys do not exist. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; kvs1;</div>
<div class="line">redis.msetnx(kvs1.begin(), kvs1.end());</div>
<div class="line">std::unordered_map&lt;std::string, std::string&gt; kvs2;</div>
<div class="line">redis.msetnx(kvs2.begin(), kvs2.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first key-value pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator of the given range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether all keys have been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If all keys have been set. </td></tr>
    <tr><td class="paramname">false</td><td>If no key was set, i.e. at least one key already exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/msetnx">https://redis.io/commands/msetnx</a> </dd></dl>

</div>
</div>
<a id="a43120cf377919c87afcfa4d247c42fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43120cf377919c87afcfa4d247c42fff">&#9670;&nbsp;</a></span>persist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::persist </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been removed. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist, or does not have an associated timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/persist">https://redis.io/commands/persist</a> </dd></dl>

</div>
</div>
<a id="a89bd28a9a885f02d73af0cac8d815388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bd28a9a885f02d73af0cac8d815388">&#9670;&nbsp;</a></span>pexpire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::pexpire </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pexpire">https://redis.io/commands/pexpire</a> </dd></dl>

</div>
</div>
<a id="a5a4925a6567993d32be66f149c4b319b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4925a6567993d32be66f149c4b319b">&#9670;&nbsp;</a></span>pexpireat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::pexpireat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key, i.e. expire the key at a future time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time in milliseconds since UNIX epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pexpireat">https://redis.io/commands/pexpireat</a> </dd></dl>

</div>
</div>
<a id="a6d35764c7d3c77ae1ab951f8192c49e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d35764c7d3c77ae1ab951f8192c49e4">&#9670;&nbsp;</a></span>pfadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::pfadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given element to a hyperloglog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of the hyperloglog. </td></tr>
    <tr><td class="paramname">element</td><td>Element to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any of hyperloglog's internal register has been altered. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If at least one internal register has been altered. </td></tr>
    <tr><td class="paramname">false</td><td>If none of internal registers has been altered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <code>pfadd</code> returns false, it does not mean that this method failed to add an element to the hyperloglog. Instead it means that the internal registers were not altered. If <code>pfadd</code> fails, it will throw an exception of <code>Exception</code> type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pfadd">https://redis.io/commands/pfadd</a> </dd></dl>

</div>
</div>
<a id="a831f88d7336e1c301a948942dffab418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831f88d7336e1c301a948942dffab418">&#9670;&nbsp;</a></span>ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::ping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connection is alive. </p>
<dl class="section return"><dt>Returns</dt><dd>Always return <em>PONG</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ping">https://redis.io/commands/ping</a> </dd></dl>

</div>
</div>
<a id="a8e68ed767a042006db11100b15d1c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e68ed767a042006db11100b15d1c765">&#9670;&nbsp;</a></span>ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::ping </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connection is alive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message sent to Redis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the given message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ping">https://redis.io/commands/ping</a> </dd></dl>

</div>
</div>
<a id="ad0bac0ef276fc16f792ddc9cfcf89455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bac0ef276fc16f792ddc9cfcf89455">&#9670;&nbsp;</a></span>psetex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::psetex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set key-value pair with the given timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">ttl</td><td>Time-To-Live in milliseconds. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/psetex">https://redis.io/commands/psetex</a> </dd></dl>

</div>
</div>
<a id="abc31f719052dd6ff99db81b372708b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc31f719052dd6ff99db81b372708b35">&#9670;&nbsp;</a></span>pttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::pttl </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the TTL of a key in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TTL of the key in milliseconds. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pttl">https://redis.io/commands/pttl</a> </dd></dl>

</div>
</div>
<a id="a5a245370c5983cf37bc567b4ad2880e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a245370c5983cf37bc567b4ad2880e4">&#9670;&nbsp;</a></span>quit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After sending QUIT, only the current connection will be close, while other connections in the pool is still open. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/quit">https://redis.io/commands/quit</a> </dd></dl>

</div>
</div>
<a id="a9fd890122ffe0335dcfaa95231a6aced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd890122ffe0335dcfaa95231a6aced">&#9670;&nbsp;</a></span>randomkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::randomkey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random key from current database. </p>
<dl class="section return"><dt>Returns</dt><dd>A random key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the database is empty, <code>randomkey</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/randomkey">https://redis.io/commands/randomkey</a> </dd></dl>

</div>
</div>
<a id="abbf099822303789b07241f37fe2f711d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf099822303789b07241f37fe2f711d">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::rename </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>newkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename <code>key</code> to <code>newkey</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be renamed. </td></tr>
    <tr><td class="paramname">newkey</td><td>The new name of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rename">https://redis.io/commands/rename</a> </dd></dl>

</div>
</div>
<a id="a6903146a136e342ad88c71169aeffe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6903146a136e342ad88c71169aeffe2c">&#9670;&nbsp;</a></span>renamenx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::renamenx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>newkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename <code>key</code> to <code>newkey</code> if <code>newkey</code> does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be renamed. </td></tr>
    <tr><td class="paramname">newkey</td><td>The new name of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether key has been renamed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If key has been renamed. </td></tr>
    <tr><td class="paramname">false</td><td>If newkey already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/renamenx">https://redis.io/commands/renamenx</a> </dd></dl>

</div>
</div>
<a id="a07b35c7d9b89ed8c9f1b3c7e2c9dd89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b35c7d9b89ed8c9f1b3c7e2c9dd89a">&#9670;&nbsp;</a></span>restore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::restore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a key with the value obtained by <code>Redis::dump</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value obtained by <code>Redis::dump</code>. </td></tr>
    <tr><td class="paramname">ttl</td><td>Timeout of the created key in milliseconds. If <code>ttl</code> is 0, set no timeout. </td></tr>
    <tr><td class="paramname">replace</td><td>Whether to overwrite an existing key. If <code>replace</code> is <code>true</code> and key already exists, throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/restore">https://redis.io/commands/restore</a> </dd></dl>

</div>
</div>
<a id="ac2a0a31265972be2c674f0e1ce750b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a0a31265972be2c674f0e1ce750b43">&#9670;&nbsp;</a></span>rpop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::rpop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the list is empty, i.e. key does not exist, <code>rpop</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpop">https://redis.io/commands/rpop</a> </dd></dl>

</div>
</div>
<a id="ac41f5045c1687e3e57afb7953b22d346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41f5045c1687e3e57afb7953b22d346">&#9670;&nbsp;</a></span>rpoplpush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::rpoplpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop last element of one list and push it to the left of another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Key of the source list. </td></tr>
    <tr><td class="paramname">destination</td><td>Key of the destination list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the source list does not exist, <code>rpoplpush</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/brpoplpush">https://redis.io/commands/brpoplpush</a> </dd></dl>

</div>
</div>
<a id="a08ff468dae74ff85572eab87e017eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ff468dae74ff85572eab87e017eaff">&#9670;&nbsp;</a></span>rpush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::rpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpush">https://redis.io/commands/rpush</a> </dd></dl>

</div>
</div>
<a id="a1fe5cd20ac7e6a2fab7c173f2517538d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5cd20ac7e6a2fab7c173f2517538d">&#9670;&nbsp;</a></span>rpushx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::rpushx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the end of the list, only if the list already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpushx">https://redis.io/commands/rpushx</a> </dd></dl>

</div>
</div>
<a id="accd9af12aab3804e1fea0c6e2e2ee6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd9af12aab3804e1fea0c6e2e2ee6b1">&#9670;&nbsp;</a></span>sadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::sadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a member to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given member is a new member. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>The member did not exist before, and it has been added now. </td></tr>
    <tr><td class="paramname">0</td><td>The member already exists before this operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sadd">https://redis.io/commands/sadd</a> </dd></dl>

</div>
</div>
<a id="a0f43c1b0021c9d60d15e17bf98d9b8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f43c1b0021c9d60d15e17bf98d9b8c1">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save databases into RDB file <b>synchronously</b>, i.e. block the server during saving. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/save">https://redis.io/commands/save</a> </dd></dl>

</div>
</div>
<a id="a0b27bcac3010c774797fa231004708b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b27bcac3010c774797fa231004708b3">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;scan_ret_t&gt; coro_redis::coro_connection::scan </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan keys of the database matching the given pattern. </p>
<p>Example: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of the keys to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many keys to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the returned keys are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> TODO: support the TYPE option for Redis 6.0. </dd></dl>

</div>
</div>
<a id="aefd46666b92e108a34221f390c989587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd46666b92e108a34221f390c989587">&#9670;&nbsp;</a></span>scard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::scard </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/scard">https://redis.io/commands/scard</a> </dd></dl>

</div>
</div>
<a id="a41d2aaf9d4467222e544d9002516a9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d2aaf9d4467222e544d9002516a9b0">&#9670;&nbsp;</a></span>sdiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::sdiff </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the difference between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sdiff">https://redis.io/commands/sdiff</a> </dd></dl>

</div>
</div>
<a id="a00126981851b1c554fe61d00d613b31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00126981851b1c554fe61d00d613b31e">&#9670;&nbsp;</a></span>sdiffstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::sdiffstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sdiffstore">https://redis.io/commands/sdiffstore</a> </dd></dl>

</div>
</div>
<a id="a6429926da586c8e18827cc50dae38f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6429926da586c8e18827cc50dae38f66">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::select </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the Redis logical database. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/select">https://redis.io/commands/select</a> </dd></dl>

</div>
</div>
<a id="ae5a4c4231a69fd20192ae33a4cdd04a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a4c4231a69fd20192ae33a4cdd04a4">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RedisSetValueType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::set </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedisTTLType&#160;</td>
          <td class="paramname"><em>ttl_type</em> = <code>RedisTTLType::EX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a key-value pair. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Set a key-value pair.</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"><span class="comment">// Set a key-value pair, and expire it after 10 seconds.</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, std::chrono::seconds(10));</div>
<div class="line"><span class="comment">// Set a key-value pair with a timeout, only if the key already exists.</span></div>
<div class="line"><span class="keywordflow">if</span> (redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, std::chrono::seconds(10),</div>
<div class="line">UpdateType::EXIST))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;OK&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key does not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
    <tr><td class="paramname">ttl</td><td>Timeout on the key. If <code>ttl</code> is 0ms, do not set timeout. </td></tr>
    <tr><td class="paramname">type</td><td>Options for set command:<ul>
<li>UpdateType::EXIST: Set the key only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Set the key only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always set the key no matter whether it exists. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the key has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If the key was not set, because of the given option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/set">https://redis.io/commands/set</a> </dd></dl>

</div>
</div>
<a id="a5cc1cc710b2ca3c1f3e0b8e65bbba9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc1cc710b2ca3c1f3e0b8e65bbba9e7">&#9670;&nbsp;</a></span>setex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::setex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set key-value pair with the given timeout in seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">ttl</td><td>Time-To-Live in seconds. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setex">https://redis.io/commands/setex</a> </dd></dl>

</div>
</div>
<a id="abfc3e988786498b8364e4d5be2fc4656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc3e988786498b8364e4d5be2fc4656">&#9670;&nbsp;</a></span>setnx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::setnx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the key if it does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the key has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If the key was not set, i.e. the key already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setnx">https://redis.io/commands/setnx</a> </dd></dl>

</div>
</div>
<a id="a7295cb5ac2c6f00d1dd60936034e4d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7295cb5ac2c6f00d1dd60936034e4d39">&#9670;&nbsp;</a></span>setrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::setrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the substring starting from <code>offset</code> to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string after this operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setrange">https://redis.io/commands/setrange</a> </dd></dl>

</div>
</div>
<a id="a13f402a3254566b0a1409e905aadd3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f402a3254566b0a1409e905aadd3bb">&#9670;&nbsp;</a></span>sinter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::sinter </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the intersection between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sinter">https://redis.io/commands/sinter</a> </dd></dl>

</div>
</div>
<a id="a7d444da5f8675cb88d2cdb17c6cb2ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d444da5f8675cb88d2cdb17c6cb2ac2">&#9670;&nbsp;</a></span>sinterstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::sinterstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sinter">https://redis.io/commands/sinter</a> </dd></dl>

</div>
</div>
<a id="a8c32ad6ffad5ad1ca7fb60d6cedf1fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c32ad6ffad5ad1ca7fb60d6cedf1fe7">&#9670;&nbsp;</a></span>sismember()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::sismember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if <code>member</code> exists in the set stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>member</code> exists in the set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If it exists in the set. </td></tr>
    <tr><td class="paramname">false</td><td>If it does not exist in the set, or the given key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sismember">https://redis.io/commands/sismember</a> </dd></dl>

</div>
</div>
<a id="a460d52e7508312d6cb66492a16572499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460d52e7508312d6cb66492a16572499">&#9670;&nbsp;</a></span>smembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::smembers </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all members in the given set. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_set&lt;std::string&gt; members1;</div>
<div class="line">redis.smembers(<span class="stringliteral">&quot;set&quot;</span>, std::inserter(members1, members1.begin()));</div>
<div class="line">std::vector&lt;std::string&gt; members2;</div>
<div class="line">redis.smembers(<span class="stringliteral">&quot;set&quot;</span>, std::back_inserter(members2));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a> </dd></dl>

</div>
</div>
<a id="aaf1db5dc5bf80ac96a65f49203f62fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1db5dc5bf80ac96a65f49203f62fef">&#9670;&nbsp;</a></span>smove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::smove </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move <code>member</code> from one set to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Key of the set in which the member currently exists. </td></tr>
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been moved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the member has been moved. </td></tr>
    <tr><td class="paramname">false</td><td>If <code>member</code> does not exist in <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/smove">https://redis.io/commands/smove</a> </dd></dl>

</div>
</div>
<a id="ae2217d63ae2dddfcb3ee1c98104ca44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2217d63ae2dddfcb3ee1c98104ca44a">&#9670;&nbsp;</a></span>spop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::spop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a random member from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the set is empty, <code>spop</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::srandmember</code> </dd>
<dd>
<a href="https://redis.io/commands/spop">https://redis.io/commands/spop</a> </dd></dl>

</div>
</div>
<a id="a4cebf8814bed3196f65d3ee5d95602a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cebf8814bed3196f65d3ee5d95602a6">&#9670;&nbsp;</a></span>srandmember() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::srandmember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random member of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the set is empty, <code>srandmember</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd>
<dd>
This method won't remove the member from the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::spop</code> </dd>
<dd>
<a href="https://redis.io/commands/srandmember">https://redis.io/commands/srandmember</a> </dd></dl>

</div>
</div>
<a id="a3d024e1084ce9a8d02a44b894c64b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d024e1084ce9a8d02a44b894c64b464">&#9670;&nbsp;</a></span>srandmember() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::srandmember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get multiple random members of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">count</td><td>Number of members to be returned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method won't remove members from the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::spop</code> </dd>
<dd>
<a href="https://redis.io/commands/srandmember">https://redis.io/commands/srandmember</a> </dd></dl>

</div>
</div>
<a id="ac12063063fdbf86df0768cd60803fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12063063fdbf86df0768cd60803fabf">&#9670;&nbsp;</a></span>srem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::srem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a member from set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the given member exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the given member does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/srem">https://redis.io/commands/srem</a> </dd></dl>

</div>
</div>
<a id="a80ce030ee7ea6675f64c6b808f54ff1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ce030ee7ea6675f64c6b808f54ff1d">&#9670;&nbsp;</a></span>sscan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;scan_ret_t&gt; coro_redis::coro_connection::sscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan members of the set matching the given pattern. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cursor = 0LL;</div>
<div class="line">std::unordered_set&lt;std::string&gt; members;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    cursor = redis.sscan(<span class="stringliteral">&quot;set&quot;</span>, cursor, <span class="stringliteral">&quot;pattern:*&quot;</span>,</div>
<div class="line">        10, std::inserter(members, members.begin()));</div>
<div class="line">    <span class="keywordflow">if</span> (cursor == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sscan">https://redis.io/commands/sscan</a> </dd></dl>

</div>
</div>
<a id="a4f3b13fb28c5d91b84ed6d29774deb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3b13fb28c5d91b84ed6d29774deb86">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::strlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>strlen</code> returns 0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/strlen">https://redis.io/commands/strlen</a> </dd></dl>

</div>
</div>
<a id="affd4e3a5907cd681a0db72688d585319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd4e3a5907cd681a0db72688d585319">&#9670;&nbsp;</a></span>sunion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::sunion </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the union between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sunion">https://redis.io/commands/sunion</a> </dd></dl>

</div>
</div>
<a id="a98c30efc9e5cab586a6969bb32e56c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c30efc9e5cab586a6969bb32e56c5a">&#9670;&nbsp;</a></span>sunionstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::sunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sunionstore">https://redis.io/commands/sunionstore</a> </dd></dl>

</div>
</div>
<a id="adeb6b91bcb4a1c8a4f9deaa51fbee477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb6b91bcb4a1c8a4f9deaa51fbee477">&#9670;&nbsp;</a></span>swapdb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::swapdb </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two Redis databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx1</td><td>The index of the first database. </td></tr>
    <tr><td class="paramname">idx2</td><td>The index of the second database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/swapdb">https://redis.io/commands/swapdb</a> </dd></dl>

</div>
</div>
<a id="a8478ecb3c377ccd3e1253a21a993caef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8478ecb3c377ccd3e1253a21a993caef">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcoro__redis_1_1sync__connection.html">sync_connection</a>&gt; coro_redis::coro_connection::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction </p>
<dl class="section return"><dt>Returns</dt><dd>Get synchronous connection from current connection </dd></dl>

</div>
</div>
<a id="a4768777cb8ccb72a401391b4e1cfafdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4768777cb8ccb72a401391b4e1cfafdf">&#9670;&nbsp;</a></span>touch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::touch </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the last access time of the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether last access time of the key has been updated. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists, and last access time has been updated. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/touch">https://redis.io/commands/touch</a> </dd></dl>

</div>
</div>
<a id="a287efe339b95302b65542e83956c45d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287efe339b95302b65542e83956c45d0">&#9670;&nbsp;</a></span>ttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::ttl </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining Time-To-Live of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TTL in seconds. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TTL</td><td>If the key has a timeout. </td></tr>
    <tr><td class="paramname">-1</td><td>If the key exists but does not have a timeout. </td></tr>
    <tr><td class="paramname">-2</td><td>If the key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Redis 2.6 or older, <code>ttl</code> returns -1 if the key does not exist, or if the key exists but does not have a timeout. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ttl">https://redis.io/commands/ttl</a> </dd></dl>

</div>
</div>
<a id="a2f3dfb56bf418bd6e055cbf16cee5416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3dfb56bf418bd6e055cbf16cee5416">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::type </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the value stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/type">https://redis.io/commands/type</a> </dd></dl>

</div>
</div>
<a id="a714bdd65d2dec825c02d6a2ba965058e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714bdd65d2dec825c02d6a2ba965058e">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::unlink </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given key asynchronously, i.e. without blocking Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/unlink">https://redis.io/commands/unlink</a> </dd></dl>

</div>
</div>
<a id="a35f602f3155d2b684d5983d8f94d6840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f602f3155d2b684d5983d8f94d6840">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::wait </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numslaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until previous write commands are successfully replicated to at least the specified number of replicas or the given timeout has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numslaves</td><td>Number of replicas. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. If timeout is 0ms, wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of replicas that have been successfully replicated these write commands. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The return value might be less than <code>numslaves</code>, because timeout has been reached. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/wait">https://redis.io/commands/wait</a> </dd></dl>

</div>
</div>
<a id="a6a5e97f3370f89bc7a3ef413c1607bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5e97f3370f89bc7a3ef413c1607bdb">&#9670;&nbsp;</a></span>zadd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update multiple members with score to sorted set. </p>
<p>Example: </p><div class="fragment"><div class="line">redis.zadd(<span class="stringliteral">&quot;zset&quot;</span>, {std::make_pair(<span class="stringliteral">&quot;m1&quot;</span>, 1.4),</div>
<div class="line">std::make_pair(<span class="stringliteral">&quot;m2&quot;</span>, 2.3)});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first member-score pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the member-score pairs range. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: `auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");<code> @see</code>UpdateType` </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="af8330b95d71d9847abdf9f354486bef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8330b95d71d9847abdf9f354486bef5">&#9670;&nbsp;</a></span>zadd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update a member with score to sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be added. </td></tr>
    <tr><td class="paramname">score</td><td>Score of the member. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: `auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");<code> @see</code>UpdateType` </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="ac920e30fa684392352781dec8761258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac920e30fa684392352781dec8761258a">&#9670;&nbsp;</a></span>zadd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt;&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update multiple members with score to sorted set. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, double&gt; m = {{<span class="stringliteral">&quot;m1&quot;</span>, 1.2}, {<span class="stringliteral">&quot;m2&quot;</span>, 2.3}};</div>
<div class="line">redis.zadd(<span class="stringliteral">&quot;zset&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first member-score pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the member-score pairs range. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: `auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");<code> @see</code>UpdateType` </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="aba94cb28f6dedce8a4234ecbd3cc3551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba94cb28f6dedce8a4234ecbd3cc3551">&#9670;&nbsp;</a></span>zcard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zcard </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members in the sorted set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zcard">https://redis.io/commands/zcard</a> </dd></dl>

</div>
</div>
<a id="a2936db94d0a51bfdcb19f7b4241ebe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2936db94d0a51bfdcb19f7b4241ebe72">&#9670;&nbsp;</a></span>zcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members with score between a min-max score range. </p>
<p>Example: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>The min-max score range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members with score between a min-max score range. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zcount">https://redis.io/commands/zcount</a> </dd></dl>

</div>
</div>
<a id="a9e3b3cac2eb8051bad4ba80cc7aa5b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3b3cac2eb8051bad4ba80cc7aa5b45">&#9670;&nbsp;</a></span>zincrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;double&gt; coro_redis::coro_connection::zincrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the score of given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The score of the member after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zincrby">https://redis.io/commands/zincrby</a> </dd></dl>

</div>
</div>
<a id="a0548a9b98553ec2745a3ed71aaaed8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0548a9b98553ec2745a3ed71aaaed8c1">&#9670;&nbsp;</a></span>zlexcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zlexcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members between a min-max range in lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>The min-max range in lexicographical order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members between a min-max range in lexicographical order. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zlexcount">https://redis.io/commands/zlexcount</a> </dd></dl>

</div>
</div>
<a id="aa8905a8c6af2fc96cd719735d1029c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8905a8c6af2fc96cd719735d1029c72">&#9670;&nbsp;</a></span>zpopmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::zpopmax </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with highest score from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Member-score pair with the highest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty <code>zpopmax</code> returns <code>Optional&lt;std::pair&lt;std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::bzpopmax</code> </dd>
<dd>
<a href="https://redis.io/commands/zpopmax">https://redis.io/commands/zpopmax</a> </dd></dl>

</div>
</div>
<a id="a26a294b7cb8bb15272e9c8131c8545eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a294b7cb8bb15272e9c8131c8545eb">&#9670;&nbsp;</a></span>zpopmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::zpopmin </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with lowest score from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Member-score pair with the lowest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty <code>zpopmin</code> returns <code>Optional&lt;std::pair&lt;std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::bzpopmin</code> </dd>
<dd>
<a href="https://redis.io/commands/zpopmin">https://redis.io/commands/zpopmin</a> </dd></dl>

</div>
</div>
<a id="a7ac5ebaa17a4cb2f3f2b51c01042cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac5ebaa17a4cb2f3f2b51c01042cd34">&#9670;&nbsp;</a></span>zrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::zrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by rank (ordered from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// send *ZRANGE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line">redis.zrange(<span class="stringliteral">&quot;zset&quot;</span>, 0, -1, std::back_inserter(result));</div>
<div class="line"><span class="comment">// send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line">redis.zrange(<span class="stringliteral">&quot;zset&quot;</span>, 0, -1, std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZRANGE key start stop</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZRANGE key start stop WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrevrange</code> </dd>
<dd>
<a href="https://redis.io/commands/zrange">https://redis.io/commands/zrange</a> </dd></dl>

</div>
</div>
<a id="a73d2e5be0963a7bc4675a16165509f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d2e5be0963a7bc4675a16165509f35">&#9670;&nbsp;</a></span>zrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::zrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by lexicographical order (from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members between [abc, abd].</span></div>
<div class="line">redis.zrangebylex(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;std::string&gt;(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;abd&quot;</span>,</div>
<div class="line">BoundType::CLOSED),</div>
<div class="line">    std::back_inserter(result));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<code>Redis::zrevrangebylex</code> </dd>
<dd>
<a href="https://redis.io/commands/zrangebylex">https://redis.io/commands/zrangebylex</a> </dd></dl>

</div>
</div>
<a id="af7076e89beafcc5712dec6b9e6e9aa6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7076e89beafcc5712dec6b9e6e9aa6f">&#9670;&nbsp;</a></span>zrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::vector&lt;std::string&gt; &gt; coro_redis::coro_connection::zrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by score (ordered from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Send *ZRANGEBYSCORE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members whose score between (3, 6).</span></div>
<div class="line">redis.zrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;double&gt;(3, 6,</div>
<div class="line">BoundType::OPEN),</div>
<div class="line">    std::back_inserter(result));</div>
<div class="line"><span class="comment">// Send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line"><span class="comment">// Get members whose score between [3, +inf).</span></div>
<div class="line">redis.zrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, LeftBoundedInterval&lt;double&gt;(3,</div>
<div class="line">BoundType::RIGHT_OPEN),</div>
<div class="line">    std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZRANGEBYSCORE key min max</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZRANGEBYSCORE key min max WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd>
<dd>
See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrevrangebyscore</code> </dd>
<dd>
<a href="https://redis.io/commands/zrangebyscore">https://redis.io/commands/zrangebyscore</a> </dd></dl>

</div>
</div>
<a id="af38c270b3de713a99dc111b0631e385d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38c270b3de713a99dc111b0631e385d">&#9670;&nbsp;</a></span>zrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank (from low to high) of the given member in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the given member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the member does not exist, <code>zrank</code> returns <code>OptionalLongLong{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrank">https://redis.io/commands/zrank</a> </dd></dl>

</div>
</div>
<a id="a1da8ba95df5108160f727084448919a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da8ba95df5108160f727084448919a1">&#9670;&nbsp;</a></span>zrem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zrem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given member from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the member exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the member does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrem">https://redis.io/commands/zrem</a> </dd></dl>

</div>
</div>
<a id="a73c57c4791576c1143564075af693624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c57c4791576c1143564075af693624">&#9670;&nbsp;</a></span>zremrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zremrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range of lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zremrangebylex">https://redis.io/commands/zremrangebylex</a> </dd></dl>

</div>
</div>
<a id="a6ffc1ccce94cd76af298b484fb54566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffc1ccce94cd76af298b484fb54566e">&#9670;&nbsp;</a></span>zremrangebyrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zremrangebyrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range ordered by rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zremrangebyrank">https://redis.io/commands/zremrangebyrank</a> </dd></dl>

</div>
</div>
<a id="a24ba0e38ee1b77b1a91ada8ff9ecb407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ba0e38ee1b77b1a91ada8ff9ecb407">&#9670;&nbsp;</a></span>zremrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zremrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range ordered by score. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zremrangebyscore">https://redis.io/commands/zremrangebyscore</a> </dd></dl>

</div>
</div>
<a id="aa650bae9e9e6e5c14bcef71187391703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa650bae9e9e6e5c14bcef71187391703">&#9670;&nbsp;</a></span>zrevrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::zrevrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withscores</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by rank (ordered from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// send *ZREVRANGE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line">redis.zrevrange(<span class="stringliteral">&quot;key&quot;</span>, 0, -1, std::back_inserter(result));</div>
<div class="line"><span class="comment">// send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line">redis.zrevrange(<span class="stringliteral">&quot;key&quot;</span>, 0, -1, std::inserter(with_score,</div>
<div class="line">with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZREVRANGE key start stop</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZREVRANGE key start stop WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrange</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrange">https://redis.io/commands/zrevrange</a> </dd></dl>

</div>
</div>
<a id="adec71d7f8217c987a74ad81bcd6eeb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec71d7f8217c987a74ad81bcd6eeb02">&#9670;&nbsp;</a></span>zrevrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::zrevrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by lexicographical order (from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members between [abc, abd] in reverse order.</span></div>
<div class="line">redis.zrevrangebylex(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;std::string&gt;(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;abd&quot;</span>,</div>
<div class="line">BoundType::CLOSED),</div>
<div class="line">    std::back_inserter(result));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<code>Redis::zrangebylex</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrangebylex">https://redis.io/commands/zrevrangebylex</a> </dd></dl>

</div>
</div>
<a id="a0c8b9d13aa5b759b17a7e46df62ed5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8b9d13aa5b759b17a7e46df62ed5c9">&#9670;&nbsp;</a></span>zrevrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;std::string&gt; coro_redis::coro_connection::zrevrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by score (ordered from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Send *ZREVRANGEBYSCORE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members whose score between (3, 6) in reverse order.</span></div>
<div class="line">redis.zrevrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;double&gt;(3, 6,</div>
<div class="line">BoundType::OPEN),</div>
<div class="line">    std::back_inserter(result));</div>
<div class="line"><span class="comment">// Send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line"><span class="comment">// Get members whose score between [3, +inf) in reverse order.</span></div>
<div class="line">redis.zrevrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, LeftBoundedInterval&lt;double&gt;(3,</div>
<div class="line">BoundType::RIGHT_OPEN),</div>
<div class="line">    std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZREVRANGEBYSCORE key min max</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZREVRANGEBYSCORE key min max WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd>
<dd>
See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrangebyscore</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrangebyscore">https://redis.io/commands/zrevrangebyscore</a> </dd></dl>

</div>
</div>
<a id="ab6a5b8df67eddf6d3ec528ae23d5ddcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a5b8df67eddf6d3ec528ae23d5ddcd">&#9670;&nbsp;</a></span>zrevrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zrevrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank (from high to low) of the given member in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the given member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the member does not exist, <code>zrevrank</code> returns <code>OptionalLongLong{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrevrank">https://redis.io/commands/zrevrank</a> </dd></dl>

</div>
</div>
<a id="ae696ee1711f3588320f05ab470f9da15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae696ee1711f3588320f05ab470f9da15">&#9670;&nbsp;</a></span>zscan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;scan_ret_t&gt; coro_redis::coro_connection::zscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan all members of the given sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscan">https://redis.io/commands/zscan</a> </dd></dl>

</div>
</div>
<a id="acc4e4b19aa5b53ffd29316a897536ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4e4b19aa5b53ffd29316a897536ef9">&#9670;&nbsp;</a></span>zscan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan all members of the given sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many members to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscan">https://redis.io/commands/zscan</a> </dd></dl>

</div>
</div>
<a id="ad75d4fd3672e7a5b8cecbe13459c52f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75d4fd3672e7a5b8cecbe13459c52f7">&#9670;&nbsp;</a></span>zscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;double&gt; coro_redis::coro_connection::zscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the score of the given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The score of the member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If member does not exist, <code>zscore</code> returns <code>OptionalDouble{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscore">https://redis.io/commands/zscore</a> </dd></dl>

</div>
</div>
<a id="a4fcf904bf29cfe29cf71535d869f5211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcf904bf29cfe29cf71535d869f5211">&#9670;&nbsp;</a></span>zunionstore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>aggregate</em> = <code>&quot;SUM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sorted set to another one with the scores being multiplied by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination sorted set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source sorted set. </td></tr>
    <tr><td class="paramname">weight</td><td>Weight to be multiplied to the score of each member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of members in the sorted set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There's no aggregation type parameter for single key overload, since these 3 types have the same effect. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zinterstore</code> </dd>
<dd>
<a href="https://redis.io/commands/zinterstore">https://redis.io/commands/zinterstore</a> </dd></dl>

</div>
</div>
<a id="a13ed0b810a6ddd6b144c9627c12eaba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ed0b810a6ddd6b144c9627c12eaba0">&#9670;&nbsp;</a></span>zunionstore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">awaiter_t&lt;uint64_t&gt; coro_redis::coro_connection::zunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt;&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>aggregate</em> = <code>&quot;SUM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get union of multiple sorted sets, and store the result to another one. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Use the default weight, i.e. 1,</span></div>
<div class="line"><span class="comment">// and use the sum of the all scores as the score of the result:</span></div>
<div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;k3&quot;</span>};</div>
<div class="line">redis.zunionstore(<span class="stringliteral">&quot;destination&quot;</span>, keys.begin(), keys.end());</div>
<div class="line"><span class="comment">// Each sorted set has a different weight,</span></div>
<div class="line"><span class="comment">// and the score of the result is the min of all scores.</span></div>
<div class="line">std::vector&lt;std::pair&lt;std::string, double&gt;&gt; keys_with_weights = {{<span class="stringliteral">&quot;k1&quot;</span>,</div>
<div class="line">1}, {<span class="stringliteral">&quot;k2&quot;</span>, 2}}; redis.zunionstore(<span class="stringliteral">&quot;destination&quot;</span>,</div>
<div class="line">keys_with_weights.begin(),</div>
<div class="line">    keys_with_weights.end(), Aggregation::MIN);</div>
<div class="line"><span class="comment">// NOTE: `keys_with_weights` can also be of type</span></div>
<div class="line">`std::unordered_map&lt;std::string, double&gt;`.</div>
<div class="line"><span class="comment">// However, it will be slower than std::vector&lt;std::pair&lt;std::string,</span></div>
<div class="line">double&gt;&gt;, since we use</div>
<div class="line"><span class="comment">// `std::distance(first, last)` to calculate the *numkeys* parameter.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination sorted set. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first sorted set (might with weight). </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the sorted set range. </td></tr>
    <tr><td class="paramname">type</td><td>How the scores are aggregated.<ul>
<li>Aggregation::SUM: Score of a member is the sum of all scores.</li>
<li>Aggregation::MIN: Score of a member is the min of all scores.</li>
<li>Aggregation::MAX: Score of a member is the max of all scores. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of members in the resulting sorted set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The score of each member can be multiplied by a factor, i.e. weight. If <code>Input</code> is an iterator to a container of <code>std::string</code>, we use the default weight, i.e. 1, and send <em>ZUNIONSTORE dest numkeys key [key ...] [AGGREGATE SUM|MIN|MAX]</em> command. If <code>Input</code> is an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, i.e. key-weight pair, we send the command with the given weights: <em>ZUNIONSTORE dest numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</em>. See the <em>Example</em> part for examples on how to use this command. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zinterstore</code> </dd>
<dd>
<a href="https://redis.io/commands/zunionstore">https://redis.io/commands/zunionstore</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/coro_redis/<a class="el" href="coro__connection_8hpp_source.html">coro_connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
