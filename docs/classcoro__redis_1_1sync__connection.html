<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coro_redis: coro_redis::sync_connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coro_redis
   &#160;<span id="projectnumber">1.0.0.0</span>
   </div>
   <div id="projectbrief">C++ Corotine Redis Client</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>coro_redis</b></li><li class="navelem"><a class="el" href="classcoro__redis_1_1sync__connection.html">sync_connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcoro__redis_1_1sync__connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">coro_redis::sync_connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Synchronous connection.  
 <a href="classcoro__redis_1_1sync__connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sync__connection_8hpp_source.html">sync_connection.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a96c0fed68600d7c174365bba3a3b6919"><td class="memItemLeft" align="right" valign="top"><a id="a96c0fed68600d7c174365bba3a3b6919"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BitOp</b> { <b>AND</b>, 
<b>OR</b>, 
<b>XOR</b>, 
<b>NOT</b>
 }</td></tr>
<tr class="separator:a96c0fed68600d7c174365bba3a3b6919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d91e21ad2fb5478646a577e64cc242c"><td class="memItemLeft" align="right" valign="top"><a id="a5d91e21ad2fb5478646a577e64cc242c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cptr</b> = std::shared_ptr&lt; <a class="el" href="classcoro__redis_1_1sync__connection.html">sync_connection</a> &gt;</td></tr>
<tr class="separator:a5d91e21ad2fb5478646a577e64cc242c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6999468f63dea283ee5fbc6a9e7b761"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab6999468f63dea283ee5fbc6a9e7b761">sync_connection</a> (redisContext *ctx)</td></tr>
<tr class="memdesc:ab6999468f63dea283ee5fbc6a9e7b761"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction  <a href="classcoro__redis_1_1sync__connection.html#ab6999468f63dea283ee5fbc6a9e7b761">More...</a><br /></td></tr>
<tr class="separator:ab6999468f63dea283ee5fbc6a9e7b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6078321046f4ce076587402ddf3789"><td class="memTemplParams" colspan="2">template&lt;typename RET  = std::string&gt; </td></tr>
<tr class="memitem:a0d6078321046f4ce076587402ddf3789"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0d6078321046f4ce076587402ddf3789">command</a> (std::string_view cmd) const</td></tr>
<tr class="memdesc:a0d6078321046f4ce076587402ddf3789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send redis command.  <a href="classcoro__redis_1_1sync__connection.html#a0d6078321046f4ce076587402ddf3789">More...</a><br /></td></tr>
<tr class="separator:a0d6078321046f4ce076587402ddf3789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae861eaa99554048ffc4fbf15e4f3c009"><td class="memTemplParams" colspan="2"><a id="ae861eaa99554048ffc4fbf15e4f3c009"></a>
template&lt;typename RET  = std::string&gt; </td></tr>
<tr class="memitem:ae861eaa99554048ffc4fbf15e4f3c009"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>command</b> (std::string_view cmd, std::function&lt; void(redisReply *)&gt; op) const</td></tr>
<tr class="separator:ae861eaa99554048ffc4fbf15e4f3c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3c9608703080731f6446a48a0843c3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a2b3c9608703080731f6446a48a0843c3">auth</a> (std::string_view password)</td></tr>
<tr class="memdesc:a2b3c9608703080731f6446a48a0843c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send password to Redis.  <a href="classcoro__redis_1_1sync__connection.html#a2b3c9608703080731f6446a48a0843c3">More...</a><br /></td></tr>
<tr class="separator:a2b3c9608703080731f6446a48a0843c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b48c81b338e387ade29474c0e3d7f9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac5b48c81b338e387ade29474c0e3d7f9">auth</a> (std::string_view user, std::string_view password)</td></tr>
<tr class="memdesc:ac5b48c81b338e387ade29474c0e3d7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send user and password to Redis.  <a href="classcoro__redis_1_1sync__connection.html#ac5b48c81b338e387ade29474c0e3d7f9">More...</a><br /></td></tr>
<tr class="separator:ac5b48c81b338e387ade29474c0e3d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60f83377e08d6d19efc70ccce31877e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab60f83377e08d6d19efc70ccce31877e">echo</a> (std::string_view msg) const</td></tr>
<tr class="memdesc:ab60f83377e08d6d19efc70ccce31877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask Redis to return the given message.  <a href="classcoro__redis_1_1sync__connection.html#ab60f83377e08d6d19efc70ccce31877e">More...</a><br /></td></tr>
<tr class="separator:ab60f83377e08d6d19efc70ccce31877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaad69eb23ad0decead6f30aeb2847ac"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#acaad69eb23ad0decead6f30aeb2847ac">ping</a> ()</td></tr>
<tr class="memdesc:acaad69eb23ad0decead6f30aeb2847ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connection is alive.  <a href="classcoro__redis_1_1sync__connection.html#acaad69eb23ad0decead6f30aeb2847ac">More...</a><br /></td></tr>
<tr class="separator:acaad69eb23ad0decead6f30aeb2847ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad338e0e6956388ffb70105417ba09ef2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ad338e0e6956388ffb70105417ba09ef2">ping</a> (std::string_view msg)</td></tr>
<tr class="memdesc:ad338e0e6956388ffb70105417ba09ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connection is alive.  <a href="classcoro__redis_1_1sync__connection.html#ad338e0e6956388ffb70105417ba09ef2">More...</a><br /></td></tr>
<tr class="separator:ad338e0e6956388ffb70105417ba09ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4783c929f1efd8371d0801e0e2ba40"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a7b4783c929f1efd8371d0801e0e2ba40">quit</a> ()</td></tr>
<tr class="memdesc:a7b4783c929f1efd8371d0801e0e2ba40"><td class="mdescLeft">&#160;</td><td class="mdescRight">After sending QUIT, only the current connection will be close, while other connections in the pool is still open.  <a href="classcoro__redis_1_1sync__connection.html#a7b4783c929f1efd8371d0801e0e2ba40">More...</a><br /></td></tr>
<tr class="separator:a7b4783c929f1efd8371d0801e0e2ba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e0688b6734eec25e2fb63ea3a94464"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a52e0688b6734eec25e2fb63ea3a94464">select</a> (uint64_t idx)</td></tr>
<tr class="memdesc:a52e0688b6734eec25e2fb63ea3a94464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the Redis logical database.  <a href="classcoro__redis_1_1sync__connection.html#a52e0688b6734eec25e2fb63ea3a94464">More...</a><br /></td></tr>
<tr class="separator:a52e0688b6734eec25e2fb63ea3a94464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19929d3c807a31bc2ebd7de4f9f57e6a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a19929d3c807a31bc2ebd7de4f9f57e6a">swapdb</a> (uint64_t idx1, uint64_t idx2)</td></tr>
<tr class="memdesc:a19929d3c807a31bc2ebd7de4f9f57e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two Redis databases.  <a href="classcoro__redis_1_1sync__connection.html#a19929d3c807a31bc2ebd7de4f9f57e6a">More...</a><br /></td></tr>
<tr class="separator:a19929d3c807a31bc2ebd7de4f9f57e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea0ac75d862c81071fdbcc29c9a6bbd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#adea0ac75d862c81071fdbcc29c9a6bbd">bgrewriteaof</a> ()</td></tr>
<tr class="memdesc:adea0ac75d862c81071fdbcc29c9a6bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite AOF in the background.  <a href="classcoro__redis_1_1sync__connection.html#adea0ac75d862c81071fdbcc29c9a6bbd">More...</a><br /></td></tr>
<tr class="separator:adea0ac75d862c81071fdbcc29c9a6bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6520df97e2c74a08c721a9b7ee1cc5c2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a6520df97e2c74a08c721a9b7ee1cc5c2">bgsave</a> ()</td></tr>
<tr class="memdesc:a6520df97e2c74a08c721a9b7ee1cc5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save database in the background.  <a href="classcoro__redis_1_1sync__connection.html#a6520df97e2c74a08c721a9b7ee1cc5c2">More...</a><br /></td></tr>
<tr class="separator:a6520df97e2c74a08c721a9b7ee1cc5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ba922d77d84750e7221f8cdbaba200"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a98ba922d77d84750e7221f8cdbaba200">dbsize</a> ()</td></tr>
<tr class="memdesc:a98ba922d77d84750e7221f8cdbaba200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the currently selected database.  <a href="classcoro__redis_1_1sync__connection.html#a98ba922d77d84750e7221f8cdbaba200">More...</a><br /></td></tr>
<tr class="separator:a98ba922d77d84750e7221f8cdbaba200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ff504bf9cdbce9fc6803e5eb2be09"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a973ff504bf9cdbce9fc6803e5eb2be09">flushall</a> (bool async=false)</td></tr>
<tr class="memdesc:a973ff504bf9cdbce9fc6803e5eb2be09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys of all databases.  <a href="classcoro__redis_1_1sync__connection.html#a973ff504bf9cdbce9fc6803e5eb2be09">More...</a><br /></td></tr>
<tr class="separator:a973ff504bf9cdbce9fc6803e5eb2be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037aa2182aeb4c0e082e0ac752e2ac66"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a037aa2182aeb4c0e082e0ac752e2ac66">flushdb</a> (bool async=false)</td></tr>
<tr class="memdesc:a037aa2182aeb4c0e082e0ac752e2ac66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys of current databases.  <a href="classcoro__redis_1_1sync__connection.html#a037aa2182aeb4c0e082e0ac752e2ac66">More...</a><br /></td></tr>
<tr class="separator:a037aa2182aeb4c0e082e0ac752e2ac66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f3d259a618a14cc0f97432d45b35ff"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a15f3d259a618a14cc0f97432d45b35ff">info</a> ()</td></tr>
<tr class="memdesc:a15f3d259a618a14cc0f97432d45b35ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the info about the server.  <a href="classcoro__redis_1_1sync__connection.html#a15f3d259a618a14cc0f97432d45b35ff">More...</a><br /></td></tr>
<tr class="separator:a15f3d259a618a14cc0f97432d45b35ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b9752eff75871735b1e7347e934ca9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a78b9752eff75871735b1e7347e934ca9">info</a> (std::string_view section)</td></tr>
<tr class="memdesc:a78b9752eff75871735b1e7347e934ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the info about the server on the given section.  <a href="classcoro__redis_1_1sync__connection.html#a78b9752eff75871735b1e7347e934ca9">More...</a><br /></td></tr>
<tr class="separator:a78b9752eff75871735b1e7347e934ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff798e3a7e1d0781db31cc5933fdc2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a63ff798e3a7e1d0781db31cc5933fdc2">lastsave</a> ()</td></tr>
<tr class="memdesc:a63ff798e3a7e1d0781db31cc5933fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UNIX timestamp in seconds, at which the database was saved successfully.  <a href="classcoro__redis_1_1sync__connection.html#a63ff798e3a7e1d0781db31cc5933fdc2">More...</a><br /></td></tr>
<tr class="separator:a63ff798e3a7e1d0781db31cc5933fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366897d89451850b1215558b11f960e5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a366897d89451850b1215558b11f960e5">save</a> ()</td></tr>
<tr class="memdesc:a366897d89451850b1215558b11f960e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save databases into RDB file <b>synchronously</b>, i.e. block the server during saving.  <a href="classcoro__redis_1_1sync__connection.html#a366897d89451850b1215558b11f960e5">More...</a><br /></td></tr>
<tr class="separator:a366897d89451850b1215558b11f960e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6958edf56899de74bf7a39b1fe76266e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6958edf56899de74bf7a39b1fe76266e"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a6958edf56899de74bf7a39b1fe76266e">del</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a6958edf56899de74bf7a39b1fe76266e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given key.  <a href="classcoro__redis_1_1sync__connection.html#a6958edf56899de74bf7a39b1fe76266e">More...</a><br /></td></tr>
<tr class="separator:a6958edf56899de74bf7a39b1fe76266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd679d7509ead19c13dc3b11350ee999"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#abd679d7509ead19c13dc3b11350ee999">dump</a> (std::string_view key)</td></tr>
<tr class="memdesc:abd679d7509ead19c13dc3b11350ee999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serialized valued stored at key.  <a href="classcoro__redis_1_1sync__connection.html#abd679d7509ead19c13dc3b11350ee999">More...</a><br /></td></tr>
<tr class="separator:abd679d7509ead19c13dc3b11350ee999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca67a0491696d2471a9de349b71cc024"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aca67a0491696d2471a9de349b71cc024"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aca67a0491696d2471a9de349b71cc024">exists</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aca67a0491696d2471a9de349b71cc024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given key exists.  <a href="classcoro__redis_1_1sync__connection.html#aca67a0491696d2471a9de349b71cc024">More...</a><br /></td></tr>
<tr class="separator:aca67a0491696d2471a9de349b71cc024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c88ed5172f72a22b6525da2df83d82"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a38c88ed5172f72a22b6525da2df83d82">expire</a> (std::string_view key, uint64_t timeout)</td></tr>
<tr class="memdesc:a38c88ed5172f72a22b6525da2df83d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key.  <a href="classcoro__redis_1_1sync__connection.html#a38c88ed5172f72a22b6525da2df83d82">More...</a><br /></td></tr>
<tr class="separator:a38c88ed5172f72a22b6525da2df83d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7c34efe7c827b0fd29a8958b257c33"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aed7c34efe7c827b0fd29a8958b257c33">expireat</a> (std::string_view key, uint64_t timestamp)</td></tr>
<tr class="memdesc:aed7c34efe7c827b0fd29a8958b257c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key, i.e. expire the key at a future time point.  <a href="classcoro__redis_1_1sync__connection.html#aed7c34efe7c827b0fd29a8958b257c33">More...</a><br /></td></tr>
<tr class="separator:aed7c34efe7c827b0fd29a8958b257c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76343bfb5e24a0b78a590c3fba4e8eee"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a76343bfb5e24a0b78a590c3fba4e8eee">move</a> (std::string_view key, uint64_t db)</td></tr>
<tr class="memdesc:a76343bfb5e24a0b78a590c3fba4e8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get keys matching the given pattern.  <a href="classcoro__redis_1_1sync__connection.html#a76343bfb5e24a0b78a590c3fba4e8eee">More...</a><br /></td></tr>
<tr class="separator:a76343bfb5e24a0b78a590c3fba4e8eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da5a6f69128f110d67ca6bc4eb3bd07"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a8da5a6f69128f110d67ca6bc4eb3bd07">persist</a> (std::string_view key)</td></tr>
<tr class="memdesc:a8da5a6f69128f110d67ca6bc4eb3bd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove timeout on key.  <a href="classcoro__redis_1_1sync__connection.html#a8da5a6f69128f110d67ca6bc4eb3bd07">More...</a><br /></td></tr>
<tr class="separator:a8da5a6f69128f110d67ca6bc4eb3bd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14ae1d238744081a1570e676256a2e8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aa14ae1d238744081a1570e676256a2e8">pexpire</a> (std::string_view key, uint64_t timeout)</td></tr>
<tr class="memdesc:aa14ae1d238744081a1570e676256a2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key.  <a href="classcoro__redis_1_1sync__connection.html#aa14ae1d238744081a1570e676256a2e8">More...</a><br /></td></tr>
<tr class="separator:aa14ae1d238744081a1570e676256a2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716f4fdca8272a6ffd38c57fedb1088"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a5716f4fdca8272a6ffd38c57fedb1088">pexpireat</a> (std::string_view key, uint64_t timestamp)</td></tr>
<tr class="memdesc:a5716f4fdca8272a6ffd38c57fedb1088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on key, i.e. expire the key at a future time point.  <a href="classcoro__redis_1_1sync__connection.html#a5716f4fdca8272a6ffd38c57fedb1088">More...</a><br /></td></tr>
<tr class="separator:a5716f4fdca8272a6ffd38c57fedb1088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9411f4841c7b1e54b10ff1c3a0d218"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#afc9411f4841c7b1e54b10ff1c3a0d218">pttl</a> (std::string_view key)</td></tr>
<tr class="memdesc:afc9411f4841c7b1e54b10ff1c3a0d218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TTL of a key in milliseconds.  <a href="classcoro__redis_1_1sync__connection.html#afc9411f4841c7b1e54b10ff1c3a0d218">More...</a><br /></td></tr>
<tr class="separator:afc9411f4841c7b1e54b10ff1c3a0d218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b596fd668b7cdfb2d2cf24bca37e97"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a00b596fd668b7cdfb2d2cf24bca37e97">randomkey</a> ()</td></tr>
<tr class="memdesc:a00b596fd668b7cdfb2d2cf24bca37e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random key from current database.  <a href="classcoro__redis_1_1sync__connection.html#a00b596fd668b7cdfb2d2cf24bca37e97">More...</a><br /></td></tr>
<tr class="separator:a00b596fd668b7cdfb2d2cf24bca37e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6550563bb98bc89e95576881aa46c151"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a6550563bb98bc89e95576881aa46c151">rename</a> (std::string_view key, std::string_view newkey)</td></tr>
<tr class="memdesc:a6550563bb98bc89e95576881aa46c151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>key</code> to <code>newkey</code>.  <a href="classcoro__redis_1_1sync__connection.html#a6550563bb98bc89e95576881aa46c151">More...</a><br /></td></tr>
<tr class="separator:a6550563bb98bc89e95576881aa46c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b8fdfe64e266e2d5d71690bc58365"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab09b8fdfe64e266e2d5d71690bc58365">renamenx</a> (std::string_view key, std::string_view newkey)</td></tr>
<tr class="memdesc:ab09b8fdfe64e266e2d5d71690bc58365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>key</code> to <code>newkey</code> if <code>newkey</code> does not exist.  <a href="classcoro__redis_1_1sync__connection.html#ab09b8fdfe64e266e2d5d71690bc58365">More...</a><br /></td></tr>
<tr class="separator:ab09b8fdfe64e266e2d5d71690bc58365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a67ef541e7f9af72f65660d8cc0ae6b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a7a67ef541e7f9af72f65660d8cc0ae6b">restore</a> (std::string_view key, std::string_view val, uint64_t <a class="el" href="classcoro__redis_1_1sync__connection.html#a6eae6cadf59a057457b3601d884de117">ttl</a>, bool replace=false)</td></tr>
<tr class="memdesc:a7a67ef541e7f9af72f65660d8cc0ae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key with the value obtained by <code>Redis::dump</code>.  <a href="classcoro__redis_1_1sync__connection.html#a7a67ef541e7f9af72f65660d8cc0ae6b">More...</a><br /></td></tr>
<tr class="separator:a7a67ef541e7f9af72f65660d8cc0ae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac030b5b0963467561bc6bb04dd5ef794"><td class="memItemLeft" align="right" valign="top">std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac030b5b0963467561bc6bb04dd5ef794">scan</a> (uint64_t cursor, uint64_t count=0)</td></tr>
<tr class="memdesc:ac030b5b0963467561bc6bb04dd5ef794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan keys of the database matching the given pattern.  <a href="classcoro__redis_1_1sync__connection.html#ac030b5b0963467561bc6bb04dd5ef794">More...</a><br /></td></tr>
<tr class="separator:ac030b5b0963467561bc6bb04dd5ef794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7143189fd9c3ba5ac87c817e07e9144"><td class="memItemLeft" align="right" valign="top"><a id="aa7143189fd9c3ba5ac87c817e07e9144"></a>
std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scan</b> (uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="separator:aa7143189fd9c3ba5ac87c817e07e9144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c452c37db380cf791bd69f5ee32642"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac7c452c37db380cf791bd69f5ee32642"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac7c452c37db380cf791bd69f5ee32642">touch</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:ac7c452c37db380cf791bd69f5ee32642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the last access time of the given key.  <a href="classcoro__redis_1_1sync__connection.html#ac7c452c37db380cf791bd69f5ee32642">More...</a><br /></td></tr>
<tr class="separator:ac7c452c37db380cf791bd69f5ee32642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eae6cadf59a057457b3601d884de117"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a6eae6cadf59a057457b3601d884de117">ttl</a> (std::string_view key)</td></tr>
<tr class="memdesc:a6eae6cadf59a057457b3601d884de117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining Time-To-Live of a key.  <a href="classcoro__redis_1_1sync__connection.html#a6eae6cadf59a057457b3601d884de117">More...</a><br /></td></tr>
<tr class="separator:a6eae6cadf59a057457b3601d884de117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5632e80e4f17fce42def24e72683f749"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a5632e80e4f17fce42def24e72683f749">type</a> (std::string_view key)</td></tr>
<tr class="memdesc:a5632e80e4f17fce42def24e72683f749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the value stored at key.  <a href="classcoro__redis_1_1sync__connection.html#a5632e80e4f17fce42def24e72683f749">More...</a><br /></td></tr>
<tr class="separator:a5632e80e4f17fce42def24e72683f749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713392dcd6524ad1c51631791d3fc86f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a713392dcd6524ad1c51631791d3fc86f"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a713392dcd6524ad1c51631791d3fc86f">unlink</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a713392dcd6524ad1c51631791d3fc86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given key asynchronously, i.e. without blocking Redis.  <a href="classcoro__redis_1_1sync__connection.html#a713392dcd6524ad1c51631791d3fc86f">More...</a><br /></td></tr>
<tr class="separator:a713392dcd6524ad1c51631791d3fc86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0af3d04793664999ab17407fdb93582"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af0af3d04793664999ab17407fdb93582">wait</a> (uint64_t numslaves, uint64_t timeout)</td></tr>
<tr class="memdesc:af0af3d04793664999ab17407fdb93582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until previous write commands are successfully replicated to at least the specified number of replicas or the given timeout has been reached.  <a href="classcoro__redis_1_1sync__connection.html#af0af3d04793664999ab17407fdb93582">More...</a><br /></td></tr>
<tr class="separator:af0af3d04793664999ab17407fdb93582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace61b8c6282d972a93d37168514a67df"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ace61b8c6282d972a93d37168514a67df">append</a> (std::string_view key, std::string_view str)</td></tr>
<tr class="memdesc:ace61b8c6282d972a93d37168514a67df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the given string to the string stored at key.  <a href="classcoro__redis_1_1sync__connection.html#ace61b8c6282d972a93d37168514a67df">More...</a><br /></td></tr>
<tr class="separator:ace61b8c6282d972a93d37168514a67df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f9e0b894e8a37e15f9302e1edebed9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac1f9e0b894e8a37e15f9302e1edebed9">bitcount</a> (std::string_view key, uint64_t start=0, uint64_t end=-1)</td></tr>
<tr class="memdesc:ac1f9e0b894e8a37e15f9302e1edebed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits that have been set for the given range of the string.  <a href="classcoro__redis_1_1sync__connection.html#ac1f9e0b894e8a37e15f9302e1edebed9">More...</a><br /></td></tr>
<tr class="separator:ac1f9e0b894e8a37e15f9302e1edebed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f3c9b81819ebec0917c40b7dad423e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab6f3c9b81819ebec0917c40b7dad423e"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab6f3c9b81819ebec0917c40b7dad423e">bitop</a> (BitOp op, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:ab6f3c9b81819ebec0917c40b7dad423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do bit operation on the string stored at <code>key</code>, and save the result to <code>destination</code>.  <a href="classcoro__redis_1_1sync__connection.html#ab6f3c9b81819ebec0917c40b7dad423e">More...</a><br /></td></tr>
<tr class="separator:ab6f3c9b81819ebec0917c40b7dad423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1453868a3ac84ed492dea113ca32d1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#afc1453868a3ac84ed492dea113ca32d1">bitpos</a> (std::string_view key, uint64_t bit, uint64_t start=0, uint64_t end=-1)</td></tr>
<tr class="memdesc:afc1453868a3ac84ed492dea113ca32d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the first bit set to 0 or 1 in the given range of the string.  <a href="classcoro__redis_1_1sync__connection.html#afc1453868a3ac84ed492dea113ca32d1">More...</a><br /></td></tr>
<tr class="separator:afc1453868a3ac84ed492dea113ca32d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca18e4e7a5b149fa7d0ee04011c9f2e8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aca18e4e7a5b149fa7d0ee04011c9f2e8">decr</a> (std::string_view key)</td></tr>
<tr class="memdesc:aca18e4e7a5b149fa7d0ee04011c9f2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the integer stored at key by 1.  <a href="classcoro__redis_1_1sync__connection.html#aca18e4e7a5b149fa7d0ee04011c9f2e8">More...</a><br /></td></tr>
<tr class="separator:aca18e4e7a5b149fa7d0ee04011c9f2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dc95b15bdcc11e46d898cc37f11091"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a50dc95b15bdcc11e46d898cc37f11091">decrby</a> (std::string_view key, uint64_t decrement)</td></tr>
<tr class="memdesc:a50dc95b15bdcc11e46d898cc37f11091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the integer stored at key by <code>decrement</code>.  <a href="classcoro__redis_1_1sync__connection.html#a50dc95b15bdcc11e46d898cc37f11091">More...</a><br /></td></tr>
<tr class="separator:a50dc95b15bdcc11e46d898cc37f11091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba79e76ddf7e6b596e8ac8ee851e179"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a7ba79e76ddf7e6b596e8ac8ee851e179">get</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a7ba79e76ddf7e6b596e8ac8ee851e179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string value stored at key.  <a href="classcoro__redis_1_1sync__connection.html#a7ba79e76ddf7e6b596e8ac8ee851e179">More...</a><br /></td></tr>
<tr class="separator:a7ba79e76ddf7e6b596e8ac8ee851e179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1e0d8f97fb1a182f273a476be38806"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0a1e0d8f97fb1a182f273a476be38806">getbit</a> (std::string_view key, uint64_t offset)</td></tr>
<tr class="memdesc:a0a1e0d8f97fb1a182f273a476be38806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit value at offset in the string.  <a href="classcoro__redis_1_1sync__connection.html#a0a1e0d8f97fb1a182f273a476be38806">More...</a><br /></td></tr>
<tr class="separator:a0a1e0d8f97fb1a182f273a476be38806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9517179ee4fc2ff9b26e665816657800"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a9517179ee4fc2ff9b26e665816657800">getrange</a> (std::string_view key, uint64_t start, uint64_t end)</td></tr>
<tr class="memdesc:a9517179ee4fc2ff9b26e665816657800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring of the string stored at key.  <a href="classcoro__redis_1_1sync__connection.html#a9517179ee4fc2ff9b26e665816657800">More...</a><br /></td></tr>
<tr class="separator:a9517179ee4fc2ff9b26e665816657800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9247fcacc8c06c585c179a1eba4319"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3b9247fcacc8c06c585c179a1eba4319">getset</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a3b9247fcacc8c06c585c179a1eba4319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically set the string stored at <code>key</code> to <code>val</code>, and return the old value.  <a href="classcoro__redis_1_1sync__connection.html#a3b9247fcacc8c06c585c179a1eba4319">More...</a><br /></td></tr>
<tr class="separator:a3b9247fcacc8c06c585c179a1eba4319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b8451c9097f69bf3f2892cf0c7c834"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ae7b8451c9097f69bf3f2892cf0c7c834">incr</a> (std::string_view key)</td></tr>
<tr class="memdesc:ae7b8451c9097f69bf3f2892cf0c7c834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at key by 1.  <a href="classcoro__redis_1_1sync__connection.html#ae7b8451c9097f69bf3f2892cf0c7c834">More...</a><br /></td></tr>
<tr class="separator:ae7b8451c9097f69bf3f2892cf0c7c834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8ac3675f56b6fbb4a2089f2fccdcb3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a9e8ac3675f56b6fbb4a2089f2fccdcb3">incrby</a> (std::string_view key, uint64_t increment)</td></tr>
<tr class="memdesc:a9e8ac3675f56b6fbb4a2089f2fccdcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at key by <code>increment</code>.  <a href="classcoro__redis_1_1sync__connection.html#a9e8ac3675f56b6fbb4a2089f2fccdcb3">More...</a><br /></td></tr>
<tr class="separator:a9e8ac3675f56b6fbb4a2089f2fccdcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af712313772bdd6ebcfe5de0114b6aee7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af712313772bdd6ebcfe5de0114b6aee7">incrbyfloat</a> (std::string_view key, double increment)</td></tr>
<tr class="memdesc:af712313772bdd6ebcfe5de0114b6aee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the floating point number stored at key by <code>increment</code>.  <a href="classcoro__redis_1_1sync__connection.html#af712313772bdd6ebcfe5de0114b6aee7">More...</a><br /></td></tr>
<tr class="separator:af712313772bdd6ebcfe5de0114b6aee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0139d41f5aba914e7d82bff8f8889c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9a0139d41f5aba914e7d82bff8f8889c"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a9a0139d41f5aba914e7d82bff8f8889c">mget</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a9a0139d41f5aba914e7d82bff8f8889c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of multiple keys atomically.  <a href="classcoro__redis_1_1sync__connection.html#a9a0139d41f5aba914e7d82bff8f8889c">More...</a><br /></td></tr>
<tr class="separator:a9a0139d41f5aba914e7d82bff8f8889c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2550cd1e6ecf4375e0b84c2fdb1b5f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aec2550cd1e6ecf4375e0b84c2fdb1b5f"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aec2550cd1e6ecf4375e0b84c2fdb1b5f">mset</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:aec2550cd1e6ecf4375e0b84c2fdb1b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple key-value pairs.  <a href="classcoro__redis_1_1sync__connection.html#aec2550cd1e6ecf4375e0b84c2fdb1b5f">More...</a><br /></td></tr>
<tr class="separator:aec2550cd1e6ecf4375e0b84c2fdb1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a6b432cc9a913e8d4925e56dc5e15f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af6a6b432cc9a913e8d4925e56dc5e15f"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af6a6b432cc9a913e8d4925e56dc5e15f">msetnx</a> (Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:af6a6b432cc9a913e8d4925e56dc5e15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given key-value pairs if all specified keys do not exist.  <a href="classcoro__redis_1_1sync__connection.html#af6a6b432cc9a913e8d4925e56dc5e15f">More...</a><br /></td></tr>
<tr class="separator:af6a6b432cc9a913e8d4925e56dc5e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d5e52a622b6f8f01c47910f20daa65"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a57d5e52a622b6f8f01c47910f20daa65">psetex</a> (std::string_view key, uint64_t <a class="el" href="classcoro__redis_1_1sync__connection.html#a6eae6cadf59a057457b3601d884de117">ttl</a>, std::string_view val)</td></tr>
<tr class="memdesc:a57d5e52a622b6f8f01c47910f20daa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key-value pair with the given timeout in milliseconds.  <a href="classcoro__redis_1_1sync__connection.html#a57d5e52a622b6f8f01c47910f20daa65">More...</a><br /></td></tr>
<tr class="separator:a57d5e52a622b6f8f01c47910f20daa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7ddd32b687869d59a1f5099ced4ee1"><td class="memTemplParams" colspan="2">template&lt;RedisSetValueType T&gt; </td></tr>
<tr class="memitem:a4e7ddd32b687869d59a1f5099ced4ee1"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a4e7ddd32b687869d59a1f5099ced4ee1">set</a> (std::string_view key, T val, uint64_t <a class="el" href="classcoro__redis_1_1sync__connection.html#a6eae6cadf59a057457b3601d884de117">ttl</a>=0, RedisTTLType ttl_type=RedisTTLType::EX, UpdateType <a class="el" href="classcoro__redis_1_1sync__connection.html#a5632e80e4f17fce42def24e72683f749">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:a4e7ddd32b687869d59a1f5099ced4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a key-value pair.  <a href="classcoro__redis_1_1sync__connection.html#a4e7ddd32b687869d59a1f5099ced4ee1">More...</a><br /></td></tr>
<tr class="separator:a4e7ddd32b687869d59a1f5099ced4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a1df055586b26f637bc94800a871af"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a21a1df055586b26f637bc94800a871af">setex</a> (std::string_view key, uint64_t <a class="el" href="classcoro__redis_1_1sync__connection.html#a6eae6cadf59a057457b3601d884de117">ttl</a>, std::string_view val)</td></tr>
<tr class="memdesc:a21a1df055586b26f637bc94800a871af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key-value pair with the given timeout in seconds.  <a href="classcoro__redis_1_1sync__connection.html#a21a1df055586b26f637bc94800a871af">More...</a><br /></td></tr>
<tr class="separator:a21a1df055586b26f637bc94800a871af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293ddc35925035864afa9803e362f5fa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a293ddc35925035864afa9803e362f5fa">setnx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a293ddc35925035864afa9803e362f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the key if it does not exist.  <a href="classcoro__redis_1_1sync__connection.html#a293ddc35925035864afa9803e362f5fa">More...</a><br /></td></tr>
<tr class="separator:a293ddc35925035864afa9803e362f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca632d2ffa22b25f4e29350a937fa96f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aca632d2ffa22b25f4e29350a937fa96f">setrange</a> (std::string_view key, uint64_t offset, std::string_view val)</td></tr>
<tr class="memdesc:aca632d2ffa22b25f4e29350a937fa96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the substring starting from <code>offset</code> to the given value.  <a href="classcoro__redis_1_1sync__connection.html#aca632d2ffa22b25f4e29350a937fa96f">More...</a><br /></td></tr>
<tr class="separator:aca632d2ffa22b25f4e29350a937fa96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d217b4e4a1d94d099aefffaaf9cefd5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0d217b4e4a1d94d099aefffaaf9cefd5">strlen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a0d217b4e4a1d94d099aefffaaf9cefd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string stored at key.  <a href="classcoro__redis_1_1sync__connection.html#a0d217b4e4a1d94d099aefffaaf9cefd5">More...</a><br /></td></tr>
<tr class="separator:a0d217b4e4a1d94d099aefffaaf9cefd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acede5cf003ab5eb0c3e2df9e980b5c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a8acede5cf003ab5eb0c3e2df9e980b5c">llen</a> (std::string_view key)</td></tr>
<tr class="memdesc:a8acede5cf003ab5eb0c3e2df9e980b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the list.  <a href="classcoro__redis_1_1sync__connection.html#a8acede5cf003ab5eb0c3e2df9e980b5c">More...</a><br /></td></tr>
<tr class="separator:a8acede5cf003ab5eb0c3e2df9e980b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1afc0239cfca4cd095faeb501f1a686"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aa1afc0239cfca4cd095faeb501f1a686">lpop</a> (std::string_view key)</td></tr>
<tr class="memdesc:aa1afc0239cfca4cd095faeb501f1a686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the first element of the list.  <a href="classcoro__redis_1_1sync__connection.html#aa1afc0239cfca4cd095faeb501f1a686">More...</a><br /></td></tr>
<tr class="separator:aa1afc0239cfca4cd095faeb501f1a686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0be919681356eca77fe6fc7d736445"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#afa0be919681356eca77fe6fc7d736445">lpush</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:afa0be919681356eca77fe6fc7d736445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the beginning of the list.  <a href="classcoro__redis_1_1sync__connection.html#afa0be919681356eca77fe6fc7d736445">More...</a><br /></td></tr>
<tr class="separator:afa0be919681356eca77fe6fc7d736445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa95b1e6d9979d21d0312ca0561bd8b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3fa95b1e6d9979d21d0312ca0561bd8b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3fa95b1e6d9979d21d0312ca0561bd8b">lpush</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a3fa95b1e6d9979d21d0312ca0561bd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push multiple elements to the beginning of the list.  <a href="classcoro__redis_1_1sync__connection.html#a3fa95b1e6d9979d21d0312ca0561bd8b">More...</a><br /></td></tr>
<tr class="separator:a3fa95b1e6d9979d21d0312ca0561bd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b6cc948c56f4483ffcde56714fade"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a6d2b6cc948c56f4483ffcde56714fade">lpushx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a6d2b6cc948c56f4483ffcde56714fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the beginning of the list, only if the list already exists.  <a href="classcoro__redis_1_1sync__connection.html#a6d2b6cc948c56f4483ffcde56714fade">More...</a><br /></td></tr>
<tr class="separator:a6d2b6cc948c56f4483ffcde56714fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869dc52b1481c8d425920631355f13d6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a869dc52b1481c8d425920631355f13d6">lrange</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:a869dc52b1481c8d425920631355f13d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get elements in the given range of the given list.  <a href="classcoro__redis_1_1sync__connection.html#a869dc52b1481c8d425920631355f13d6">More...</a><br /></td></tr>
<tr class="separator:a869dc52b1481c8d425920631355f13d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78db624f4c59b38fdcb832f0b2e3aed"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac78db624f4c59b38fdcb832f0b2e3aed">lrem</a> (std::string_view key, uint64_t count, std::string_view val)</td></tr>
<tr class="memdesc:ac78db624f4c59b38fdcb832f0b2e3aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first <code>count</code> occurrences of elements equal to <code>val</code>.  <a href="classcoro__redis_1_1sync__connection.html#ac78db624f4c59b38fdcb832f0b2e3aed">More...</a><br /></td></tr>
<tr class="separator:ac78db624f4c59b38fdcb832f0b2e3aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb77a3f44cf7ddad47aaf924fe4b93"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#abaeb77a3f44cf7ddad47aaf924fe4b93">lset</a> (std::string_view key, uint64_t index, std::string_view val)</td></tr>
<tr class="memdesc:abaeb77a3f44cf7ddad47aaf924fe4b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element at the given index to the specified value.  <a href="classcoro__redis_1_1sync__connection.html#abaeb77a3f44cf7ddad47aaf924fe4b93">More...</a><br /></td></tr>
<tr class="separator:abaeb77a3f44cf7ddad47aaf924fe4b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab203113950d44f3608659c5e1df4ed05"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab203113950d44f3608659c5e1df4ed05">ltrim</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:ab203113950d44f3608659c5e1df4ed05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim a list to keep only element in the given range.  <a href="classcoro__redis_1_1sync__connection.html#ab203113950d44f3608659c5e1df4ed05">More...</a><br /></td></tr>
<tr class="separator:ab203113950d44f3608659c5e1df4ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e285e1e3cd3aa652fa7d599bb39f0d3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0e285e1e3cd3aa652fa7d599bb39f0d3">rpop</a> (std::string_view key)</td></tr>
<tr class="memdesc:a0e285e1e3cd3aa652fa7d599bb39f0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the last element of a list.  <a href="classcoro__redis_1_1sync__connection.html#a0e285e1e3cd3aa652fa7d599bb39f0d3">More...</a><br /></td></tr>
<tr class="separator:a0e285e1e3cd3aa652fa7d599bb39f0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b63db9752f6fd89bc1c3f46df673948"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a8b63db9752f6fd89bc1c3f46df673948">rpoplpush</a> (std::string_view source, std::string_view destination)</td></tr>
<tr class="memdesc:a8b63db9752f6fd89bc1c3f46df673948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop last element of one list and push it to the left of another list.  <a href="classcoro__redis_1_1sync__connection.html#a8b63db9752f6fd89bc1c3f46df673948">More...</a><br /></td></tr>
<tr class="separator:a8b63db9752f6fd89bc1c3f46df673948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e846977434a90b982c15cc45b26952"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae3e846977434a90b982c15cc45b26952"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ae3e846977434a90b982c15cc45b26952">rpush</a> (std::string_view key, std::string_view val, Args &amp;&amp;... vals)</td></tr>
<tr class="memdesc:ae3e846977434a90b982c15cc45b26952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the end of the list.  <a href="classcoro__redis_1_1sync__connection.html#ae3e846977434a90b982c15cc45b26952">More...</a><br /></td></tr>
<tr class="separator:ae3e846977434a90b982c15cc45b26952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a341f8d8b323636c7fb6b33918688"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3d8a341f8d8b323636c7fb6b33918688">rpushx</a> (std::string_view key, std::string_view val)</td></tr>
<tr class="memdesc:a3d8a341f8d8b323636c7fb6b33918688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the end of the list, only if the list already exists.  <a href="classcoro__redis_1_1sync__connection.html#a3d8a341f8d8b323636c7fb6b33918688">More...</a><br /></td></tr>
<tr class="separator:a3d8a341f8d8b323636c7fb6b33918688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a2d34ac4f8e2eafb921f2e5e335ffa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad0a2d34ac4f8e2eafb921f2e5e335ffa"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ad0a2d34ac4f8e2eafb921f2e5e335ffa">hdel</a> (std::string_view key, std::string_view field, Args &amp;&amp;... fields)</td></tr>
<tr class="memdesc:ad0a2d34ac4f8e2eafb921f2e5e335ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given field from hash.  <a href="classcoro__redis_1_1sync__connection.html#ad0a2d34ac4f8e2eafb921f2e5e335ffa">More...</a><br /></td></tr>
<tr class="separator:ad0a2d34ac4f8e2eafb921f2e5e335ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8570eece0f2911d55138d7db1476561"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af8570eece0f2911d55138d7db1476561">hexists</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:af8570eece0f2911d55138d7db1476561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given field exists in hash.  <a href="classcoro__redis_1_1sync__connection.html#af8570eece0f2911d55138d7db1476561">More...</a><br /></td></tr>
<tr class="separator:af8570eece0f2911d55138d7db1476561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b80ef25d6388e3f30e2048bd0b9d26"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a18b80ef25d6388e3f30e2048bd0b9d26">hget</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:a18b80ef25d6388e3f30e2048bd0b9d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the given field.  <a href="classcoro__redis_1_1sync__connection.html#a18b80ef25d6388e3f30e2048bd0b9d26">More...</a><br /></td></tr>
<tr class="separator:a18b80ef25d6388e3f30e2048bd0b9d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa57b60afb0b2587d1afa24f564b4ca"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#adfa57b60afb0b2587d1afa24f564b4ca">hgetall</a> (std::string_view key)</td></tr>
<tr class="memdesc:adfa57b60afb0b2587d1afa24f564b4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all field-value pairs of the given hash.  <a href="classcoro__redis_1_1sync__connection.html#adfa57b60afb0b2587d1afa24f564b4ca">More...</a><br /></td></tr>
<tr class="separator:adfa57b60afb0b2587d1afa24f564b4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae7bdaae2cd429d5bb2e663084cfe86"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aaae7bdaae2cd429d5bb2e663084cfe86">hincrby</a> (std::string_view key, std::string_view field, uint64_t increment)</td></tr>
<tr class="memdesc:aaae7bdaae2cd429d5bb2e663084cfe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the integer stored at the given field.  <a href="classcoro__redis_1_1sync__connection.html#aaae7bdaae2cd429d5bb2e663084cfe86">More...</a><br /></td></tr>
<tr class="separator:aaae7bdaae2cd429d5bb2e663084cfe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202ad50ac7a87b0d4e1d8d335d15dd2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a1202ad50ac7a87b0d4e1d8d335d15dd2">hincrbyfloat</a> (std::string_view key, std::string_view field, double increment)</td></tr>
<tr class="memdesc:a1202ad50ac7a87b0d4e1d8d335d15dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the floating point number stored at the given field.  <a href="classcoro__redis_1_1sync__connection.html#a1202ad50ac7a87b0d4e1d8d335d15dd2">More...</a><br /></td></tr>
<tr class="separator:a1202ad50ac7a87b0d4e1d8d335d15dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f9e5846519a42bf766df11363cf513"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac1f9e5846519a42bf766df11363cf513">hkeys</a> (std::string_view key)</td></tr>
<tr class="memdesc:ac1f9e5846519a42bf766df11363cf513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all fields of the given hash.  <a href="classcoro__redis_1_1sync__connection.html#ac1f9e5846519a42bf766df11363cf513">More...</a><br /></td></tr>
<tr class="separator:ac1f9e5846519a42bf766df11363cf513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac758bf325df94e5c026618125c23dfa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aac758bf325df94e5c026618125c23dfa">hlen</a> (std::string_view key)</td></tr>
<tr class="memdesc:aac758bf325df94e5c026618125c23dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of fields of the given hash.  <a href="classcoro__redis_1_1sync__connection.html#aac758bf325df94e5c026618125c23dfa">More...</a><br /></td></tr>
<tr class="separator:aac758bf325df94e5c026618125c23dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1b071e1a514798be0280dffca9d523"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0a1b071e1a514798be0280dffca9d523"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0a1b071e1a514798be0280dffca9d523">hmget</a> (std::string_view key, std::string_view field, Args &amp;&amp;... fields)</td></tr>
<tr class="memdesc:a0a1b071e1a514798be0280dffca9d523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of multiple fields.  <a href="classcoro__redis_1_1sync__connection.html#a0a1b071e1a514798be0280dffca9d523">More...</a><br /></td></tr>
<tr class="separator:a0a1b071e1a514798be0280dffca9d523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eef1b6a59fe6fd60c4d1c92e2799032"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2eef1b6a59fe6fd60c4d1c92e2799032"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a2eef1b6a59fe6fd60c4d1c92e2799032">hmset</a> (std::string_view key, std::string_view field, std::string_view value, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2eef1b6a59fe6fd60c4d1c92e2799032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple field-value pairs of the given hash.  <a href="classcoro__redis_1_1sync__connection.html#a2eef1b6a59fe6fd60c4d1c92e2799032">More...</a><br /></td></tr>
<tr class="separator:a2eef1b6a59fe6fd60c4d1c92e2799032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11112d772cb087c071397e87c828db95"><td class="memItemLeft" align="right" valign="top">std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a11112d772cb087c071397e87c828db95">hscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:a11112d772cb087c071397e87c828db95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan fields of the given hash matching the given pattern.  <a href="classcoro__redis_1_1sync__connection.html#a11112d772cb087c071397e87c828db95">More...</a><br /></td></tr>
<tr class="separator:a11112d772cb087c071397e87c828db95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04fe51503e5aacb3dcd732a1d4116e9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac04fe51503e5aacb3dcd732a1d4116e9">hscan</a> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="memdesc:ac04fe51503e5aacb3dcd732a1d4116e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan fields of the given hash matching the given pattern.  <a href="classcoro__redis_1_1sync__connection.html#ac04fe51503e5aacb3dcd732a1d4116e9">More...</a><br /></td></tr>
<tr class="separator:ac04fe51503e5aacb3dcd732a1d4116e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779efee69c5502e1b3329455a34a4db7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a779efee69c5502e1b3329455a34a4db7"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a779efee69c5502e1b3329455a34a4db7">hset</a> (std::string_view key, std::string_view field, std::string_view val, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a779efee69c5502e1b3329455a34a4db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hash field to value.  <a href="classcoro__redis_1_1sync__connection.html#a779efee69c5502e1b3329455a34a4db7">More...</a><br /></td></tr>
<tr class="separator:a779efee69c5502e1b3329455a34a4db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f00be114c01c324f1e6157165bf56a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac7f00be114c01c324f1e6157165bf56a">hset</a> (std::string_view key, const std::vector&lt; std::pair&lt; std::string_view, std::string_view &gt;&gt; &amp;kvs)</td></tr>
<tr class="memdesc:ac7f00be114c01c324f1e6157165bf56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple fields of the given hash.  <a href="classcoro__redis_1_1sync__connection.html#ac7f00be114c01c324f1e6157165bf56a">More...</a><br /></td></tr>
<tr class="separator:ac7f00be114c01c324f1e6157165bf56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3b53648bebb00f0d668051c8f93dea"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#acf3b53648bebb00f0d668051c8f93dea">hsetnx</a> (std::string_view key, std::string_view field, std::string_view val)</td></tr>
<tr class="memdesc:acf3b53648bebb00f0d668051c8f93dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hash field to value, only if the given field does not exist.  <a href="classcoro__redis_1_1sync__connection.html#acf3b53648bebb00f0d668051c8f93dea">More...</a><br /></td></tr>
<tr class="separator:acf3b53648bebb00f0d668051c8f93dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa660bda10ef0c0cf491d5d244b61b9f3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aa660bda10ef0c0cf491d5d244b61b9f3">hstrlen</a> (std::string_view key, std::string_view field)</td></tr>
<tr class="memdesc:aa660bda10ef0c0cf491d5d244b61b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string stored at the given field.  <a href="classcoro__redis_1_1sync__connection.html#aa660bda10ef0c0cf491d5d244b61b9f3">More...</a><br /></td></tr>
<tr class="separator:aa660bda10ef0c0cf491d5d244b61b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08f79ad848549b5fd88d16adb0c4d28"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ae08f79ad848549b5fd88d16adb0c4d28">hvals</a> (std::string_view key)</td></tr>
<tr class="memdesc:ae08f79ad848549b5fd88d16adb0c4d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get values of all fields stored at the given hash.  <a href="classcoro__redis_1_1sync__connection.html#ae08f79ad848549b5fd88d16adb0c4d28">More...</a><br /></td></tr>
<tr class="separator:ae08f79ad848549b5fd88d16adb0c4d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fbbde1c561945ca1ca779f1839cf36"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af6fbbde1c561945ca1ca779f1839cf36"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af6fbbde1c561945ca1ca779f1839cf36">sadd</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:af6fbbde1c561945ca1ca779f1839cf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a member to the given set.  <a href="classcoro__redis_1_1sync__connection.html#af6fbbde1c561945ca1ca779f1839cf36">More...</a><br /></td></tr>
<tr class="separator:af6fbbde1c561945ca1ca779f1839cf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af47f8fc3f26fd6c4fab66619cabd33"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a2af47f8fc3f26fd6c4fab66619cabd33">scard</a> (std::string_view key)</td></tr>
<tr class="memdesc:a2af47f8fc3f26fd6c4fab66619cabd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members in the set.  <a href="classcoro__redis_1_1sync__connection.html#a2af47f8fc3f26fd6c4fab66619cabd33">More...</a><br /></td></tr>
<tr class="separator:a2af47f8fc3f26fd6c4fab66619cabd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acfa502f1a2ab9ef263628592c8b149"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3acfa502f1a2ab9ef263628592c8b149"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3acfa502f1a2ab9ef263628592c8b149">sdiff</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a3acfa502f1a2ab9ef263628592c8b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the difference between the first set and all successive sets.  <a href="classcoro__redis_1_1sync__connection.html#a3acfa502f1a2ab9ef263628592c8b149">More...</a><br /></td></tr>
<tr class="separator:a3acfa502f1a2ab9ef263628592c8b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3545e120cf70e86075cb362ed5105651"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3545e120cf70e86075cb362ed5105651"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3545e120cf70e86075cb362ed5105651">sdiffstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a3545e120cf70e86075cb362ed5105651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1sync__connection.html#a3545e120cf70e86075cb362ed5105651">More...</a><br /></td></tr>
<tr class="separator:a3545e120cf70e86075cb362ed5105651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d9b68f21d16af08b253254100da453"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a69d9b68f21d16af08b253254100da453"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a69d9b68f21d16af08b253254100da453">sinter</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a69d9b68f21d16af08b253254100da453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection between the first set and all successive sets.  <a href="classcoro__redis_1_1sync__connection.html#a69d9b68f21d16af08b253254100da453">More...</a><br /></td></tr>
<tr class="separator:a69d9b68f21d16af08b253254100da453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5bab9de9a8acdef435ccc594696f05"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9e5bab9de9a8acdef435ccc594696f05"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a9e5bab9de9a8acdef435ccc594696f05">sinterstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a9e5bab9de9a8acdef435ccc594696f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1sync__connection.html#a9e5bab9de9a8acdef435ccc594696f05">More...</a><br /></td></tr>
<tr class="separator:a9e5bab9de9a8acdef435ccc594696f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea74d9b4ebc55cbf7d3aaa8b62f7efd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0ea74d9b4ebc55cbf7d3aaa8b62f7efd">sismember</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a0ea74d9b4ebc55cbf7d3aaa8b62f7efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <code>member</code> exists in the set stored at key.  <a href="classcoro__redis_1_1sync__connection.html#a0ea74d9b4ebc55cbf7d3aaa8b62f7efd">More...</a><br /></td></tr>
<tr class="separator:a0ea74d9b4ebc55cbf7d3aaa8b62f7efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94bed2239591235d3f6b1968592b94c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ad94bed2239591235d3f6b1968592b94c">smembers</a> (std::string_view key)</td></tr>
<tr class="memdesc:ad94bed2239591235d3f6b1968592b94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all members in the given set.  <a href="classcoro__redis_1_1sync__connection.html#ad94bed2239591235d3f6b1968592b94c">More...</a><br /></td></tr>
<tr class="separator:ad94bed2239591235d3f6b1968592b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d28229bd7449de6567d1afa1878fdbe"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a7d28229bd7449de6567d1afa1878fdbe">smove</a> (std::string_view source, std::string_view destination, std::string_view member)</td></tr>
<tr class="memdesc:a7d28229bd7449de6567d1afa1878fdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move <code>member</code> from one set to another.  <a href="classcoro__redis_1_1sync__connection.html#a7d28229bd7449de6567d1afa1878fdbe">More...</a><br /></td></tr>
<tr class="separator:a7d28229bd7449de6567d1afa1878fdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27446ca9cb630942fda7cee06c203450"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a27446ca9cb630942fda7cee06c203450">spop</a> (std::string_view key, uint64_t count=1)</td></tr>
<tr class="memdesc:a27446ca9cb630942fda7cee06c203450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a random member from the set.  <a href="classcoro__redis_1_1sync__connection.html#a27446ca9cb630942fda7cee06c203450">More...</a><br /></td></tr>
<tr class="separator:a27446ca9cb630942fda7cee06c203450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccb33103c2ce71b60fb8b0b8b9ccb80"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a5ccb33103c2ce71b60fb8b0b8b9ccb80">srandmember</a> (std::string_view key)</td></tr>
<tr class="memdesc:a5ccb33103c2ce71b60fb8b0b8b9ccb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random member of the given set.  <a href="classcoro__redis_1_1sync__connection.html#a5ccb33103c2ce71b60fb8b0b8b9ccb80">More...</a><br /></td></tr>
<tr class="separator:a5ccb33103c2ce71b60fb8b0b8b9ccb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42911430edd683362689ce345720b374"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a42911430edd683362689ce345720b374">srandmember</a> (std::string_view key, uint64_t count)</td></tr>
<tr class="memdesc:a42911430edd683362689ce345720b374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple random members of the given set.  <a href="classcoro__redis_1_1sync__connection.html#a42911430edd683362689ce345720b374">More...</a><br /></td></tr>
<tr class="separator:a42911430edd683362689ce345720b374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e63bae2c40ebe1efcbfc5f89d3e7d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aef5e63bae2c40ebe1efcbfc5f89d3e7d"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aef5e63bae2c40ebe1efcbfc5f89d3e7d">srem</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:aef5e63bae2c40ebe1efcbfc5f89d3e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a member from set.  <a href="classcoro__redis_1_1sync__connection.html#aef5e63bae2c40ebe1efcbfc5f89d3e7d">More...</a><br /></td></tr>
<tr class="separator:aef5e63bae2c40ebe1efcbfc5f89d3e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e047988a9573a925818072bf0b999a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab5e047988a9573a925818072bf0b999a">sscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:ab5e047988a9573a925818072bf0b999a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan members of the set matching the given pattern.  <a href="classcoro__redis_1_1sync__connection.html#ab5e047988a9573a925818072bf0b999a">More...</a><br /></td></tr>
<tr class="separator:ab5e047988a9573a925818072bf0b999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4986cf0b881b318e485a222ec79bd87e"><td class="memItemLeft" align="right" valign="top"><a id="a4986cf0b881b318e485a222ec79bd87e"></a>
std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sscan</b> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count=0)</td></tr>
<tr class="separator:a4986cf0b881b318e485a222ec79bd87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0122d161b3ecc2b60866dd56d722c847"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0122d161b3ecc2b60866dd56d722c847"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0122d161b3ecc2b60866dd56d722c847">sunion</a> (std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a0122d161b3ecc2b60866dd56d722c847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the union between the first set and all successive sets.  <a href="classcoro__redis_1_1sync__connection.html#a0122d161b3ecc2b60866dd56d722c847">More...</a><br /></td></tr>
<tr class="separator:a0122d161b3ecc2b60866dd56d722c847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa2e92682a3ecfe13d3339a941217c6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5aa2e92682a3ecfe13d3339a941217c6"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a5aa2e92682a3ecfe13d3339a941217c6">sunionstore</a> (std::string_view destination, std::string_view key, Args &amp;&amp;... keys)</td></tr>
<tr class="memdesc:a5aa2e92682a3ecfe13d3339a941217c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy set stored at <code>key</code> to <code>destination</code>.  <a href="classcoro__redis_1_1sync__connection.html#a5aa2e92682a3ecfe13d3339a941217c6">More...</a><br /></td></tr>
<tr class="separator:a5aa2e92682a3ecfe13d3339a941217c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3d9002f3ae0daaca3c8b05247e67a2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0b3d9002f3ae0daaca3c8b05247e67a2">bzpopmax</a> (std::initializer_list&lt; std::string_view &gt; keys, uint64_t timeout=0)</td></tr>
<tr class="memdesc:a0b3d9002f3ae0daaca3c8b05247e67a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with highest score from sorted set in a blocking way.  <a href="classcoro__redis_1_1sync__connection.html#a0b3d9002f3ae0daaca3c8b05247e67a2">More...</a><br /></td></tr>
<tr class="separator:a0b3d9002f3ae0daaca3c8b05247e67a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34ac9573dc51fc9588282721241072"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a4b34ac9573dc51fc9588282721241072">bzpopmin</a> (std::initializer_list&lt; std::string_view &gt; keys, uint64_t timeout=0)</td></tr>
<tr class="memdesc:a4b34ac9573dc51fc9588282721241072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with lowest score from sorted set in a blocking way.  <a href="classcoro__redis_1_1sync__connection.html#a4b34ac9573dc51fc9588282721241072">More...</a><br /></td></tr>
<tr class="separator:a4b34ac9573dc51fc9588282721241072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c38b137bc676a25f9a6a634f2c50f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af26c38b137bc676a25f9a6a634f2c50f">zadd</a> (std::string_view key, std::string_view member, double score, UpdateType <a class="el" href="classcoro__redis_1_1sync__connection.html#a5632e80e4f17fce42def24e72683f749">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:af26c38b137bc676a25f9a6a634f2c50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update a member with score to sorted set.  <a href="classcoro__redis_1_1sync__connection.html#af26c38b137bc676a25f9a6a634f2c50f">More...</a><br /></td></tr>
<tr class="separator:af26c38b137bc676a25f9a6a634f2c50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af035262f38c3966ae292f99cfd683ef8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af035262f38c3966ae292f99cfd683ef8">zadd</a> (std::string_view key, std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt; kvs, UpdateType <a class="el" href="classcoro__redis_1_1sync__connection.html#a5632e80e4f17fce42def24e72683f749">type</a>=UpdateType::ALWAYS)</td></tr>
<tr class="memdesc:af035262f38c3966ae292f99cfd683ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update multiple members with score to sorted set.  <a href="classcoro__redis_1_1sync__connection.html#af035262f38c3966ae292f99cfd683ef8">More...</a><br /></td></tr>
<tr class="separator:af035262f38c3966ae292f99cfd683ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ea586a6846db30d565f2b4d1f6718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca4ea586a6846db30d565f2b4d1f6718"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#aca4ea586a6846db30d565f2b4d1f6718">zadd</a> (std::string_view key, std::initializer_list&lt; T &gt; il, UpdateType <a class="el" href="classcoro__redis_1_1sync__connection.html#a5632e80e4f17fce42def24e72683f749">type</a>=UpdateType::ALWAYS, bool changed=false)</td></tr>
<tr class="memdesc:aca4ea586a6846db30d565f2b4d1f6718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or update multiple members with score to sorted set.  <a href="classcoro__redis_1_1sync__connection.html#aca4ea586a6846db30d565f2b4d1f6718">More...</a><br /></td></tr>
<tr class="separator:aca4ea586a6846db30d565f2b4d1f6718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1899bd5c7694a7062135d911809caedc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a1899bd5c7694a7062135d911809caedc">zcard</a> (std::string_view key)</td></tr>
<tr class="memdesc:a1899bd5c7694a7062135d911809caedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members in the sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a1899bd5c7694a7062135d911809caedc">More...</a><br /></td></tr>
<tr class="separator:a1899bd5c7694a7062135d911809caedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9d4afb84826de42cb5b62a19c6043e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3c9d4afb84826de42cb5b62a19c6043e">zcount</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a3c9d4afb84826de42cb5b62a19c6043e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members with score between a min-max score range.  <a href="classcoro__redis_1_1sync__connection.html#a3c9d4afb84826de42cb5b62a19c6043e">More...</a><br /></td></tr>
<tr class="separator:a3c9d4afb84826de42cb5b62a19c6043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ba5b7962b54fd4b1aad9633caf9c70"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab8ba5b7962b54fd4b1aad9633caf9c70">zincrby</a> (std::string_view key, double increment, std::string_view member)</td></tr>
<tr class="memdesc:ab8ba5b7962b54fd4b1aad9633caf9c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the score of given member.  <a href="classcoro__redis_1_1sync__connection.html#ab8ba5b7962b54fd4b1aad9633caf9c70">More...</a><br /></td></tr>
<tr class="separator:ab8ba5b7962b54fd4b1aad9633caf9c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47413eb7fd039ffe15fc9d706ffc951"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ad47413eb7fd039ffe15fc9d706ffc951">zlexcount</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:ad47413eb7fd039ffe15fc9d706ffc951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of members between a min-max range in lexicographical order.  <a href="classcoro__redis_1_1sync__connection.html#ad47413eb7fd039ffe15fc9d706ffc951">More...</a><br /></td></tr>
<tr class="separator:ad47413eb7fd039ffe15fc9d706ffc951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac479fdadfcd5a73e6090eb9a34a62d72"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ac479fdadfcd5a73e6090eb9a34a62d72">zpopmax</a> (std::string_view key, uint64_t count=1)</td></tr>
<tr class="memdesc:ac479fdadfcd5a73e6090eb9a34a62d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with highest score from sorted set.  <a href="classcoro__redis_1_1sync__connection.html#ac479fdadfcd5a73e6090eb9a34a62d72">More...</a><br /></td></tr>
<tr class="separator:ac479fdadfcd5a73e6090eb9a34a62d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a86c321ca701916d5b94579c607a3dd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a0a86c321ca701916d5b94579c607a3dd">zpopmin</a> (std::string_view key)</td></tr>
<tr class="memdesc:a0a86c321ca701916d5b94579c607a3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the member with lowest score from sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a0a86c321ca701916d5b94579c607a3dd">More...</a><br /></td></tr>
<tr class="separator:a0a86c321ca701916d5b94579c607a3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1b0a77c6763bdc39fd857250921938"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a4f1b0a77c6763bdc39fd857250921938">zrange</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a4f1b0a77c6763bdc39fd857250921938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by rank (ordered from lowest to highest).  <a href="classcoro__redis_1_1sync__connection.html#a4f1b0a77c6763bdc39fd857250921938">More...</a><br /></td></tr>
<tr class="separator:a4f1b0a77c6763bdc39fd857250921938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b4d51a2f28157e6cb81a589e445731"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a89b4d51a2f28157e6cb81a589e445731">zrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a89b4d51a2f28157e6cb81a589e445731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by lexicographical order (from lowest to highest).  <a href="classcoro__redis_1_1sync__connection.html#a89b4d51a2f28157e6cb81a589e445731">More...</a><br /></td></tr>
<tr class="separator:a89b4d51a2f28157e6cb81a589e445731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bf1f2fe56660f26a53d0b71bf4243c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a97bf1f2fe56660f26a53d0b71bf4243c">zrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a97bf1f2fe56660f26a53d0b71bf4243c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by score (ordered from lowest to highest).  <a href="classcoro__redis_1_1sync__connection.html#a97bf1f2fe56660f26a53d0b71bf4243c">More...</a><br /></td></tr>
<tr class="separator:a97bf1f2fe56660f26a53d0b71bf4243c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac3a542530b763f93e6415cf07262c1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a8ac3a542530b763f93e6415cf07262c1">zrank</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a8ac3a542530b763f93e6415cf07262c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank (from low to high) of the given member in the sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a8ac3a542530b763f93e6415cf07262c1">More...</a><br /></td></tr>
<tr class="separator:a8ac3a542530b763f93e6415cf07262c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574c36c767212ce31a414a81f3caaeb"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8574c36c767212ce31a414a81f3caaeb"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a8574c36c767212ce31a414a81f3caaeb">zrem</a> (std::string_view key, std::string_view member, Args &amp;&amp;... members)</td></tr>
<tr class="memdesc:a8574c36c767212ce31a414a81f3caaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given member from sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a8574c36c767212ce31a414a81f3caaeb">More...</a><br /></td></tr>
<tr class="separator:a8574c36c767212ce31a414a81f3caaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13cefa891315665675637e10fb7a231"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af13cefa891315665675637e10fb7a231">zremrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:af13cefa891315665675637e10fb7a231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range of lexicographical order.  <a href="classcoro__redis_1_1sync__connection.html#af13cefa891315665675637e10fb7a231">More...</a><br /></td></tr>
<tr class="separator:af13cefa891315665675637e10fb7a231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d6e14929aced75d8c19c31b7da1250"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a57d6e14929aced75d8c19c31b7da1250">zremrangebyrank</a> (std::string_view key, uint64_t start, uint64_t stop)</td></tr>
<tr class="memdesc:a57d6e14929aced75d8c19c31b7da1250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range ordered by rank.  <a href="classcoro__redis_1_1sync__connection.html#a57d6e14929aced75d8c19c31b7da1250">More...</a><br /></td></tr>
<tr class="separator:a57d6e14929aced75d8c19c31b7da1250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9894009ee0145f00b4c871d0d45170"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a1d9894009ee0145f00b4c871d0d45170">zremrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a1d9894009ee0145f00b4c871d0d45170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove members in the given range ordered by score.  <a href="classcoro__redis_1_1sync__connection.html#a1d9894009ee0145f00b4c871d0d45170">More...</a><br /></td></tr>
<tr class="separator:a1d9894009ee0145f00b4c871d0d45170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77fd44236d42c98b443b0da8ad50f00"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ad77fd44236d42c98b443b0da8ad50f00">zrevrange</a> (std::string_view key, uint64_t start, uint64_t stop, bool withscores=false)</td></tr>
<tr class="memdesc:ad77fd44236d42c98b443b0da8ad50f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by rank (ordered from highest to lowest).  <a href="classcoro__redis_1_1sync__connection.html#ad77fd44236d42c98b443b0da8ad50f00">More...</a><br /></td></tr>
<tr class="separator:ad77fd44236d42c98b443b0da8ad50f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8380c249876f306ccbd241d1ba418384"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a8380c249876f306ccbd241d1ba418384">zrevrangebylex</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a8380c249876f306ccbd241d1ba418384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by lexicographical order (from highest to lowest).  <a href="classcoro__redis_1_1sync__connection.html#a8380c249876f306ccbd241d1ba418384">More...</a><br /></td></tr>
<tr class="separator:a8380c249876f306ccbd241d1ba418384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a133e530f486616c51712869a90079b"><td class="memTemplParams" colspan="2">template&lt;typename Interval , typename Output &gt; </td></tr>
<tr class="memitem:a5a133e530f486616c51712869a90079b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a5a133e530f486616c51712869a90079b">zrevrangebyscore</a> (std::string_view key, std::string_view min, std::string_view max)</td></tr>
<tr class="memdesc:a5a133e530f486616c51712869a90079b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of members by score (ordered from highest to lowest).  <a href="classcoro__redis_1_1sync__connection.html#a5a133e530f486616c51712869a90079b">More...</a><br /></td></tr>
<tr class="separator:a5a133e530f486616c51712869a90079b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9874f8029b9caedeb6119c882b30782c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a9874f8029b9caedeb6119c882b30782c">zrevrank</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:a9874f8029b9caedeb6119c882b30782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank (from high to low) of the given member in the sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a9874f8029b9caedeb6119c882b30782c">More...</a><br /></td></tr>
<tr class="separator:a9874f8029b9caedeb6119c882b30782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d52df360988afadede40587582f61"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a3b0d52df360988afadede40587582f61">zscan</a> (std::string_view key, uint64_t cursor, uint64_t count)</td></tr>
<tr class="memdesc:a3b0d52df360988afadede40587582f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all members of the given sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a3b0d52df360988afadede40587582f61">More...</a><br /></td></tr>
<tr class="separator:a3b0d52df360988afadede40587582f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5458557b358e5baabf7155735d15f109"><td class="memItemLeft" align="right" valign="top">std::optional&lt; scan_ret_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a5458557b358e5baabf7155735d15f109">zscan</a> (std::string_view key, uint64_t cursor, std::string_view pattern, uint64_t count)</td></tr>
<tr class="memdesc:a5458557b358e5baabf7155735d15f109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all members of the given sorted set.  <a href="classcoro__redis_1_1sync__connection.html#a5458557b358e5baabf7155735d15f109">More...</a><br /></td></tr>
<tr class="separator:a5458557b358e5baabf7155735d15f109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14939ea99f37b8bae8520a88972be52"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#af14939ea99f37b8bae8520a88972be52">zscore</a> (std::string_view key, std::string_view member)</td></tr>
<tr class="memdesc:af14939ea99f37b8bae8520a88972be52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score of the given member.  <a href="classcoro__redis_1_1sync__connection.html#af14939ea99f37b8bae8520a88972be52">More...</a><br /></td></tr>
<tr class="separator:af14939ea99f37b8bae8520a88972be52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7333bb9b68345b6c723fb097cdddd57"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#ab7333bb9b68345b6c723fb097cdddd57">zunionstore</a> (std::string_view destination, std::initializer_list&lt; std::string_view &gt; keys, std::string_view aggregate=&quot;SUM&quot;)</td></tr>
<tr class="memdesc:ab7333bb9b68345b6c723fb097cdddd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sorted set to another one with the scores being multiplied by a factor.  <a href="classcoro__redis_1_1sync__connection.html#ab7333bb9b68345b6c723fb097cdddd57">More...</a><br /></td></tr>
<tr class="separator:ab7333bb9b68345b6c723fb097cdddd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf5f46b62f853f383cb8fb3d7f46019"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#adaf5f46b62f853f383cb8fb3d7f46019">zunionstore</a> (std::string_view destination, std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt; kvs, std::string_view aggregate=&quot;SUM&quot;)</td></tr>
<tr class="memdesc:adaf5f46b62f853f383cb8fb3d7f46019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get union of multiple sorted sets, and store the result to another one.  <a href="classcoro__redis_1_1sync__connection.html#adaf5f46b62f853f383cb8fb3d7f46019">More...</a><br /></td></tr>
<tr class="separator:adaf5f46b62f853f383cb8fb3d7f46019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dcfb45101588a54b5aea7787e9c272"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a18dcfb45101588a54b5aea7787e9c272"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoro__redis_1_1sync__connection.html#a18dcfb45101588a54b5aea7787e9c272">pfadd</a> (std::string_view key, Args &amp;&amp;... elements)</td></tr>
<tr class="memdesc:a18dcfb45101588a54b5aea7787e9c272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given element to a hyperloglog.  <a href="classcoro__redis_1_1sync__connection.html#a18dcfb45101588a54b5aea7787e9c272">More...</a><br /></td></tr>
<tr class="separator:a18dcfb45101588a54b5aea7787e9c272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Synchronous connection. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6999468f63dea283ee5fbc6a9e7b761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6999468f63dea283ee5fbc6a9e7b761">&#9670;&nbsp;</a></span>sync_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">coro_redis::sync_connection::sync_connection </td>
          <td>(</td>
          <td class="paramtype">redisContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Redis synchronous context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace61b8c6282d972a93d37168514a67df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace61b8c6282d972a93d37168514a67df">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::append </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the given string to the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">str</td><td>String to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string after the append operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/append">https://redis.io/commands/append</a> </dd></dl>

</div>
</div>
<a id="a2b3c9608703080731f6446a48a0843c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3c9608703080731f6446a48a0843c3">&#9670;&nbsp;</a></span>auth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::auth </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send password to Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Normally, you should not call this method. Instead, you should set password with <code>ConnectionOptions</code> or URI. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/auth">https://redis.io/commands/auth</a> </dd></dl>

</div>
</div>
<a id="ac5b48c81b338e387ade29474c0e3d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b48c81b338e387ade29474c0e3d7f9">&#9670;&nbsp;</a></span>auth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::auth </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send user and password to Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>User name. </td></tr>
    <tr><td class="paramname">password</td><td>Password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Normally, you should not call this method. Instead, you should set password with <code>ConnectionOptions</code> or URI. Also this overload only works with Redis 6.0 or later. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/auth">https://redis.io/commands/auth</a> </dd></dl>

</div>
</div>
<a id="adea0ac75d862c81071fdbcc29c9a6bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea0ac75d862c81071fdbcc29c9a6bbd">&#9670;&nbsp;</a></span>bgrewriteaof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::bgrewriteaof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite AOF in the background. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bgrewriteaof">https://redis.io/commands/bgrewriteaof</a> </dd></dl>

</div>
</div>
<a id="a6520df97e2c74a08c721a9b7ee1cc5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6520df97e2c74a08c721a9b7ee1cc5c2">&#9670;&nbsp;</a></span>bgsave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::bgsave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save database in the background. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bgsave">https://redis.io/commands/bgsave</a> </dd></dl>

</div>
</div>
<a id="ac1f9e0b894e8a37e15f9302e1edebed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f9e0b894e8a37e15f9302e1edebed9">&#9670;&nbsp;</a></span>bitcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::bitcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bits that have been set for the given range of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits that have been set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The index can be negative to index from the end of the string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitcount">https://redis.io/commands/bitcount</a> </dd></dl>

</div>
</div>
<a id="ab6f3c9b81819ebec0917c40b7dad423e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f3c9b81819ebec0917c40b7dad423e">&#9670;&nbsp;</a></span>bitop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::bitop </td>
          <td>(</td>
          <td class="paramtype">BitOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do bit operation on the string stored at <code>key</code>, and save the result to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>Bit operations. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination key where the result is saved. </td></tr>
    <tr><td class="paramname">key</td><td>The key where the string to be operated is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string saved at <code>destination</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitop">https://redis.io/commands/bitop</a> </dd>
<dd>
<code>BitOp</code> </dd></dl>

</div>
</div>
<a id="afc1453868a3ac84ed492dea113ca32d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1453868a3ac84ed492dea113ca32d1">&#9670;&nbsp;</a></span>bitpos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::bitpos </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of the first bit set to 0 or 1 in the given range of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">bit</td><td>0 or 1. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first bit set to 0 or 1. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/bitpos">https://redis.io/commands/bitpos</a> </dd></dl>

</div>
</div>
<a id="a0b3d9002f3ae0daaca3c8b05247e67a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3d9002f3ae0daaca3c8b05247e67a2">&#9670;&nbsp;</a></span>bzpopmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::bzpopmax </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with highest score from sorted set in a blocking way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. 0 means block forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key-member-score tuple with the highest score. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zpopmax</code> </dd>
<dd>
<a href="https://redis.io/commands/bzpopmax">https://redis.io/commands/bzpopmax</a> </dd></dl>

</div>
</div>
<a id="a4b34ac9573dc51fc9588282721241072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34ac9573dc51fc9588282721241072">&#9670;&nbsp;</a></span>bzpopmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::bzpopmin </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with lowest score from sorted set in a blocking way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. 0 means block forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key-member-score tuple with the lowest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty and timeout reaches, <code>bzpopmin</code> returns <code>Optional&lt;std::tuple&lt;std::string, std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zpopmin</code> </dd>
<dd>
<a href="https://redis.io/commands/bzpopmin">https://redis.io/commands/bzpopmin</a> </dd></dl>

</div>
</div>
<a id="a0d6078321046f4ce076587402ddf3789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6078321046f4ce076587402ddf3789">&#9670;&nbsp;</a></span>command()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RET  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;RET&gt; coro_redis::sync_connection::command </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send redis command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Redis command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Redis return. </dd></dl>

</div>
</div>
<a id="a98ba922d77d84750e7221f8cdbaba200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ba922d77d84750e7221f8cdbaba200">&#9670;&nbsp;</a></span>dbsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::dbsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the currently selected database. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of keys in currently selected database. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/dbsize">https://redis.io/commands/dbsize</a> </dd></dl>

</div>
</div>
<a id="aca18e4e7a5b149fa7d0ee04011c9f2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca18e4e7a5b149fa7d0ee04011c9f2e8">&#9670;&nbsp;</a></span>decr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::decr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the integer stored at key by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the decrement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/decr">https://redis.io/commands/decr</a> </dd></dl>

</div>
</div>
<a id="a50dc95b15bdcc11e46d898cc37f11091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dc95b15bdcc11e46d898cc37f11091">&#9670;&nbsp;</a></span>decrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::decrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>decrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the integer stored at key by <code>decrement</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">decrement</td><td>Decrement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the decrement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/decrby">https://redis.io/commands/decrby</a> </dd></dl>

</div>
</div>
<a id="a6958edf56899de74bf7a39b1fe76266e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6958edf56899de74bf7a39b1fe76266e">&#9670;&nbsp;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::del </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of keys removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the key exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/del">https://redis.io/commands/del</a> </dd></dl>

</div>
</div>
<a id="abd679d7509ead19c13dc3b11350ee999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd679d7509ead19c13dc3b11350ee999">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::dump </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the serialized valued stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serialized value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>dump</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/dump">https://redis.io/commands/dump</a> </dd></dl>

</div>
</div>
<a id="ab60f83377e08d6d19efc70ccce31877e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60f83377e08d6d19efc70ccce31877e">&#9670;&nbsp;</a></span>echo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::echo </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask Redis to return the given message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the given message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/echo">https://redis.io/commands/echo</a> </dd></dl>

</div>
</div>
<a id="aca67a0491696d2471a9de349b71cc024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca67a0491696d2471a9de349b71cc024">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::exists </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given key exists. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/exists">https://redis.io/commands/exists</a> </dd></dl>

</div>
</div>
<a id="a38c88ed5172f72a22b6525da2df83d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c88ed5172f72a22b6525da2df83d82">&#9670;&nbsp;</a></span>expire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::expire </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/expire">https://redis.io/commands/expire</a> </dd></dl>

</div>
</div>
<a id="aed7c34efe7c827b0fd29a8958b257c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7c34efe7c827b0fd29a8958b257c33">&#9670;&nbsp;</a></span>expireat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::expireat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key, i.e. expire the key at a future time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time in seconds since UNIX epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/expireat">https://redis.io/commands/expireat</a> </dd></dl>

</div>
</div>
<a id="a973ff504bf9cdbce9fc6803e5eb2be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973ff504bf9cdbce9fc6803e5eb2be09">&#9670;&nbsp;</a></span>flushall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::flushall </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys of all databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>Whether flushing databases asynchronously, i.e. without blocking the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/flushall">https://redis.io/commands/flushall</a> </dd></dl>

</div>
</div>
<a id="a037aa2182aeb4c0e082e0ac752e2ac66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037aa2182aeb4c0e082e0ac752e2ac66">&#9670;&nbsp;</a></span>flushdb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::flushdb </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys of current databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>Whether flushing databases asynchronously, i.e. without blocking the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/flushdb">https://redis.io/commands/flushdb</a> </dd></dl>

</div>
</div>
<a id="a7ba79e76ddf7e6b596e8ac8ee851e179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba79e76ddf7e6b596e8ac8ee851e179">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::get </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the string value stored at key. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value stored at key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>get</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/get">https://redis.io/commands/get</a> </dd></dl>

</div>
</div>
<a id="a0a1e0d8f97fb1a182f273a476be38806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1e0d8f97fb1a182f273a476be38806">&#9670;&nbsp;</a></span>getbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::getbit </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bit value at offset in the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getbit">https://redis.io/commands/getbit</a> </dd></dl>

</div>
</div>
<a id="a9517179ee4fc2ff9b26e665816657800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9517179ee4fc2ff9b26e665816657800">&#9670;&nbsp;</a></span>getrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::getrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring of the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">start</td><td>Start index (inclusive) of the range. 0 means the beginning of the string. </td></tr>
    <tr><td class="paramname">end</td><td>End index (inclusive) of the range. -1 means the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substring in range [start, end]. If key does not exist, return an empty string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getrange">https://redis.io/commands/getrange</a> </dd></dl>

</div>
</div>
<a id="a3b9247fcacc8c06c585c179a1eba4319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9247fcacc8c06c585c179a1eba4319">&#9670;&nbsp;</a></span>getset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::getset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically set the string stored at <code>key</code> to <code>val</code>, and return the old value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value stored at key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>getset</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/getset">https://redis.io/commands/getset</a> </dd>
<dd>
<code>OptionalString</code> </dd></dl>

</div>
</div>
<a id="ad0a2d34ac4f8e2eafb921f2e5e335ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a2d34ac4f8e2eafb921f2e5e335ffa">&#9670;&nbsp;</a></span>hdel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hdel </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given field from hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the field exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the field does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hdel">https://redis.io/commands/hdel</a> </dd></dl>

</div>
</div>
<a id="af8570eece0f2911d55138d7db1476561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8570eece0f2911d55138d7db1476561">&#9670;&nbsp;</a></span>hexists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hexists </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given field exists in hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field exists. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the field exists in hash. </td></tr>
    <tr><td class="paramname">false</td><td>If the field does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hexists">https://redis.io/commands/hexists</a> </dd></dl>

</div>
</div>
<a id="a18b80ef25d6388e3f30e2048bd0b9d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b80ef25d6388e3f30e2048bd0b9d26">&#9670;&nbsp;</a></span>hget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::hget </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the given field. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If field does not exist, <code>hget</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hget">https://redis.io/commands/hget</a> </dd></dl>

</div>
</div>
<a id="adfa57b60afb0b2587d1afa24f564b4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa57b60afb0b2587d1afa24f564b4ca">&#9670;&nbsp;</a></span>hgetall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::hgetall </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all field-value pairs of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; results;</div>
<div class="line"><span class="comment">// Save all field-value pairs of a Redis hash to an unordered_map&lt;string,</span></div>
<div class="line"><span class="keywordtype">string</span>&gt;. redis.hgetall(<span class="stringliteral">&quot;hash&quot;</span>, std::inserter(results, results.begin()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hgetall</code> on a large hash, since it will block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a> </dd></dl>

</div>
</div>
<a id="aaae7bdaae2cd429d5bb2e663084cfe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae7bdaae2cd429d5bb2e663084cfe86">&#9670;&nbsp;</a></span>hincrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hincrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hincrby">https://redis.io/commands/hincrby</a> </dd></dl>

</div>
</div>
<a id="a1202ad50ac7a87b0d4e1d8d335d15dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202ad50ac7a87b0d4e1d8d335d15dd2">&#9670;&nbsp;</a></span>hincrbyfloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;double&gt; coro_redis::sync_connection::hincrbyfloat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the floating point number stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hincrbyfloat">https://redis.io/commands/hincrbyfloat</a> </dd></dl>

</div>
</div>
<a id="ac1f9e5846519a42bf766df11363cf513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f9e5846519a42bf766df11363cf513">&#9670;&nbsp;</a></span>hkeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::hkeys </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all fields of the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hkeys</code> on a large hash, since it will block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hkeys">https://redis.io/commands/hkeys</a> </dd></dl>

</div>
</div>
<a id="aac758bf325df94e5c026618125c23dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac758bf325df94e5c026618125c23dfa">&#9670;&nbsp;</a></span>hlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of fields of the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of fields. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hlen">https://redis.io/commands/hlen</a> </dd></dl>

</div>
</div>
<a id="a0a1b071e1a514798be0280dffca9d523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1b071e1a514798be0280dffca9d523">&#9670;&nbsp;</a></span>hmget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::hmget </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of multiple fields. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; fields = {<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;f2&quot;</span>};</div>
<div class="line">std::vector&lt;OptionalString&gt; vals;</div>
<div class="line">redis.hmget(<span class="stringliteral">&quot;hash&quot;</span>, fields.begin(), fields.end(),</div>
<div class="line">std::back_inserter(vals)); <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : vals) {</div>
<div class="line">    <span class="keywordflow">if</span> (val)</div>
<div class="line">        std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;field not exist&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given field range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination should be a container of <code>OptionalString</code> type, since the given field might not exist (in this case, the value of the corresponding field is <code>OptionalString{}</code> (<code>std::nullopt</code>)). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hmget">https://redis.io/commands/hmget</a> </dd></dl>

</div>
</div>
<a id="a2eef1b6a59fe6fd60c4d1c92e2799032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eef1b6a59fe6fd60c4d1c92e2799032">&#9670;&nbsp;</a></span>hmset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::hmset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple field-value pairs of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; m = {{<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>}, {<span class="stringliteral">&quot;f2&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;v2&quot;</span>}}; redis.hmset(<span class="stringliteral">&quot;hash&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field-value pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hmset">https://redis.io/commands/hmset</a> </dd></dl>

</div>
</div>
<a id="ac04fe51503e5aacb3dcd732a1d4116e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04fe51503e5aacb3dcd732a1d4116e9">&#9670;&nbsp;</a></span>hscan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;scan_ret_t&gt; coro_redis::sync_connection::hscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan fields of the given hash matching the given pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hscan">https://redis.io/commands/hscan</a> </dd></dl>

</div>
</div>
<a id="a11112d772cb087c071397e87c828db95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11112d772cb087c071397e87c828db95">&#9670;&nbsp;</a></span>hscan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;scan_ret_t&gt; coro_redis::sync_connection::hscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan fields of the given hash matching the given pattern. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cursor = 0LL;</div>
<div class="line">std::unordered_map&lt;std::string, std::string&gt; kvs;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    cursor = redis.hscan(<span class="stringliteral">&quot;hash&quot;</span>, cursor, <span class="stringliteral">&quot;pattern:*&quot;</span>, 10,</div>
<div class="line">    std::inserter(kvs, kvs.begin())); <span class="keywordflow">if</span> (cursor == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hscan">https://redis.io/commands/hscan</a> </dd></dl>

</div>
</div>
<a id="ac7f00be114c01c324f1e6157165bf56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f00be114c01c324f1e6157165bf56a">&#9670;&nbsp;</a></span>hset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string_view, std::string_view &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>kvs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple fields of the given hash. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, std::string&gt; m = {{<span class="stringliteral">&quot;f1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>}, {<span class="stringliteral">&quot;f2&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;v2&quot;</span>}}; redis.hset(<span class="stringliteral">&quot;hash&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first field to be set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of fields that have been added, i.e. fields that not existed before. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hset">https://redis.io/commands/hset</a> </dd></dl>

</div>
</div>
<a id="a779efee69c5502e1b3329455a34a4db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779efee69c5502e1b3329455a34a4db7">&#9670;&nbsp;</a></span>hset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hash field to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given field is a new field. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the given field didn't exist, and a new field has been added. </td></tr>
    <tr><td class="paramname">false</td><td>If the given field already exists, and its value has been overwritten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <code>hset</code> returns false, it does not mean that the method failed to set the field. Instead, it means that the field already exists, and we've overwritten its value. If <code>hset</code> fails, it will throw an exception of <code>Exception</code> type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/sewenew/redis-plus-plus/issues/9">https://github.com/sewenew/redis-plus-plus/issues/9</a> </dd>
<dd>
<a href="https://redis.io/commands/hset">https://redis.io/commands/hset</a> </dd></dl>

</div>
</div>
<a id="acf3b53648bebb00f0d668051c8f93dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3b53648bebb00f0d668051c8f93dea">&#9670;&nbsp;</a></span>hsetnx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hsetnx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hash field to value, only if the given field does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the field has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the field has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If failed to set the field, i.e. the field already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hsetnx">https://redis.io/commands/hsetnx</a> </dd></dl>

</div>
</div>
<a id="aa660bda10ef0c0cf491d5d244b61b9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa660bda10ef0c0cf491d5d244b61b9f3">&#9670;&nbsp;</a></span>hstrlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::hstrlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string stored at the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">field</td><td>Field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/hstrlen">https://redis.io/commands/hstrlen</a> </dd></dl>

</div>
</div>
<a id="ae08f79ad848549b5fd88d16adb0c4d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08f79ad848549b5fd88d16adb0c4d28">&#9670;&nbsp;</a></span>hvals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::hvals </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get values of all fields stored at the given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the hash is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>hvals</code> on a large hash, since it might block Redis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::hscan</code> </dd>
<dd>
<a href="https://redis.io/commands/hvals">https://redis.io/commands/hvals</a> </dd></dl>

</div>
</div>
<a id="ae7b8451c9097f69bf3f2892cf0c7c834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b8451c9097f69bf3f2892cf0c7c834">&#9670;&nbsp;</a></span>incr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::incr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at key by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incr">https://redis.io/commands/incr</a> </dd></dl>

</div>
</div>
<a id="a9e8ac3675f56b6fbb4a2089f2fccdcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8ac3675f56b6fbb4a2089f2fccdcb3">&#9670;&nbsp;</a></span>incrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::incrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the integer stored at key by <code>increment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incrby">https://redis.io/commands/incrby</a> </dd></dl>

</div>
</div>
<a id="af712313772bdd6ebcfe5de0114b6aee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af712313772bdd6ebcfe5de0114b6aee7">&#9670;&nbsp;</a></span>incrbyfloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::incrbyfloat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the floating point number stored at key by <code>increment</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value after the increment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/incrbyfloat">https://redis.io/commands/incrbyfloat</a> </dd></dl>

</div>
</div>
<a id="a15f3d259a618a14cc0f97432d45b35ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f3d259a618a14cc0f97432d45b35ff">&#9670;&nbsp;</a></span>info() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the info about the server. </p>
<dl class="section return"><dt>Returns</dt><dd>Server info. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/info">https://redis.io/commands/info</a> </dd></dl>

</div>
</div>
<a id="a78b9752eff75871735b1e7347e934ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b9752eff75871735b1e7347e934ca9">&#9670;&nbsp;</a></span>info() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::info </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>section</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the info about the server on the given section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>Section. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Server info. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/info">https://redis.io/commands/info</a> </dd></dl>

</div>
</div>
<a id="a63ff798e3a7e1d0781db31cc5933fdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff798e3a7e1d0781db31cc5933fdc2">&#9670;&nbsp;</a></span>lastsave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::lastsave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UNIX timestamp in seconds, at which the database was saved successfully. </p>
<dl class="section return"><dt>Returns</dt><dd>The last saving time. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lastsave">https://redis.io/commands/lastsave</a> </dd></dl>

</div>
</div>
<a id="a8acede5cf003ab5eb0c3e2df9e980b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acede5cf003ab5eb0c3e2df9e980b5c">&#9670;&nbsp;</a></span>llen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::llen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/llen">https://redis.io/commands/llen</a> </dd></dl>

</div>
</div>
<a id="aa1afc0239cfca4cd095faeb501f1a686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1afc0239cfca4cd095faeb501f1a686">&#9670;&nbsp;</a></span>lpop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::lpop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the first element of the list. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> element = redis.lpop(<span class="stringliteral">&quot;list&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (element)</div>
<div class="line">    std::cout &lt;&lt; *element &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;list is empty, i.e. list does not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If list is empty, i.e. key does not exist, return <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpop">https://redis.io/commands/lpop</a> </dd></dl>

</div>
</div>
<a id="a3fa95b1e6d9979d21d0312ca0561bd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa95b1e6d9979d21d0312ca0561bd8b">&#9670;&nbsp;</a></span>lpush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::lpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push multiple elements to the beginning of the list. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; elements = {<span class="stringliteral">&quot;e1&quot;</span>, <span class="stringliteral">&quot;e2&quot;</span>, <span class="stringliteral">&quot;e3&quot;</span>};</div>
<div class="line">redis.lpush(<span class="stringliteral">&quot;list&quot;</span>, elements.begin(), elements.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first element to be pushed. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given element range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a> </dd></dl>

</div>
</div>
<a id="afa0be919681356eca77fe6fc7d736445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0be919681356eca77fe6fc7d736445">&#9670;&nbsp;</a></span>lpush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::lpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the beginning of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a> </dd></dl>

</div>
</div>
<a id="a6d2b6cc948c56f4483ffcde56714fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2b6cc948c56f4483ffcde56714fade">&#9670;&nbsp;</a></span>lpushx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::lpushx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the beginning of the list, only if the list already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lpushx">https://redis.io/commands/lpushx</a> </dd></dl>

</div>
</div>
<a id="a869dc52b1481c8d425920631355f13d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869dc52b1481c8d425920631355f13d6">&#9670;&nbsp;</a></span>lrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::lrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get elements in the given range of the given list. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; elements;</div>
<div class="line"><span class="comment">// Save all elements of a Redis list to a vector of string.</span></div>
<div class="line">redis.lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1, std::back_inserter(elements));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the range. Index can be negative, which mean index from the end. </td></tr>
    <tr><td class="paramname">stop</td><td>End index of the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the results are saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a> </dd></dl>

</div>
</div>
<a id="ac78db624f4c59b38fdcb832f0b2e3aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78db624f4c59b38fdcb832f0b2e3aed">&#9670;&nbsp;</a></span>lrem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::lrem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first <code>count</code> occurrences of elements equal to <code>val</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">count</td><td>Number of occurrences to be removed. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>count</code> can be positive, negative and 0. Check the reference for detail. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lrem">https://redis.io/commands/lrem</a> </dd></dl>

</div>
</div>
<a id="abaeb77a3f44cf7ddad47aaf924fe4b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaeb77a3f44cf7ddad47aaf924fe4b93">&#9670;&nbsp;</a></span>lset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::lset </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element at the given index to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the element to be set. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/lset">https://redis.io/commands/lset</a> </dd></dl>

</div>
</div>
<a id="ab203113950d44f3608659c5e1df4ed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab203113950d44f3608659c5e1df4ed05">&#9670;&nbsp;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim a list to keep only element in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the key is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start of the index. </td></tr>
    <tr><td class="paramname">stop</td><td>End of the index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ltrim">https://redis.io/commands/ltrim</a> </dd></dl>

</div>
</div>
<a id="a9a0139d41f5aba914e7d82bff8f8889c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0139d41f5aba914e7d82bff8f8889c">&#9670;&nbsp;</a></span>mget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::mget </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values of multiple keys atomically. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;k3&quot;</span>};</div>
<div class="line">std::vector&lt;OptionalString&gt; vals;</div>
<div class="line">redis.mget(keys.begin(), keys.end(), std::back_inserter(vals));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : vals) {</div>
<div class="line">    <span class="keywordflow">if</span> (val)</div>
<div class="line">        std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;key does not exist&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first key of the given range. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the given range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the values are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination should be a container of <code>OptionalString</code> type, since the given key might not exist (in this case, the value of the corresponding key is <code>OptionalString{}</code> (<code>std::nullopt</code>)). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/mget">https://redis.io/commands/mget</a> </dd></dl>

</div>
</div>
<a id="a76343bfb5e24a0b78a590c3fba4e8eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76343bfb5e24a0b78a590c3fba4e8eee">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::move </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get keys matching the given pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Pattern. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the returned keys are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It's always a bad idea to call <code>keys</code>, since it might block Redis for a long time, especially when the data set is very big. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::scan</code> </dd>
<dd>
<a href="https://redis.io/commands/keys">https://redis.io/commands/keys</a></dd></dl>
<p>Move a key to the given database. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">db</td><td>The destination database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether key has been moved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If key has been moved. </td></tr>
    <tr><td class="paramname">false</td><td>If key was not moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/move">https://redis.io/commands/move</a> </dd></dl>

</div>
</div>
<a id="aec2550cd1e6ecf4375e0b84c2fdb1b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2550cd1e6ecf4375e0b84c2fdb1b5f">&#9670;&nbsp;</a></span>mset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::mset </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple key-value pairs. </p>
<p>Example: </p><div class="fragment"><div class="line">redis.mset({std::make_pair(<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;v1&quot;</span>), std::make_pair(<span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;v2&quot;</span>)});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>Initializer list of key-value pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/mset">https://redis.io/commands/mset</a> </dd></dl>

</div>
</div>
<a id="af6a6b432cc9a913e8d4925e56dc5e15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a6b432cc9a913e8d4925e56dc5e15f">&#9670;&nbsp;</a></span>msetnx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::msetnx </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the given key-value pairs if all specified keys do not exist. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; kvs1;</div>
<div class="line">redis.msetnx(kvs1.begin(), kvs1.end());</div>
<div class="line">std::unordered_map&lt;std::string, std::string&gt; kvs2;</div>
<div class="line">redis.msetnx(kvs2.begin(), kvs2.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first key-value pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator of the given range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether all keys have been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If all keys have been set. </td></tr>
    <tr><td class="paramname">false</td><td>If no key was set, i.e. at least one key already exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/msetnx">https://redis.io/commands/msetnx</a> </dd></dl>

</div>
</div>
<a id="a8da5a6f69128f110d67ca6bc4eb3bd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da5a6f69128f110d67ca6bc4eb3bd07">&#9670;&nbsp;</a></span>persist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::persist </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been removed. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist, or does not have an associated timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/persist">https://redis.io/commands/persist</a> </dd></dl>

</div>
</div>
<a id="aa14ae1d238744081a1570e676256a2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14ae1d238744081a1570e676256a2e8">&#9670;&nbsp;</a></span>pexpire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::pexpire </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pexpire">https://redis.io/commands/pexpire</a> </dd></dl>

</div>
</div>
<a id="a5716f4fdca8272a6ffd38c57fedb1088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5716f4fdca8272a6ffd38c57fedb1088">&#9670;&nbsp;</a></span>pexpireat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::pexpireat </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout on key, i.e. expire the key at a future time point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time in milliseconds since UNIX epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether timeout has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If timeout has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pexpireat">https://redis.io/commands/pexpireat</a> </dd></dl>

</div>
</div>
<a id="a18dcfb45101588a54b5aea7787e9c272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18dcfb45101588a54b5aea7787e9c272">&#9670;&nbsp;</a></span>pfadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::pfadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given element to a hyperloglog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of the hyperloglog. </td></tr>
    <tr><td class="paramname">element</td><td>Element to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether any of hyperloglog's internal register has been altered. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If at least one internal register has been altered. </td></tr>
    <tr><td class="paramname">false</td><td>If none of internal registers has been altered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <code>pfadd</code> returns false, it does not mean that this method failed to add an element to the hyperloglog. Instead it means that the internal registers were not altered. If <code>pfadd</code> fails, it will throw an exception of <code>Exception</code> type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pfadd">https://redis.io/commands/pfadd</a> </dd></dl>

</div>
</div>
<a id="acaad69eb23ad0decead6f30aeb2847ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaad69eb23ad0decead6f30aeb2847ac">&#9670;&nbsp;</a></span>ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::ping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connection is alive. </p>
<dl class="section return"><dt>Returns</dt><dd>Always return <em>PONG</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ping">https://redis.io/commands/ping</a> </dd></dl>

</div>
</div>
<a id="ad338e0e6956388ffb70105417ba09ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad338e0e6956388ffb70105417ba09ef2">&#9670;&nbsp;</a></span>ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::ping </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connection is alive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message sent to Redis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the given message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ping">https://redis.io/commands/ping</a> </dd></dl>

</div>
</div>
<a id="a57d5e52a622b6f8f01c47910f20daa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d5e52a622b6f8f01c47910f20daa65">&#9670;&nbsp;</a></span>psetex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::psetex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set key-value pair with the given timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">ttl</td><td>Time-To-Live in milliseconds. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/psetex">https://redis.io/commands/psetex</a> </dd></dl>

</div>
</div>
<a id="afc9411f4841c7b1e54b10ff1c3a0d218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9411f4841c7b1e54b10ff1c3a0d218">&#9670;&nbsp;</a></span>pttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::pttl </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the TTL of a key in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TTL of the key in milliseconds. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/pttl">https://redis.io/commands/pttl</a> </dd></dl>

</div>
</div>
<a id="a7b4783c929f1efd8371d0801e0e2ba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4783c929f1efd8371d0801e0e2ba40">&#9670;&nbsp;</a></span>quit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After sending QUIT, only the current connection will be close, while other connections in the pool is still open. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/quit">https://redis.io/commands/quit</a> </dd></dl>

</div>
</div>
<a id="a00b596fd668b7cdfb2d2cf24bca37e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b596fd668b7cdfb2d2cf24bca37e97">&#9670;&nbsp;</a></span>randomkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::randomkey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random key from current database. </p>
<dl class="section return"><dt>Returns</dt><dd>A random key. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the database is empty, <code>randomkey</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/randomkey">https://redis.io/commands/randomkey</a> </dd></dl>

</div>
</div>
<a id="a6550563bb98bc89e95576881aa46c151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6550563bb98bc89e95576881aa46c151">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::rename </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>newkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename <code>key</code> to <code>newkey</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be renamed. </td></tr>
    <tr><td class="paramname">newkey</td><td>The new name of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rename">https://redis.io/commands/rename</a> </dd></dl>

</div>
</div>
<a id="ab09b8fdfe64e266e2d5d71690bc58365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09b8fdfe64e266e2d5d71690bc58365">&#9670;&nbsp;</a></span>renamenx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::renamenx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>newkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename <code>key</code> to <code>newkey</code> if <code>newkey</code> does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to be renamed. </td></tr>
    <tr><td class="paramname">newkey</td><td>The new name of the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether key has been renamed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If key has been renamed. </td></tr>
    <tr><td class="paramname">false</td><td>If newkey already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/renamenx">https://redis.io/commands/renamenx</a> </dd></dl>

</div>
</div>
<a id="a7a67ef541e7f9af72f65660d8cc0ae6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a67ef541e7f9af72f65660d8cc0ae6b">&#9670;&nbsp;</a></span>restore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::restore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a key with the value obtained by <code>Redis::dump</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value obtained by <code>Redis::dump</code>. </td></tr>
    <tr><td class="paramname">ttl</td><td>Timeout of the created key in milliseconds. If <code>ttl</code> is 0, set no timeout. </td></tr>
    <tr><td class="paramname">replace</td><td>Whether to overwrite an existing key. If <code>replace</code> is <code>true</code> and key already exists, throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/restore">https://redis.io/commands/restore</a> </dd></dl>

</div>
</div>
<a id="a0e285e1e3cd3aa652fa7d599bb39f0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e285e1e3cd3aa652fa7d599bb39f0d3">&#9670;&nbsp;</a></span>rpop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::rpop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the list is empty, i.e. key does not exist, <code>rpop</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpop">https://redis.io/commands/rpop</a> </dd></dl>

</div>
</div>
<a id="a8b63db9752f6fd89bc1c3f46df673948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b63db9752f6fd89bc1c3f46df673948">&#9670;&nbsp;</a></span>rpoplpush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::rpoplpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop last element of one list and push it to the left of another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Key of the source list. </td></tr>
    <tr><td class="paramname">destination</td><td>Key of the destination list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the source list does not exist, <code>rpoplpush</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/brpoplpush">https://redis.io/commands/brpoplpush</a> </dd></dl>

</div>
</div>
<a id="ae3e846977434a90b982c15cc45b26952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e846977434a90b982c15cc45b26952">&#9670;&nbsp;</a></span>rpush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::rpush </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpush">https://redis.io/commands/rpush</a> </dd></dl>

</div>
</div>
<a id="a3d8a341f8d8b323636c7fb6b33918688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8a341f8d8b323636c7fb6b33918688">&#9670;&nbsp;</a></span>rpushx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::rpushx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the end of the list, only if the list already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the list is stored. </td></tr>
    <tr><td class="paramname">val</td><td>Element to be pushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the list after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/rpushx">https://redis.io/commands/rpushx</a> </dd></dl>

</div>
</div>
<a id="af6fbbde1c561945ca1ca779f1839cf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fbbde1c561945ca1ca779f1839cf36">&#9670;&nbsp;</a></span>sadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::sadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a member to the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given member is a new member. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>The member did not exist before, and it has been added now. </td></tr>
    <tr><td class="paramname">0</td><td>The member already exists before this operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sadd">https://redis.io/commands/sadd</a> </dd></dl>

</div>
</div>
<a id="a366897d89451850b1215558b11f960e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366897d89451850b1215558b11f960e5">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save databases into RDB file <b>synchronously</b>, i.e. block the server during saving. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/save">https://redis.io/commands/save</a> </dd></dl>

</div>
</div>
<a id="ac030b5b0963467561bc6bb04dd5ef794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac030b5b0963467561bc6bb04dd5ef794">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;scan_ret_t&gt; coro_redis::sync_connection::scan </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan keys of the database matching the given pattern. </p>
<p>Example: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of the keys to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many keys to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the returned keys are stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> TODO: support the TYPE option for Redis 6.0. </dd></dl>

</div>
</div>
<a id="a2af47f8fc3f26fd6c4fab66619cabd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af47f8fc3f26fd6c4fab66619cabd33">&#9670;&nbsp;</a></span>scard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::scard </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/scard">https://redis.io/commands/scard</a> </dd></dl>

</div>
</div>
<a id="a3acfa502f1a2ab9ef263628592c8b149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acfa502f1a2ab9ef263628592c8b149">&#9670;&nbsp;</a></span>sdiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::sdiff </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the difference between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sdiff">https://redis.io/commands/sdiff</a> </dd></dl>

</div>
</div>
<a id="a3545e120cf70e86075cb362ed5105651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3545e120cf70e86075cb362ed5105651">&#9670;&nbsp;</a></span>sdiffstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::sdiffstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sdiffstore">https://redis.io/commands/sdiffstore</a> </dd></dl>

</div>
</div>
<a id="a52e0688b6734eec25e2fb63ea3a94464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e0688b6734eec25e2fb63ea3a94464">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::select </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the Redis logical database. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/select">https://redis.io/commands/select</a> </dd></dl>

</div>
</div>
<a id="a4e7ddd32b687869d59a1f5099ced4ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7ddd32b687869d59a1f5099ced4ee1">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;RedisSetValueType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::set </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedisTTLType&#160;</td>
          <td class="paramname"><em>ttl_type</em> = <code>RedisTTLType::EX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a key-value pair. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Set a key-value pair.</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"><span class="comment">// Set a key-value pair, and expire it after 10 seconds.</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, std::chrono::seconds(10));</div>
<div class="line"><span class="comment">// Set a key-value pair with a timeout, only if the key already exists.</span></div>
<div class="line"><span class="keywordflow">if</span> (redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, std::chrono::seconds(10),</div>
<div class="line">UpdateType::EXIST))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;OK&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key does not exist&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
    <tr><td class="paramname">ttl</td><td>Timeout on the key. If <code>ttl</code> is 0ms, do not set timeout. </td></tr>
    <tr><td class="paramname">type</td><td>Options for set command:<ul>
<li>UpdateType::EXIST: Set the key only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Set the key only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always set the key no matter whether it exists. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the key has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If the key was not set, because of the given option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/set">https://redis.io/commands/set</a> </dd></dl>

</div>
</div>
<a id="a21a1df055586b26f637bc94800a871af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a1df055586b26f637bc94800a871af">&#9670;&nbsp;</a></span>setex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::setex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set key-value pair with the given timeout in seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">ttl</td><td>Time-To-Live in seconds. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setex">https://redis.io/commands/setex</a> </dd></dl>

</div>
</div>
<a id="a293ddc35925035864afa9803e362f5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293ddc35925035864afa9803e362f5fa">&#9670;&nbsp;</a></span>setnx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::setnx </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the key if it does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the key has been set. </td></tr>
    <tr><td class="paramname">false</td><td>If the key was not set, i.e. the key already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setnx">https://redis.io/commands/setnx</a> </dd></dl>

</div>
</div>
<a id="aca632d2ffa22b25f4e29350a937fa96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca632d2ffa22b25f4e29350a937fa96f">&#9670;&nbsp;</a></span>setrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::setrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the substring starting from <code>offset</code> to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset. </td></tr>
    <tr><td class="paramname">val</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string after this operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/setrange">https://redis.io/commands/setrange</a> </dd></dl>

</div>
</div>
<a id="a69d9b68f21d16af08b253254100da453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d9b68f21d16af08b253254100da453">&#9670;&nbsp;</a></span>sinter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::sinter </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the intersection between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sinter">https://redis.io/commands/sinter</a> </dd></dl>

</div>
</div>
<a id="a9e5bab9de9a8acdef435ccc594696f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5bab9de9a8acdef435ccc594696f05">&#9670;&nbsp;</a></span>sinterstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::sinterstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sinter">https://redis.io/commands/sinter</a> </dd></dl>

</div>
</div>
<a id="a0ea74d9b4ebc55cbf7d3aaa8b62f7efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea74d9b4ebc55cbf7d3aaa8b62f7efd">&#9670;&nbsp;</a></span>sismember()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::sismember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if <code>member</code> exists in the set stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>member</code> exists in the set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If it exists in the set. </td></tr>
    <tr><td class="paramname">false</td><td>If it does not exist in the set, or the given key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sismember">https://redis.io/commands/sismember</a> </dd></dl>

</div>
</div>
<a id="ad94bed2239591235d3f6b1968592b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94bed2239591235d3f6b1968592b94c">&#9670;&nbsp;</a></span>smembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::smembers </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all members in the given set. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_set&lt;std::string&gt; members1;</div>
<div class="line">redis.smembers(<span class="stringliteral">&quot;set&quot;</span>, std::inserter(members1, members1.begin()));</div>
<div class="line">std::vector&lt;std::string&gt; members2;</div>
<div class="line">redis.smembers(<span class="stringliteral">&quot;set&quot;</span>, std::back_inserter(members2));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">output</td><td>Iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a> </dd></dl>

</div>
</div>
<a id="a7d28229bd7449de6567d1afa1878fdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d28229bd7449de6567d1afa1878fdbe">&#9670;&nbsp;</a></span>smove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::smove </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move <code>member</code> from one set to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Key of the set in which the member currently exists. </td></tr>
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been moved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the member has been moved. </td></tr>
    <tr><td class="paramname">false</td><td>If <code>member</code> does not exist in <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/smove">https://redis.io/commands/smove</a> </dd></dl>

</div>
</div>
<a id="a27446ca9cb630942fda7cee06c203450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27446ca9cb630942fda7cee06c203450">&#9670;&nbsp;</a></span>spop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::spop </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a random member from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The popped member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the set is empty, <code>spop</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::srandmember</code> </dd>
<dd>
<a href="https://redis.io/commands/spop">https://redis.io/commands/spop</a> </dd></dl>

</div>
</div>
<a id="a5ccb33103c2ce71b60fb8b0b8b9ccb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccb33103c2ce71b60fb8b0b8b9ccb80">&#9670;&nbsp;</a></span>srandmember() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::srandmember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random member of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the set is empty, <code>srandmember</code> returns <code>OptionalString{}</code> (<code>std::nullopt</code>). </dd>
<dd>
This method won't remove the member from the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::spop</code> </dd>
<dd>
<a href="https://redis.io/commands/srandmember">https://redis.io/commands/srandmember</a> </dd></dl>

</div>
</div>
<a id="a42911430edd683362689ce345720b374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42911430edd683362689ce345720b374">&#9670;&nbsp;</a></span>srandmember() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::srandmember </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get multiple random members of the given set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">count</td><td>Number of members to be returned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method won't remove members from the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::spop</code> </dd>
<dd>
<a href="https://redis.io/commands/srandmember">https://redis.io/commands/srandmember</a> </dd></dl>

</div>
</div>
<a id="aef5e63bae2c40ebe1efcbfc5f89d3e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5e63bae2c40ebe1efcbfc5f89d3e7d">&#9670;&nbsp;</a></span>srem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::srem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a member from set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the given member exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the given member does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/srem">https://redis.io/commands/srem</a> </dd></dl>

</div>
</div>
<a id="ab5e047988a9573a925818072bf0b999a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e047988a9573a925818072bf0b999a">&#9670;&nbsp;</a></span>sscan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;scan_ret_t&gt; coro_redis::sync_connection::sscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan members of the set matching the given pattern. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cursor = 0LL;</div>
<div class="line">std::unordered_set&lt;std::string&gt; members;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    cursor = redis.sscan(<span class="stringliteral">&quot;set&quot;</span>, cursor, <span class="stringliteral">&quot;pattern:*&quot;</span>,</div>
<div class="line">        10, std::inserter(members, members.begin()));</div>
<div class="line">    <span class="keywordflow">if</span> (cursor == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of fields to be scanned. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many fields to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sscan">https://redis.io/commands/sscan</a> </dd></dl>

</div>
</div>
<a id="a0d217b4e4a1d94d099aefffaaf9cefd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d217b4e4a1d94d099aefffaaf9cefd5">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::strlen </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If key does not exist, <code>strlen</code> returns 0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/strlen">https://redis.io/commands/strlen</a> </dd></dl>

</div>
</div>
<a id="a0122d161b3ecc2b60866dd56d722c847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0122d161b3ecc2b60866dd56d722c847">&#9670;&nbsp;</a></span>sunion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::sunion </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the union between the first set and all successive sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first set. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the range. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sunion">https://redis.io/commands/sunion</a> </dd></dl>

</div>
</div>
<a id="a5aa2e92682a3ecfe13d3339a941217c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa2e92682a3ecfe13d3339a941217c6">&#9670;&nbsp;</a></span>sunionstore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::sunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy set stored at <code>key</code> to <code>destination</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members of the set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/sunionstore">https://redis.io/commands/sunionstore</a> </dd></dl>

</div>
</div>
<a id="a19929d3c807a31bc2ebd7de4f9f57e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19929d3c807a31bc2ebd7de4f9f57e6a">&#9670;&nbsp;</a></span>swapdb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::swapdb </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two Redis databases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx1</td><td>The index of the first database. </td></tr>
    <tr><td class="paramname">idx2</td><td>The index of the second database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/swapdb">https://redis.io/commands/swapdb</a> </dd></dl>

</div>
</div>
<a id="ac7c452c37db380cf791bd69f5ee32642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c452c37db380cf791bd69f5ee32642">&#9670;&nbsp;</a></span>touch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::touch </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the last access time of the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether last access time of the key has been updated. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists, and last access time has been updated. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/touch">https://redis.io/commands/touch</a> </dd></dl>

</div>
</div>
<a id="a6eae6cadf59a057457b3601d884de117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eae6cadf59a057457b3601d884de117">&#9670;&nbsp;</a></span>ttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::ttl </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining Time-To-Live of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TTL in seconds. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TTL</td><td>If the key has a timeout. </td></tr>
    <tr><td class="paramname">-1</td><td>If the key exists but does not have a timeout. </td></tr>
    <tr><td class="paramname">-2</td><td>If the key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Redis 2.6 or older, <code>ttl</code> returns -1 if the key does not exist, or if the key exists but does not have a timeout. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/ttl">https://redis.io/commands/ttl</a> </dd></dl>

</div>
</div>
<a id="a5632e80e4f17fce42def24e72683f749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5632e80e4f17fce42def24e72683f749">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::type </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the value stored at key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/type">https://redis.io/commands/type</a> </dd></dl>

</div>
</div>
<a id="a713392dcd6524ad1c51631791d3fc86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713392dcd6524ad1c51631791d3fc86f">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::unlink </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given key asynchronously, i.e. without blocking Redis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If key exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/unlink">https://redis.io/commands/unlink</a> </dd></dl>

</div>
</div>
<a id="af0af3d04793664999ab17407fdb93582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0af3d04793664999ab17407fdb93582">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::wait </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numslaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until previous write commands are successfully replicated to at least the specified number of replicas or the given timeout has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numslaves</td><td>Number of replicas. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. If timeout is 0ms, wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of replicas that have been successfully replicated these write commands. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The return value might be less than <code>numslaves</code>, because timeout has been reached. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/wait">https://redis.io/commands/wait</a> </dd></dl>

</div>
</div>
<a id="aca4ea586a6846db30d565f2b4d1f6718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4ea586a6846db30d565f2b4d1f6718">&#9670;&nbsp;</a></span>zadd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update multiple members with score to sorted set. </p>
<p>Example: </p><div class="fragment"><div class="line">redis.zadd(<span class="stringliteral">&quot;zset&quot;</span>, {std::make_pair(<span class="stringliteral">&quot;m1&quot;</span>, 1.4),</div>
<div class="line">std::make_pair(<span class="stringliteral">&quot;m2&quot;</span>, 2.3)});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first member-score pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the member-score pairs range. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: `auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");<code> @see</code>UpdateType` </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="af26c38b137bc676a25f9a6a634f2c50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c38b137bc676a25f9a6a634f2c50f">&#9670;&nbsp;</a></span>zadd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update a member with score to sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be added. </td></tr>
    <tr><td class="paramname">score</td><td>Score of the member. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: `auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");<code> @see</code>UpdateType` </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="af035262f38c3966ae292f99cfd683ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af035262f38c3966ae292f99cfd683ef8">&#9670;&nbsp;</a></span>zadd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zadd </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt;&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateType&#160;</td>
          <td class="paramname"><em>type</em> = <code>UpdateType::ALWAYS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or update multiple members with score to sorted set. </p>
<p>Example: </p><div class="fragment"><div class="line">std::unordered_map&lt;std::string, double&gt; m = {{<span class="stringliteral">&quot;m1&quot;</span>, 1.2}, {<span class="stringliteral">&quot;m2&quot;</span>, 2.3}};</div>
<div class="line">redis.zadd(<span class="stringliteral">&quot;zset&quot;</span>, m.begin(), m.end());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first member-score pair. </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the member-score pairs range. </td></tr>
    <tr><td class="paramname">type</td><td>Options for zadd command:<ul>
<li>UpdateType::EXIST: Add the member only if it already exists.</li>
<li>UpdateType::NOT_EXIST: Add the member only if it does not exist.</li>
<li>UpdateType::ALWAYS: Always add the member no matter whether it exists. </li>
</ul>
</td></tr>
    <tr><td class="paramname">changed</td><td>Whether change the return value from number of newly added member to number of members changed (i.e. added and updated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of added members or number of added and updated members depends on <code>changed</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We don't support the INCR option, because in this case, the return value of zadd command is NOT of type uint64_t. However, you can always use the generic interface to send zadd command with INCR option: `auto score = redis.command&lt;OptionalDouble&gt;("ZADD", "key", "XX", "INCR", 10, "mem");<code> @see</code>UpdateType` </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a> </dd></dl>

</div>
</div>
<a id="a1899bd5c7694a7062135d911809caedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1899bd5c7694a7062135d911809caedc">&#9670;&nbsp;</a></span>zcard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zcard </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members in the sorted set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zcard">https://redis.io/commands/zcard</a> </dd></dl>

</div>
</div>
<a id="a3c9d4afb84826de42cb5b62a19c6043e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9d4afb84826de42cb5b62a19c6043e">&#9670;&nbsp;</a></span>zcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members with score between a min-max score range. </p>
<p>Example: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>The min-max score range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members with score between a min-max score range. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zcount">https://redis.io/commands/zcount</a> </dd></dl>

</div>
</div>
<a id="ab8ba5b7962b54fd4b1aad9633caf9c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ba5b7962b54fd4b1aad9633caf9c70">&#9670;&nbsp;</a></span>zincrby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;double&gt; coro_redis::sync_connection::zincrby </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the score of given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">increment</td><td>Increment. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The score of the member after the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zincrby">https://redis.io/commands/zincrby</a> </dd></dl>

</div>
</div>
<a id="ad47413eb7fd039ffe15fc9d706ffc951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47413eb7fd039ffe15fc9d706ffc951">&#9670;&nbsp;</a></span>zlexcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zlexcount </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of members between a min-max range in lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>The min-max range in lexicographical order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members between a min-max range in lexicographical order. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zlexcount">https://redis.io/commands/zlexcount</a> </dd></dl>

</div>
</div>
<a id="ac479fdadfcd5a73e6090eb9a34a62d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac479fdadfcd5a73e6090eb9a34a62d72">&#9670;&nbsp;</a></span>zpopmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::zpopmax </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with highest score from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Member-score pair with the highest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty <code>zpopmax</code> returns <code>Optional&lt;std::pair&lt;std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::bzpopmax</code> </dd>
<dd>
<a href="https://redis.io/commands/zpopmax">https://redis.io/commands/zpopmax</a> </dd></dl>

</div>
</div>
<a id="a0a86c321ca701916d5b94579c607a3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a86c321ca701916d5b94579c607a3dd">&#9670;&nbsp;</a></span>zpopmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::zpopmin </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the member with lowest score from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Member-score pair with the lowest score. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If sorted set is empty <code>zpopmin</code> returns <code>Optional&lt;std::pair&lt;std::string, double&gt;&gt;{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::bzpopmin</code> </dd>
<dd>
<a href="https://redis.io/commands/zpopmin">https://redis.io/commands/zpopmin</a> </dd></dl>

</div>
</div>
<a id="a4f1b0a77c6763bdc39fd857250921938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1b0a77c6763bdc39fd857250921938">&#9670;&nbsp;</a></span>zrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::zrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by rank (ordered from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// send *ZRANGE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line">redis.zrange(<span class="stringliteral">&quot;zset&quot;</span>, 0, -1, std::back_inserter(result));</div>
<div class="line"><span class="comment">// send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line">redis.zrange(<span class="stringliteral">&quot;zset&quot;</span>, 0, -1, std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZRANGE key start stop</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZRANGE key start stop WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrevrange</code> </dd>
<dd>
<a href="https://redis.io/commands/zrange">https://redis.io/commands/zrange</a> </dd></dl>

</div>
</div>
<a id="a89b4d51a2f28157e6cb81a589e445731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b4d51a2f28157e6cb81a589e445731">&#9670;&nbsp;</a></span>zrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::zrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by lexicographical order (from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members between [abc, abd].</span></div>
<div class="line">redis.zrangebylex(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;std::string&gt;(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;abd&quot;</span>,</div>
<div class="line">BoundType::CLOSED),</div>
<div class="line">    std::back_inserter(result));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<code>Redis::zrevrangebylex</code> </dd>
<dd>
<a href="https://redis.io/commands/zrangebylex">https://redis.io/commands/zrangebylex</a> </dd></dl>

</div>
</div>
<a id="a97bf1f2fe56660f26a53d0b71bf4243c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bf1f2fe56660f26a53d0b71bf4243c">&#9670;&nbsp;</a></span>zrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;std::string&gt; &gt; coro_redis::sync_connection::zrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by score (ordered from lowest to highest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Send *ZRANGEBYSCORE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members whose score between (3, 6).</span></div>
<div class="line">redis.zrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;double&gt;(3, 6,</div>
<div class="line">BoundType::OPEN),</div>
<div class="line">    std::back_inserter(result));</div>
<div class="line"><span class="comment">// Send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line"><span class="comment">// Get members whose score between [3, +inf).</span></div>
<div class="line">redis.zrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, LeftBoundedInterval&lt;double&gt;(3,</div>
<div class="line">BoundType::RIGHT_OPEN),</div>
<div class="line">    std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZRANGEBYSCORE key min max</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZRANGEBYSCORE key min max WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd>
<dd>
See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrevrangebyscore</code> </dd>
<dd>
<a href="https://redis.io/commands/zrangebyscore">https://redis.io/commands/zrangebyscore</a> </dd></dl>

</div>
</div>
<a id="a8ac3a542530b763f93e6415cf07262c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac3a542530b763f93e6415cf07262c1">&#9670;&nbsp;</a></span>zrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank (from low to high) of the given member in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the given member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the member does not exist, <code>zrank</code> returns <code>OptionalLongLong{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrank">https://redis.io/commands/zrank</a> </dd></dl>

</div>
</div>
<a id="a8574c36c767212ce31a414a81f3caaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8574c36c767212ce31a414a81f3caaeb">&#9670;&nbsp;</a></span>zrem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zrem </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given member from sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the member has been removed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the member exists, and has been removed. </td></tr>
    <tr><td class="paramname">0</td><td>If the member does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrem">https://redis.io/commands/zrem</a> </dd></dl>

</div>
</div>
<a id="af13cefa891315665675637e10fb7a231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13cefa891315665675637e10fb7a231">&#9670;&nbsp;</a></span>zremrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zremrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range of lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<a href="https://redis.io/commands/zremrangebylex">https://redis.io/commands/zremrangebylex</a> </dd></dl>

</div>
</div>
<a id="a57d6e14929aced75d8c19c31b7da1250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d6e14929aced75d8c19c31b7da1250">&#9670;&nbsp;</a></span>zremrangebyrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zremrangebyrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range ordered by rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zremrangebyrank">https://redis.io/commands/zremrangebyrank</a> </dd></dl>

</div>
</div>
<a id="a1d9894009ee0145f00b4c871d0d45170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9894009ee0145f00b4c871d0d45170">&#9670;&nbsp;</a></span>zremrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zremrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove members in the given range ordered by score. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of members removed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zremrangebyscore">https://redis.io/commands/zremrangebyscore</a> </dd></dl>

</div>
</div>
<a id="ad77fd44236d42c98b443b0da8ad50f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77fd44236d42c98b443b0da8ad50f00">&#9670;&nbsp;</a></span>zrevrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::zrevrange </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withscores</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by rank (ordered from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// send *ZREVRANGE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line">redis.zrevrange(<span class="stringliteral">&quot;key&quot;</span>, 0, -1, std::back_inserter(result));</div>
<div class="line"><span class="comment">// send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line">redis.zrevrange(<span class="stringliteral">&quot;key&quot;</span>, 0, -1, std::inserter(with_score,</div>
<div class="line">with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">start</td><td>Start rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">stop</td><td>Stop rank. Inclusive and can be negative. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZREVRANGE key start stop</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZREVRANGE key start stop WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrange</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrange">https://redis.io/commands/zrevrange</a> </dd></dl>

</div>
</div>
<a id="a8380c249876f306ccbd241d1ba418384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8380c249876f306ccbd241d1ba418384">&#9670;&nbsp;</a></span>zrevrangebylex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::zrevrangebylex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by lexicographical order (from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members between [abc, abd] in reverse order.</span></div>
<div class="line">redis.zrevrangebylex(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;std::string&gt;(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;abd&quot;</span>,</div>
<div class="line">BoundType::CLOSED),</div>
<div class="line">    std::back_inserter(result));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by lexicographical order. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>Redis::zlexcount</code>'s <em>Example</em> part for how to set <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zlexcount</code> </dd>
<dd>
<code>BoundedInterval</code> </dd>
<dd>
<code>LeftBoundedInterval</code> </dd>
<dd>
<code>RightBoundedInterval</code> </dd>
<dd>
<code>UnboundedInterval</code> </dd>
<dd>
<code>BoundType</code> </dd>
<dd>
<code>Redis::zrangebylex</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrangebylex">https://redis.io/commands/zrevrangebylex</a> </dd></dl>

</div>
</div>
<a id="a5a133e530f486616c51712869a90079b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a133e530f486616c51712869a90079b">&#9670;&nbsp;</a></span>zrevrangebyscore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Interval , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::string&gt; coro_redis::sync_connection::zrevrangebyscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of members by score (ordered from highest to lowest). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Send *ZREVRANGEBYSCORE* command without the *WITHSCORES* option:</span></div>
<div class="line">std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="comment">// Get members whose score between (3, 6) in reverse order.</span></div>
<div class="line">redis.zrevrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, BoundedInterval&lt;double&gt;(3, 6,</div>
<div class="line">BoundType::OPEN),</div>
<div class="line">    std::back_inserter(result));</div>
<div class="line"><span class="comment">// Send command with *WITHSCORES* option:</span></div>
<div class="line">std::unordered_map&lt;std::string, double&gt; with_score;</div>
<div class="line"><span class="comment">// Get members whose score between [3, +inf) in reverse order.</span></div>
<div class="line">redis.zrevrangebyscore(<span class="stringliteral">&quot;zset&quot;</span>, LeftBoundedInterval&lt;double&gt;(3,</div>
<div class="line">BoundType::RIGHT_OPEN),</div>
<div class="line">    std::inserter(with_score, with_score.end()));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">interval</td><td>the min-max range by score. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method can also return the score of each member. If <code>output</code> is an iterator to a container of <code>std::string</code>, we send <em>ZREVRANGEBYSCORE key min max</em> command. If it's an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, we send <em>ZREVRANGEBYSCORE key min max WITHSCORES</em> command. See the <em>Example</em> part on how to use this method. </dd>
<dd>
See <code>Redis::zcount</code>'s <em>Example</em> part for how to set the <code>interval</code> parameter. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zrangebyscore</code> </dd>
<dd>
<a href="https://redis.io/commands/zrevrangebyscore">https://redis.io/commands/zrevrangebyscore</a> </dd></dl>

</div>
</div>
<a id="a9874f8029b9caedeb6119c882b30782c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9874f8029b9caedeb6119c882b30782c">&#9670;&nbsp;</a></span>zrevrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zrevrank </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank (from high to low) of the given member in the sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the given member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the member does not exist, <code>zrevrank</code> returns <code>OptionalLongLong{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zrevrank">https://redis.io/commands/zrevrank</a> </dd></dl>

</div>
</div>
<a id="a5458557b358e5baabf7155735d15f109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5458557b358e5baabf7155735d15f109">&#9670;&nbsp;</a></span>zscan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;scan_ret_t&gt; coro_redis::sync_connection::zscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan all members of the given sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscan">https://redis.io/commands/zscan</a> </dd></dl>

</div>
</div>
<a id="a3b0d52df360988afadede40587582f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0d52df360988afadede40587582f61">&#9670;&nbsp;</a></span>zscan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zscan </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan all members of the given sorted set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">cursor</td><td>Cursor. </td></tr>
    <tr><td class="paramname">count</td><td>A hint for how many members to be scanned. </td></tr>
    <tr><td class="paramname">output</td><td>Output iterator to the destination where the result is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cursor to be used for the next scan operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscan">https://redis.io/commands/zscan</a> </dd></dl>

</div>
</div>
<a id="af14939ea99f37b8bae8520a88972be52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14939ea99f37b8bae8520a88972be52">&#9670;&nbsp;</a></span>zscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;double&gt; coro_redis::sync_connection::zscore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the score of the given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key where the sorted set is stored. </td></tr>
    <tr><td class="paramname">member</td><td>Member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The score of the member. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If member does not exist, <code>zscore</code> returns <code>OptionalDouble{}</code> (<code>std::nullopt</code>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://redis.io/commands/zscore">https://redis.io/commands/zscore</a> </dd></dl>

</div>
</div>
<a id="ab7333bb9b68345b6c723fb097cdddd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7333bb9b68345b6c723fb097cdddd57">&#9670;&nbsp;</a></span>zunionstore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::string_view &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>aggregate</em> = <code>&quot;SUM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sorted set to another one with the scores being multiplied by a factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination sorted set. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the source sorted set. </td></tr>
    <tr><td class="paramname">weight</td><td>Weight to be multiplied to the score of each member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of members in the sorted set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There's no aggregation type parameter for single key overload, since these 3 types have the same effect. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zinterstore</code> </dd>
<dd>
<a href="https://redis.io/commands/zinterstore">https://redis.io/commands/zinterstore</a> </dd></dl>

</div>
</div>
<a id="adaf5f46b62f853f383cb8fb3d7f46019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf5f46b62f853f383cb8fb3d7f46019">&#9670;&nbsp;</a></span>zunionstore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; coro_redis::sync_connection::zunionstore </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string_view, double &gt;&gt;&#160;</td>
          <td class="paramname"><em>kvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>aggregate</em> = <code>&quot;SUM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get union of multiple sorted sets, and store the result to another one. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Use the default weight, i.e. 1,</span></div>
<div class="line"><span class="comment">// and use the sum of the all scores as the score of the result:</span></div>
<div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;k1&quot;</span>, <span class="stringliteral">&quot;k2&quot;</span>, <span class="stringliteral">&quot;k3&quot;</span>};</div>
<div class="line">redis.zunionstore(<span class="stringliteral">&quot;destination&quot;</span>, keys.begin(), keys.end());</div>
<div class="line"><span class="comment">// Each sorted set has a different weight,</span></div>
<div class="line"><span class="comment">// and the score of the result is the min of all scores.</span></div>
<div class="line">std::vector&lt;std::pair&lt;std::string, double&gt;&gt; keys_with_weights = {{<span class="stringliteral">&quot;k1&quot;</span>,</div>
<div class="line">1}, {<span class="stringliteral">&quot;k2&quot;</span>, 2}}; redis.zunionstore(<span class="stringliteral">&quot;destination&quot;</span>,</div>
<div class="line">keys_with_weights.begin(),</div>
<div class="line">    keys_with_weights.end(), Aggregation::MIN);</div>
<div class="line"><span class="comment">// NOTE: `keys_with_weights` can also be of type</span></div>
<div class="line">`std::unordered_map&lt;std::string, double&gt;`.</div>
<div class="line"><span class="comment">// However, it will be slower than std::vector&lt;std::pair&lt;std::string,</span></div>
<div class="line">double&gt;&gt;, since we use</div>
<div class="line"><span class="comment">// `std::distance(first, last)` to calculate the *numkeys* parameter.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Key of the destination sorted set. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first sorted set (might with weight). </td></tr>
    <tr><td class="paramname">last</td><td>Off-the-end iterator to the sorted set range. </td></tr>
    <tr><td class="paramname">type</td><td>How the scores are aggregated.<ul>
<li>Aggregation::SUM: Score of a member is the sum of all scores.</li>
<li>Aggregation::MIN: Score of a member is the min of all scores.</li>
<li>Aggregation::MAX: Score of a member is the max of all scores. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of members in the resulting sorted set. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The score of each member can be multiplied by a factor, i.e. weight. If <code>Input</code> is an iterator to a container of <code>std::string</code>, we use the default weight, i.e. 1, and send <em>ZUNIONSTORE dest numkeys key [key ...] [AGGREGATE SUM|MIN|MAX]</em> command. If <code>Input</code> is an iterator to a container of <code>std::pair&lt;std::string, double&gt;</code>, i.e. key-weight pair, we send the command with the given weights: <em>ZUNIONSTORE dest numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</em>. See the <em>Example</em> part for examples on how to use this command. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>Redis::zinterstore</code> </dd>
<dd>
<a href="https://redis.io/commands/zunionstore">https://redis.io/commands/zunionstore</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/coro_redis/<a class="el" href="sync__connection_8hpp_source.html">sync_connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
